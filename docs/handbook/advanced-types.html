<!DOCTYPE html lang="en">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us" lang="en">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Advanced Types &middot; TypeScript
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/vendor.91c84422.css">

  <link rel="stylesheet" href="/assets/css/style.min.ea760870.css">

  <!-- Icons --> <!-- TODO: Check that these all wok -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/icons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/icons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/icons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/icons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/icons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/icons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/icons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/icons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/icons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/assets/images/icons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/assets/images/icons/manifest.json">
  <link rel="mask-icon" href="/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/icons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/assets/images/icons/mstile-144x144.png">
  <meta name="msapplication-config" content="/assets/images/icons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">

  <!-- JS -->
  <script src="/assets/js/vendors.4960e48a.js"></script>

  <!-- JS -->
  <script src="/assets/js/all.min.0df14029.js"></script>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Application Insights in Azure -->
  <script type="text/javascript">
    var sdkInstance="appInsightsSDK";window[sdkInstance]="appInsights";var aiName=window[sdkInstance],aisdk=window[aiName]||function(e){function n(e){t[e]=function(){var n=arguments;t.queue.push(function(){t[e].apply(t,n)})}}var t={config:e};t.initialize=!0;var i=document,a=window;setTimeout(function(){var n=i.createElement("script");n.async = true;n.src=e.url||"https://az416426.vo.msecnd.net/scripts/b/ai.2.min.js",i.getElementsByTagName("script")[0].parentNode.appendChild(n)});try{t.cookie=i.cookie}catch(e){}t.queue=[],t.version=2;for(var r=["Event","PageView","Exception","Trace","DependencyData","Metric","PageViewPerformance"];r.length;)n("track"+r.pop());n("startTrackPage"),n("stopTrackPage");var s="Track"+r[0];if(n("start"+s),n("stop"+s),n("setAuthenticatedUserContext"),n("clearAuthenticatedUserContext"),n("flush"),!(!0===e.disableExceptionTracking||e.extensionConfig&&e.extensionConfig.ApplicationInsightsAnalytics&&!0===e.extensionConfig.ApplicationInsightsAnalytics.disableExceptionTracking)){n("_"+(r="onerror"));var o=a[r];a[r]=function(e,n,i,a,s){var c=o&&o(e,n,i,a,s);return!0!==c&&t["_"+r]({message:e,url:n,lineNumber:i,columnNumber:a,error:s}),c},e.autoExceptionInstrumented=!0}return t}({ instrumentationKey: "78a8fb52-a225-4c66-ac08-92fad1c1ade1" });window[aiName]=aisdk
    if (aisdk.queue && 0 === aisdk.queue.length) {
        const locationWithoutPlaygroundCode = document.location.href.split("#code")[0].split("#src")[0]
        const referrerWithoutPlaygroundCode = document.referrer && document.referrer.split("#code")[0].split("#src")[0]
        aisdk.trackPageView({ uri: locationWithoutPlaygroundCode, refUri: referrerWithoutPlaygroundCode });
    }
  </script>

  <!-- Search -->
  <link rel="stylesheet" href="/assets/stylesheets/docsearch.css" />

</head>

<body>
	<a href="#main-content" class="main-content-skip" tabindex="0">
    Skip to main content
</a>
    <header role="banner">
    <nav role="navigation" class="navbar navbar-default navbar-fixed-top">
         <div class="container-fluid">
            <!-- Contains the logo and a toggle button for smaller screen sizes. -->
            <div class="navbar-header">
              <!-- Toggles the visibility of the nav area on smaller screen sizes. -->
              <button type="button" class="navbar-toggle pull-left collapsed" data-toggle="collapse" data-target="#navbar-collapse-div">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <!-- Top-left logo. -->
              <a class="navbar-brand" href="/index.html" aria-label="TypeScript Home Page">
                <img class="navbar-logo" src="/assets/images/logo_nocircle.svg" alt="TypeScript logo"/>
              </a>
            </div>

            <!-- The navigation items. -->
            <div class="collapse navbar-collapse centered-navbar" id="navbar-collapse-div">
              <ul class="nav navbar-nav">
                <li class="active"><a href="/docs/index.html">Documentation </a></li>
                <li><a href="/index.html#download-links">Download</a></li>
                <li class=""><a href="/community/index.html">Connect</a></li>
                <li class=""><a href="/play/index.html">Playground</a></li>
              </ul>

              <form class="navbar-form navbar-right" role="search">
                <div class="form-group">
                  <input type="search" class="form-control site-search" placeholder="Search">
                </div>
              </form>
            </div>
        </div>
    </nav>
</header>

	<div class="container-fluid update-banner">
	<div class="container">
		TypeScript <a href="/docs/handbook/release-notes/typescript-3-7.html">3.7</a> is now available. <a href="/#download-links" aria-label="Download the latest version of TypeScript">Get</a> the latest version today!
	</div>
</div>

	<main id="main-content" class="content">
		<div id="doc-content" class="container-fluid fill docs-container">
        <a id='try-beta'>Try v2 Beta Page</a>
        <script>
          const tryBeta = document.getElementById("try-beta")
          const mobile = window.outerWidth < 800
          const isHome = document.location.pathname === "/docs/home.html"
          if (!mobile && !isHome) {
            tryBeta.style.display = "block";

            tryBeta.onclick = () => {
              document.location.pathname = "v2" + document.location.pathname
            }
          }
        </script>
        <div class="container">

        <div class="col-md-2 toc-container hidden-xs hidden-sm">
          <nav class="docs-nav visible-md visible-lg affix-top" id="docs-navbar">
  <ul class="nav" id="main-nav">
    
    <li class="panel"><a class="docs-home" href="/docs/home.html">Documentation</a></li>    					

    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-tutorials" data-toggle="collapse" data-parent="#main-nav">Tutorials</a>         
        <ul class="collapse" id="toc-tutorials" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/typescript-in-5-minutes.html>TypeScript in 5 minutes</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/asp-net-core.html>ASP.NET Core</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/gulp.html>Gulp</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/migrating-from-javascript.html>Migrating from JavaScript</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/react-&-webpack.html>React & Webpack</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-whats-new" data-toggle="collapse" data-parent="#main-nav">What's New</a>         
        <ul class="collapse" id="toc-whats-new" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/overview.html>Overview</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-7.html>TypeScript 3.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-6.html>TypeScript 3.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-5.html>TypeScript 3.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-4.html>TypeScript 3.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-3.html>TypeScript 3.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-2.html>TypeScript 3.2</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-1.html>TypeScript 3.1</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-0.html>TypeScript 3.0</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-9.html>TypeScript 2.9</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-8.html>TypeScript 2.8</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-7.html>TypeScript 2.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-6.html>TypeScript 2.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-5.html>TypeScript 2.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-4.html>TypeScript 2.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-3.html>TypeScript 2.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-2.html>TypeScript 2.2</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-1.html>TypeScript 2.1</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-0.html>TypeScript 2.0</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-8.html>TypeScript 1.8</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-7.html>TypeScript 1.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-6.html>TypeScript 1.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-5.html>TypeScript 1.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-4.html>TypeScript 1.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-3.html>TypeScript 1.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-1.html>TypeScript 1.1</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-handbook" data-toggle="collapse" data-parent="#main-nav">Handbook</a>         
        <ul class="collapse" id="toc-handbook" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/basic-types.html>Basic Types</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/variable-declarations.html>Variable Declarations</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/interfaces.html>Interfaces</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/classes.html>Classes</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/functions.html>Functions</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/generics.html>Generics</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/enums.html>Enums</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-inference.html>Type Inference</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-compatibility.html>Type Compatibility</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/advanced-types.html class="active">Advanced Types</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/symbols.html>Symbols</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/iterators-and-generators.html>Iterators and Generators</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/modules.html>Modules</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/namespaces.html>Namespaces</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/namespaces-and-modules.html>Namespaces and Modules</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/module-resolution.html>Module Resolution</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-merging.html>Declaration Merging</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/jsx.html>JSX</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/decorators.html>Decorators</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/mixins.html>Mixins</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/triple-slash-directives.html>Triple-Slash Directives</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-checking-javascript-files.html>Type Checking JavaScript Files</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/utility-types.html>Utility Types</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-declaration-files" data-toggle="collapse" data-parent="#main-nav">Declaration Files</a>         
        <ul class="collapse" id="toc-declaration-files" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/introduction.html>Introduction</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/library-structures.html>Library Structures</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/by-example.html>By Example</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/do-s-and-don-ts.html>Do's and Don'ts</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/deep-dive.html>Deep Dive</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/templates.html>Templates</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/publishing.html>Publishing</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/consumption.html>Consumption</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-project-config" data-toggle="collapse" data-parent="#main-nav">Project Configuration</a>         
        <ul class="collapse" id="toc-project-config" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/tsconfig-json.html>tsconfig.json</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/compiler-options.html>Compiler Options</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/project-references.html>Project References</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/compiler-options-in-msbuild.html>Compiler Options in MSBuild</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/integrating-with-build-tools.html>Integrating with Build Tools</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/nightly-builds.html>Nightly Builds</a>
                </li>
            
        </ul>
    </li>
        
    
	</ul>
</nav>

        </div>
        <div class="col-md-10 col-xs-12 col-sm-12  doc-content-container">
          <div class="xs-toc-container visible-xs visible-sm">
            <nav class='xs-toc'>
  <div class="toc-dropdown">
    <a class="btn btn-primary btn-sm dropdown-toggle" data-toggle="dropdown" href="#">
      Documentation
      <span class="caret"></span>
    </a>
    <ul class="dropdown-menu">
      <li>
        <a href="/docs/home.html">Documentation</a>
      </li>
      
      <li>
          <ul>
      <h2>
        
        
          Tutorials
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/typescript-in-5-minutes.html>TypeScript in 5 minutes</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/asp-net-core.html>ASP.NET Core</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/gulp.html>Gulp</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/migrating-from-javascript.html>Migrating from JavaScript</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/react-&-webpack.html>React & Webpack</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          What's New
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/overview.html>Overview</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-7.html>TypeScript 3.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-6.html>TypeScript 3.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-5.html>TypeScript 3.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-4.html>TypeScript 3.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-3.html>TypeScript 3.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-2.html>TypeScript 3.2</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-1.html>TypeScript 3.1</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-0.html>TypeScript 3.0</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-9.html>TypeScript 2.9</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-8.html>TypeScript 2.8</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-7.html>TypeScript 2.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-6.html>TypeScript 2.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-5.html>TypeScript 2.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-4.html>TypeScript 2.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-3.html>TypeScript 2.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-2.html>TypeScript 2.2</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-1.html>TypeScript 2.1</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-0.html>TypeScript 2.0</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-8.html>TypeScript 1.8</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-7.html>TypeScript 1.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-6.html>TypeScript 1.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-5.html>TypeScript 1.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-4.html>TypeScript 1.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-3.html>TypeScript 1.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-1.html>TypeScript 1.1</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Handbook
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/basic-types.html>Basic Types</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/variable-declarations.html>Variable Declarations</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/interfaces.html>Interfaces</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/classes.html>Classes</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/functions.html>Functions</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/generics.html>Generics</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/enums.html>Enums</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-inference.html>Type Inference</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-compatibility.html>Type Compatibility</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/advanced-types.html class="active">Advanced Types</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/symbols.html>Symbols</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/iterators-and-generators.html>Iterators and Generators</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/modules.html>Modules</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/namespaces.html>Namespaces</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/namespaces-and-modules.html>Namespaces and Modules</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/module-resolution.html>Module Resolution</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-merging.html>Declaration Merging</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/jsx.html>JSX</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/decorators.html>Decorators</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/mixins.html>Mixins</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/triple-slash-directives.html>Triple-Slash Directives</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-checking-javascript-files.html>Type Checking JavaScript Files</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/utility-types.html>Utility Types</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Declaration Files
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/introduction.html>Introduction</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/library-structures.html>Library Structures</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/by-example.html>By Example</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/do-s-and-don-ts.html>Do's and Don'ts</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/deep-dive.html>Deep Dive</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/templates.html>Templates</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/publishing.html>Publishing</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/consumption.html>Consumption</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Project Configuration
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/tsconfig-json.html>tsconfig.json</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/compiler-options.html>Compiler Options</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/project-references.html>Project References</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/compiler-options-in-msbuild.html>Compiler Options in MSBuild</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/integrating-with-build-tools.html>Integrating with Build Tools</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/nightly-builds.html>Nightly Builds</a>
                  </li>
              
          </ul>
      </li>
      
    </ul>
  </div>    
</nav>

          </div>
    <header class="post-header">
      <h1 class="post-title">
        
        
          Advanced Types
        
        
      </header>
          <article class="post-content">
              <p></p>
    
      <h1 id="table-of-contents">
        
        
          Table of contents <a aria-label="Link to the header: Table of contents" title="Link to the header: Table of contents" href="#table-of-contents" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p><a href="#intersection-types">Intersection Types</a></p>

<p><a href="#union-types">Union Types</a></p>

<p><a href="#type-guards-and-differentiating-types">Type Guards and Differentiating Types</a></p>
<ul>
  <li><a href="#user-defined-type-guards">User-Defined Type Guards</a>
    <ul>
      <li><a href="#using-type-predicates">Using type predicates</a></li>
      <li><a href="#using-the-in-operator">Using the <code>in</code> operator</a></li>
    </ul>
  </li>
  <li><a href="#typeof-type-guards"><code>typeof</code> type guards</a></li>
  <li><a href="#instanceof-type-guards"><code>instanceof</code> type guards</a></li>
</ul>

<p><a href="#nullable-types">Nullable types</a></p>
<ul>
  <li><a href="#optional-parameters-and-properties">Optional parameters and properties</a></li>
  <li><a href="#type-guards-and-type-assertions">Type guards and type assertions</a></li>
</ul>

<p><a href="#type-aliases">Type Aliases</a></p>
<ul>
  <li><a href="#interfaces-vs-type-aliases">Interfaces vs. Type Aliases</a></li>
</ul>

<p><a href="#string-literal-types">String Literal Types</a></p>

<p><a href="#numeric-literal-types">Numeric Literal Types</a></p>

<p><a href="#enum-member-types">Enum Member Types</a></p>

<p><a href="#discriminated-unions">Discriminated Unions</a></p>
<ul>
  <li><a href="#exhaustiveness-checking">Exhaustiveness checking</a></li>
</ul>

<p><a href="#polymorphic-this-types">Polymorphic <code>this</code> types</a></p>

<p><a href="#index-types">Index types</a></p>
<ul>
  <li><a href="#index-types-and-index-signatures">Index types and index signatures</a></li>
</ul>

<p><a href="#mapped-types">Mapped types</a></p>
<ul>
  <li><a href="#inference-from-mapped-types">Inference from mapped types</a></li>
</ul>

<p><a href="#conditional-types">Conditional Types</a></p>
<ul>
  <li><a href="#distributive-conditional-types">Distributive conditional types</a></li>
  <li><a href="#type-inference-in-conditional-types">Type inference in conditional types</a></li>
  <li><a href="#predefined-conditional-types">Predefined conditional types</a></li>
</ul>
    
      <h1 id="intersection-types">
        
        
          Intersection Types <a aria-label="Link to the header: Intersection Types" title="Link to the header: Intersection Types" href="#intersection-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>An intersection type combines multiple types into one.
This allows you to add together existing types to get a single type that has all the features you need.
For example, <code>Person &amp; Serializable &amp; Loggable</code> is a <code>Person</code> <em>and</em> <code>Serializable</code> <em>and</em> <code>Loggable</code>.
That means an object of this type will have all members of all three types.</p>

<p>You will mostly see intersection types used for mixins and other concepts that don’t fit in the classic object-oriented mold.
(There are a lot of these in JavaScript!)
Here’s a simple example that shows how to create a mixin:</p>

<pre><code class="language-ts">function extend&lt;First, Second&gt;(first: First, second: Second): First &amp; Second {
    const result: Partial&lt;First &amp; Second&gt; = {};
    for (const prop in first) {
        if (first.hasOwnProperty(prop)) {
            (result as First)[prop] = first[prop];
        }
    }
    for (const prop in second) {
        if (second.hasOwnProperty(prop)) {
            (result as Second)[prop] = second[prop];
        }
    }
    return result as First &amp; Second;
}

class Person {
    constructor(public name: string) { }
}

interface Loggable {
    log(name: string): void;
}

class ConsoleLogger implements Loggable {
    log(name) {
        console.log(`Hello, I'm ${name}.`);
    }
}

const jim = extend(new Person('Jim'), ConsoleLogger.prototype);
jim.log(jim.name);
</code></pre>
    
      <h1 id="union-types">
        
        
          Union Types <a aria-label="Link to the header: Union Types" title="Link to the header: Union Types" href="#union-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>Union types are closely related to intersection types, but they are used very differently.
Occasionally, you’ll run into a library that expects a parameter to be either a <code>number</code> or a <code>string</code>.
For instance, take the following function:</p>

<pre><code class="language-ts">/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: any) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"
</code></pre>

<p>The problem with <code>padLeft</code> is that its <code>padding</code> parameter is typed as <code>any</code>.
That means that we can call it with an argument that’s neither a <code>number</code> nor a <code>string</code>, but TypeScript will be okay with it.</p>

<pre><code class="language-ts">let indentedString = padLeft("Hello world", true); // passes at compile time, fails at runtime.
</code></pre>

<p>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types.
While this is much more explicit, it’s also a little bit overkill.
One of the nice things about the original version of <code>padLeft</code> was that we were able to just pass in primitives.
That meant that usage was simple and concise.
This new approach also wouldn’t help if we were just trying to use a function that already exists elsewhere.</p>

<p>Instead of <code>any</code>, we can use a <em>union type</em> for the <code>padding</code> parameter:</p>

<pre><code class="language-ts">/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft("Hello world", true); // errors during compilation
</code></pre>

<p>A union type describes a value that can be one of several types.
We use the vertical bar (<code>|</code>) to separate each type, so <code>number | string | boolean</code> is the type of a value that can be a <code>number</code>, a <code>string</code>, or a <code>boolean</code>.</p>

<p>If we have a value that has a union type, we can only access members that are common to all types in the union.</p>

<pre><code class="language-ts">interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
</code></pre>

<p>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to.
If a value has the type <code>A | B</code>, we only know for <em>certain</em> that it has members that both <code>A</code> <em>and</em> <code>B</code> have.
In this example, <code>Bird</code> has a member named <code>fly</code>.
We can’t be sure whether a variable typed as <code>Bird | Fish</code> has a <code>fly</code> method.
If the variable is really a <code>Fish</code> at runtime, then calling <code>pet.fly()</code> will fail.</p>
    
      <h1 id="type-guards-and-differentiating-types">
        
        
          Type Guards and Differentiating Types <a aria-label="Link to the header: Type Guards and Differentiating Types" title="Link to the header: Type Guards and Differentiating Types" href="#type-guards-and-differentiating-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>Union types are useful for modeling situations when values can overlap in the types they can take on.
What happens when we need to know specifically whether we have a <code>Fish</code>?
A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member.
As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p>

<pre><code class="language-ts">let pet = getSmallPet();

// Each of these property accesses will cause an error
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}
</code></pre>

<p>To get the same code working, we’ll need to use a type assertion:</p>

<pre><code class="language-ts">let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
</code></pre>
    
      <h2 id="user-defined-type-guards">
        
        
          User-Defined Type Guards <a aria-label="Link to the header: User-Defined Type Guards" title="Link to the header: User-Defined Type Guards" href="#user-defined-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Notice that we had to use type assertions several times.
It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p>

<p>It just so happens that TypeScript has something called a <em>type guard</em>.
A type guard is some expression that performs a runtime check that guarantees the type in some scope.</p>
    
      <h3 id="using-type-predicates">
        
        
          Using type predicates <a aria-label="Link to the header: Using type predicates" title="Link to the header: Using type predicates" href="#using-type-predicates" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p>

<pre><code class="language-ts">function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}
</code></pre>

<p><code>pet is Fish</code> is our type predicate in this example.
A predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p>

<p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p>

<pre><code class="language-ts">// Both calls to 'swim' and 'fly' are now okay.

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
</code></pre>

<p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch;
it also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p>
    
      <h3 id="using-the-in-operator">
        
        
          Using the <code>in</code> operator <a aria-label="Link to the header: Using the in operator" title="Link to the header: Using the in operator" href="#using-the-in-operator" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The <code>in</code> operator now acts as a narrowing expression for types.</p>

<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p>

<pre><code class="language-ts">function move(pet: Fish | Bird) {
    if ("swim" in pet) {
        return pet.swim();
    }
    return pet.fly();
}
</code></pre>
    
      <h2 id="typeof-type-guards">
        
        
          <code>typeof</code> type guards <a aria-label="Link to the header: typeof type guards" title="Link to the header: typeof type guards" href="#typeof-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Let’s go back and write the code for the version of <code>padLeft</code> that uses union types.
We could write it with type predicates as follows:</p>

<pre><code class="language-ts">function isNumber(x: any): x is number {
    return typeof x === "number";
}

function isString(x: any): x is string {
    return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
    if (isNumber(padding)) {
        return Array(padding + 1).join(" ") + value;
    }
    if (isString(padding)) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>

<p>However, having to define a function to figure out if a type is a primitive is kind of a pain.
Luckily, you don’t need to abstract <code>typeof x === "number"</code> into its own function because TypeScript will recognize it as a type guard on its own.
That means we could just write these checks inline.</p>

<pre><code class="language-ts">function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>

<p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === "typename"</code> and <code>typeof v !== "typename"</code>, where <code>"typename"</code> must be <code>"number"</code>, <code>"string"</code>, <code>"boolean"</code>, or <code>"symbol"</code>.
While TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.</p>
    
      <h2 id="instanceof-type-guards">
        
        
          <code>instanceof</code> type guards <a aria-label="Link to the header: instanceof type guards" title="Link to the header: instanceof type guards" href="#instanceof-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p>

<p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function.
For instance, let’s borrow our industrial string-padder example from earlier:</p>

<pre><code class="language-ts">interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(" ");
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() &lt; 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// Type is 'SpaceRepeatingPadder | StringPadder'
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // type narrowed to 'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // type narrowed to 'StringPadder'
}
</code></pre>

<p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p>

<ol>
  <li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code></li>
  <li>the union of types returned by that type’s construct signatures</li>
</ol>

<p>in that order.</p>
    
      <h1 id="nullable-types">
        
        
          Nullable types <a aria-label="Link to the header: Nullable types" title="Link to the header: Nullable types" href="#nullable-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively.
We mentioned these briefly in <a href="./basic-types.html">the Basic Types section</a>.
By default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything.
Effectively, <code>null</code> and <code>undefined</code> are valid values of every type.
That means it’s not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it.
The inventor of <code>null</code>, Tony Hoare, calls this his <a href="https://en.wikipedia.org/wiki/Null_pointer#History">“billion dollar mistake”</a>.</p>

<p>The <code>--strictNullChecks</code> flag fixes this: when you declare a variable, it doesn’t automatically include <code>null</code> or <code>undefined</code>.
You can include them explicitly using a union type:</p>

<pre><code class="language-ts">let s = "foo";
s = null; // error, 'null' is not assignable to 'string'
let sn: string | null = "bar";
sn = null; // ok

sn = undefined; // error, 'undefined' is not assignable to 'string | null'
</code></pre>

<p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics.
<code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.</p>

<p>From TypeScript 3.7 and onwards, you can use <a href="/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">optional chaining</a> to simplify working with nullable types.</p>
    
      <h2 id="optional-parameters-and-properties">
        
        
          Optional parameters and properties <a aria-label="Link to the header: Optional parameters and properties" title="Link to the header: Optional parameters and properties" href="#optional-parameters-and-properties" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With <code>--strictNullChecks</code>, an optional parameter automatically adds <code>| undefined</code>:</p>

<pre><code class="language-ts">function f(x: number, y?: number) {
    return x + (y || 0);
}
f(1, 2);
f(1);
f(1, undefined);
f(1, null); // error, 'null' is not assignable to 'number | undefined'
</code></pre>

<p>The same is true for optional properties:</p>

<pre><code class="language-ts">class C {
    a: number;
    b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'
</code></pre>
    
      <h2 id="type-guards-and-type-assertions">
        
        
          Type guards and type assertions <a aria-label="Link to the header: Type guards and type assertions" title="Link to the header: Type guards and type assertions" href="#type-guards-and-type-assertions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>.
Fortunately, this is the same code you’d write in JavaScript:</p>

<pre><code class="language-ts">function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
</code></pre>

<p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p>

<pre><code class="language-ts">function f(sn: string | null): string {
    return sn || "default";
}
</code></pre>

<p>In cases where the compiler can’t eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them.
The syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:</p>

<pre><code class="language-ts">function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}

function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
</code></pre>

<p>The example uses a nested function here because the compiler can’t eliminate nulls inside a nested function (except immediately-invoked function expressions).
That’s because it can’t track all calls to the nested function, especially if you return it from the outer function.
Without knowing where the function is called, it can’t know what the type of <code>name</code> will be at the time the body executes.</p>
    
      <h1 id="type-aliases">
        
        
          Type Aliases <a aria-label="Link to the header: Type Aliases" title="Link to the header: Type Aliases" href="#type-aliases" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>Type aliases create a new name for a type.
Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p>

<pre><code class="language-ts">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === "string") {
        return n;
    }
    else {
        return n();
    }
}
</code></pre>

<p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type.
Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p>

<p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p>

<pre><code class="language-ts">type Container&lt;T&gt; = { value: T };
</code></pre>

<p>We can also have a type alias refer to itself in a property:</p>

<pre><code class="language-ts">type Tree&lt;T&gt; = {
    value: T;
    left: Tree&lt;T&gt;;
    right: Tree&lt;T&gt;;
}
</code></pre>

<p>Together with intersection types, we can make some pretty mind-bending types:</p>

<pre><code class="language-ts">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };

interface Person {
    name: string;
}

var people: LinkedList&lt;Person&gt;;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;
</code></pre>

<p>However, it’s not possible for a type alias to appear anywhere else on the right side of the declaration:</p>

<pre><code class="language-ts">type Yikes = Array&lt;Yikes&gt;; // error
</code></pre>
    
      <h2 id="interfaces-vs-type-aliases">
        
        
          Interfaces vs. Type Aliases <a aria-label="Link to the header: Interfaces vs. Type Aliases" title="Link to the header: Interfaces vs. Type Aliases" href="#interfaces-vs-type-aliases" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>

<p>One difference is that interfaces create a new name that is used everywhere.
Type aliases don’t create a new name — for instance, error messages won’t use the alias name.
In the code below, hovering over <code>interfaced</code> in an editor will show that it returns an <code>Interface</code>, but will show that <code>aliased</code> returns object literal type.</p>

<pre><code class="language-ts">type Alias = { num: number }
interface Interface {
    num: number;
}
declare function aliased(arg: Alias): Alias;
declare function interfaced(arg: Interface): Interface;
</code></pre>

<p>In older versions of TypeScript, type aliases couldn’t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. <code>type Cat = Animal &amp; { purrs: true }</code>.</p>

<p>Because <a href="https://en.wikipedia.org/wiki/Open/closed_principle">an ideal property of software is being open to extension</a>, you should always use an interface over a type alias if possible.</p>

<p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p>
    
      <h1 id="string-literal-types">
        
        
          String Literal Types <a aria-label="Link to the header: String Literal Types" title="Link to the header: String Literal Types" href="#string-literal-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>String literal types allow you to specify the exact value a string must have.
In practice string literal types combine nicely with union types, type guards, and type aliases.
You can use these features together to get enum-like behavior with strings.</p>

<pre><code class="language-ts">type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {
            // ...
        }
        else if (easing === "ease-out") {
        }
        else if (easing === "ease-in-out") {
        }
        else {
            // error! should not pass null or undefined.
        }
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
</code></pre>

<p>You can pass any of the three allowed strings, but any other string will give the error</p>

<pre><code class="language-text">Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
</code></pre>

<p>String literal types can be used in the same way to distinguish overloads:</p>

<pre><code class="language-ts">function createElement(tagName: "img"): HTMLImageElement;
function createElement(tagName: "input"): HTMLInputElement;
// ... more overloads ...
function createElement(tagName: string): Element {
    // ... code goes here ...
}
</code></pre>
    
      <h1 id="numeric-literal-types">
        
        
          Numeric Literal Types <a aria-label="Link to the header: Numeric Literal Types" title="Link to the header: Numeric Literal Types" href="#numeric-literal-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>TypeScript also has numeric literal types.</p>

<pre><code class="language-ts">function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {
    // ...
}
</code></pre>

<p>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</p>

<pre><code class="language-ts">function foo(x: number) {
    if (x !== 1 || x !== 2) {
        //         ~~~~~~~
        // Operator '!==' cannot be applied to types '1' and '2'.
    }
}
</code></pre>

<p>In other words, <code>x</code> must be <code>1</code> when it gets compared to <code>2</code>, meaning that the above check is making an invalid comparison.</p>
    
      <h1 id="enum-member-types">
        
        
          Enum Member Types <a aria-label="Link to the header: Enum Member Types" title="Link to the header: Enum Member Types" href="#enum-member-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>As mentioned in <a href="./enums.html#union-enums-and-enum-member-types">our section on enums</a>, enum members have types when every member is literal-initialized.</p>

<p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.</p>
    
      <h1 id="discriminated-unions">
        
        
          Discriminated Unions <a aria-label="Link to the header: Discriminated Unions" title="Link to the header: Discriminated Unions" href="#discriminated-unions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called <em>discriminated unions</em>, also known as <em>tagged unions</em> or <em>algebraic data types</em>.
Discriminated unions are useful in functional programming.
Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today.
There are three ingredients:</p>

<ol>
  <li>Types that have a common, singleton type property — the <em>discriminant</em>.</li>
  <li>A type alias that takes the union of those types — the <em>union</em>.</li>
  <li>Type guards on the common property.</li>
</ol>

<pre><code class="language-ts">interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}
</code></pre>

<p>First we declare the interfaces we will union.
Each interface has a <code>kind</code> property with a different string literal type.
The <code>kind</code> property is called the <em>discriminant</em> or <em>tag</em>.
The other properties are specific to each interface.
Notice that the interfaces are currently unrelated.
Let’s put them into a union:</p>

<pre><code class="language-ts">type Shape = Square | Rectangle | Circle;
</code></pre>

<p>Now let’s use the discriminated union:</p>

<pre><code class="language-ts">function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
</code></pre>
    
      <h2 id="exhaustiveness-checking">
        
        
          Exhaustiveness checking <a aria-label="Link to the header: Exhaustiveness checking" title="Link to the header: Exhaustiveness checking" href="#exhaustiveness-checking" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>We would like the compiler to tell us when we don’t cover all variants of the discriminated union.
For example, if we add <code>Triangle</code> to <code>Shape</code>, we need to update <code>area</code> as well:</p>

<pre><code class="language-ts">type Shape = Square | Rectangle | Circle | Triangle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
    // should error here - we didn't handle case "triangle"
}
</code></pre>

<p>There are two ways to do this.
The first is to turn on <code>--strictNullChecks</code> and specify a return type:</p>

<pre><code class="language-ts">function area(s: Shape): number { // error: returns number | undefined
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
</code></pre>

<p>Because the <code>switch</code> is no longer exhaustive, TypeScript is aware that the function could sometimes return <code>undefined</code>.
If you have an explicit return type <code>number</code>, then you will get an error that the return type is actually <code>number | undefined</code>.
However, this method is quite subtle and, besides, <code>--strictNullChecks</code> does not always work with old code.</p>

<p>The second method uses the <code>never</code> type that the compiler uses to check for exhaustiveness:</p>

<pre><code class="language-ts">function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}
</code></pre>

<p>Here, <code>assertNever</code> checks that <code>s</code> is of type <code>never</code> — the type that’s left after all other cases have been removed.
If you forget a case, then <code>s</code> will have a real type and you will get a type error.
This method requires you to define an extra function, but it’s much more obvious when you forget it.</p>
    
      <h1 id="polymorphic-this-types">
        
        
          Polymorphic <code>this</code> types <a aria-label="Link to the header: Polymorphic this types" title="Link to the header: Polymorphic this types" href="#polymorphic-this-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface.
This is called <em>F</em>-bounded polymorphism.
This makes hierarchical fluent interfaces much easier to express, for example.
Take a simple calculator that returns <code>this</code> after each operation:</p>

<pre><code class="language-ts">class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
    // ... other operations go here ...
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();
</code></pre>

<p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p>

<pre><code class="language-ts">class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... other operations go here ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();
</code></pre>

<p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface.
<code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method.
However, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p>
    
      <h1 id="index-types">
        
        
          Index types <a aria-label="Link to the header: Index types" title="Link to the header: Index types" href="#index-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>With index types, you can get the compiler to check code that uses dynamic property names.
For example, a common JavaScript pattern is to pick a subset of properties from an object:</p>

<pre><code class="language-js">function pluck(o, propertyNames) {
    return propertyNames.map(n =&gt; o[n]);
}
</code></pre>

<p>Here’s how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:</p>

<pre><code class="language-ts">function pluck&lt;T, K extends keyof T&gt;(o: T, propertyNames: K[]): T[K][] {
  return propertyNames.map(n =&gt; o[n]);
}

interface Car {
    manufacturer: string;
    model: string;
    year: number;
}
let taxi: Car = {
    manufacturer: 'Toyota',
    model: 'Camry',
    year: 2014
};

// Manufacturer and model are both of type string,
// so we can pluck them both into a typed string array
let makeAndModel: string[] = pluck(taxi, ['manufacturer', 'model']);

// If we try to pluck model and year, we get an
// array of a union type: (string | number)[]
let modelYear = pluck(taxi, ['model', 'year'])
</code></pre>

<p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>.
The example introduces a couple of new type operators.
First is <code>keyof T</code>, the <strong>index type query operator</strong>.
For any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>.
For example:</p>

<pre><code class="language-ts">let carProps: keyof Car; // the union of ('manufacturer' | 'model' | 'year')
</code></pre>

<p><code>keyof Car</code> is completely interchangeable with <code>'manufacturer' | 'model' | 'year'</code>.
The difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>'manufacturer' | 'model' | 'year' | 'ownersAddress'</code>.
And you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can’t possibly know the property names ahead of time.
That means the compiler will check that you pass the right set of property names to <code>pluck</code>:</p>

<pre><code class="language-ts">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'
pluck(taxi, ['year', 'unknown']); /
</code></pre>

<p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>.
Here, the type syntax reflects the expression syntax.
That means that <code>person['name']</code> has the type <code>Person['name']</code> — which in our example is just <code>string</code>.
However, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life.
You just have to make sure that the type variable <code>K extends keyof T</code>.
Here’s another example with a function named <code>getProperty</code>.</p>

<pre><code class="language-ts">function getProperty&lt;T, K extends keyof T&gt;(o: T, propertyName: K): T[K] {
    return o[propertyName]; // o[propertyName] is of type T[K]
}
</code></pre>

<p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>.
Once you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.</p>

<pre><code class="language-ts">let name: string = getProperty(taxi, 'manufacturer');
let year: number = getProperty(taxi, 'year');

// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'
let unknown = getProperty(taxi, 'unknown');
</code></pre>
    
      <h2 id="index-types-and-index-signatures">
        
        
          Index types and index signatures <a aria-label="Link to the header: Index types and index signatures" title="Link to the header: Index types and index signatures" href="#index-types-and-index-signatures" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’.
If you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code>
(and not just <code>string</code>, since in JavaScript you can access an object property either
by using strings (<code>object['42'</code>]) or numbers (<code>object[42]</code>)).
And <code>T[string]</code> is just the type of the index signature:</p>

<pre><code class="language-ts">interface Dictionary&lt;T&gt; {
    [key: string]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // string | number
let value: Dictionary&lt;number&gt;['foo']; // number
</code></pre>

<p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.</p>

<pre><code class="language-ts">interface Dictionary&lt;T&gt; {
    [key: number]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // number
let value: Dictionary&lt;number&gt;['foo']; // Error, Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.
let value: Dictionary&lt;number&gt;[42]; // number
</code></pre>
    
      <h1 id="mapped-types">
        
        
          Mapped types <a aria-label="Link to the header: Mapped types" title="Link to the header: Mapped types" href="#mapped-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>A common task is to take an existing type and make each of its properties optional:</p>

<pre><code class="language-ts">interface PersonPartial {
    name?: string;
    age?: number;
}
</code></pre>

<p>Or we might want a readonly version:</p>

<pre><code class="language-ts">interface PersonReadonly {
    readonly name: string;
    readonly age: number;
}
</code></pre>

<p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>.
In a mapped type, the new type transforms each property in the old type in the same way.
For example, you can make all properties of a type <code>readonly</code> or optional.
Here are a couple of examples:</p>

<pre><code class="language-ts">type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
}
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
}
</code></pre>

<p>And to use it:</p>

<pre><code class="language-ts">type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;
</code></pre>

<p>Note that this syntax describes a type rather than a member.
If you want to add members, you can use an intersection type:</p>

<pre><code class="language-ts">// Use this:
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
} &amp; { newMember: boolean }

// **Do not** use the following!
// This is an error!
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
  newMember: boolean;
}
</code></pre>

<p>Let’s take a look at the simplest mapped type and its parts:</p>

<pre><code class="language-ts">type Keys = 'option1' | 'option2';
type Flags = { [K in Keys]: boolean };
</code></pre>

<p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside.
There are three parts:</p>

<ol>
  <li>The type variable <code>K</code>, which gets bound to each property in turn.</li>
  <li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.</li>
  <li>The resulting type of the property.</li>
</ol>

<p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:</p>

<pre><code class="language-ts">type Flags = {
    option1: boolean;
    option2: boolean;
}
</code></pre>

<p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above.
They’re based on some existing type, and they transform the properties in some way.
That’s where <code>keyof</code> and indexed access types come in:</p>

<pre><code class="language-ts">type NullablePerson = { [P in keyof Person]: Person[P] | null }
type PartialPerson = { [P in keyof Person]?: Person[P] }
</code></pre>

<p>But it’s more useful to have a general version.</p>

<pre><code class="language-ts">type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null }
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] }
</code></pre>

<p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>.
This is a good template for any general use of mapped types.
That’s because this kind of transformation is <a href="https://en.wikipedia.org/wiki/Homomorphism">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others.
The compiler knows that it can copy all the existing property modifiers before adding any new ones.
For example, if <code>Person.name</code> was readonly, <code>Partial&lt;Person&gt;.name</code> would be readonly and optional.</p>

<p>Here’s one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&lt;T&gt;</code> class:</p>

<pre><code class="language-ts">type Proxy&lt;T&gt; = {
    get(): T;
    set(value: T): void;
}
type Proxify&lt;T&gt; = {
    [P in keyof T]: Proxy&lt;T[P]&gt;;
}
function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; {
   // ... wrap proxies ...
}
let proxyProps = proxify(props);
</code></pre>

<p>Note that <code>Readonly&lt;T&gt;</code> and <code>Partial&lt;T&gt;</code> are so useful, they are included in TypeScript’s standard library along with <code>Pick</code> and <code>Record</code>:</p>

<pre><code class="language-ts">type Pick&lt;T, K extends keyof T&gt; = {
    [P in K]: T[P];
}
type Record&lt;K extends keyof any, T&gt; = {
    [P in K]: T;
}
</code></pre>

<p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not.
One clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p>

<pre><code class="language-ts">type ThreeStringProps = Record&lt;'prop1' | 'prop2' | 'prop3', string&gt;
</code></pre>

<p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p>
    
      <h2 id="inference-from-mapped-types">
        
        
          Inference from mapped types <a aria-label="Link to the header: Inference from mapped types" title="Link to the header: Inference from mapped types" href="#inference-from-mapped-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them.
Fortunately, that’s pretty easy:</p>

<pre><code class="language-ts">function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T {
    let result = {} as T;
    for (const k in t) {
        result[k] = t[k].get();
    }
    return result;
}

let originalProps = unproxify(proxyProps);
</code></pre>

<p>Note that this unwrapping inference only works on homomorphic mapped types.
If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.</p>
    
      <h1 id="conditional-types">
        
        
          Conditional Types <a aria-label="Link to the header: Conditional Types" title="Link to the header: Conditional Types" href="#conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h1>

<p>TypeScript 2.8 introduces <em>conditional types</em> which add the ability to express non-uniform type mappings.
A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p>

<pre><code class="language-ts">T extends U ? X : Y
</code></pre>

<p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p>

<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables.
When <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.</p>

<p>As an example of some types that are immediately resolved, we can take a look at the following example:</p>

<pre><code class="language-ts">declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;

// Type is 'string | number'
let x = f(Math.random() &lt; 0.5)

</code></pre>

<p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:</p>

<pre><code class="language-ts">type TypeName&lt;T&gt; =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName&lt;string&gt;;  // "string"
type T1 = TypeName&lt;"a"&gt;;  // "string"
type T2 = TypeName&lt;true&gt;;  // "boolean"
type T3 = TypeName&lt;() =&gt; void&gt;;  // "function"
type T4 = TypeName&lt;string[]&gt;;  // "object"
</code></pre>

<p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</p>

<pre><code class="language-ts">interface Foo {
    propA: boolean;
    propB: boolean;
}

declare function f&lt;T&gt;(x: T): T extends Foo ? string : number;

function foo&lt;U&gt;(x: U) {
    // Has type 'U extends Foo ? string : number'
    let a = f(x);

    // This assignment is allowed though!
    let b: string | number = a;
}
</code></pre>

<p>In the above, the variable <code>a</code> has a conditional type that hasn’t yet chosen a branch.
When another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</p>

<p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target.
So in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it’s known to be either <code>string</code> or <code>number</code>.</p>
    
      <h2 id="distributive-conditional-types">
        
        
          Distributive conditional types <a aria-label="Link to the header: Distributive conditional types" title="Link to the header: Distributive conditional types" href="#distributive-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>.
Distributive conditional types are automatically distributed over union types during instantiation.
For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p>
    
      <h3 id="example">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<pre><code class="language-ts">type T10 = TypeName&lt;string | (() =&gt; void)&gt;;  // "string" | "function"
type T12 = TypeName&lt;string | string[] | undefined&gt;;  // "string" | "object" | "undefined"
type T11 = TypeName&lt;string[] | number[]&gt;;  // "object"
</code></pre>

<p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type).
Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p>
    
      <h3 id="example-1">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-1" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<pre><code class="language-ts">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;

type T20 = Boxed&lt;string&gt;;  // BoxedValue&lt;string&gt;;
type T21 = Boxed&lt;number[]&gt;;  // BoxedArray&lt;number&gt;;
type T22 = Boxed&lt;string | number[]&gt;;  // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;
</code></pre>

<p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&lt;T&gt;</code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p>

<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p>

<pre><code class="language-ts">type Diff&lt;T, U&gt; = T extends U ? never : T;  // Remove types from T that are assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;  // Remove types from T that are not assignable to U

type T30 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T31 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"
type T32 = Diff&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T33 = Filter&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;  // Remove null and undefined from T

type T34 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T35 = NonNullable&lt;string | string[] | null | undefined&gt;;  // string | string[]

function f1&lt;T&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
}

function f2&lt;T extends string | undefined&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
    let s1: string = x;  // Error
    let s2: string = y;  // Ok
}
</code></pre>

<p>Conditional types are particularly useful when combined with mapped types:</p>

<pre><code class="language-ts">type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;

type NonFunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;

interface Part {
    id: number;
    name: string;
    subparts: Part[];
    updatePart(newName: string): void;
}

type T40 = FunctionPropertyNames&lt;Part&gt;;  // "updatePart"
type T41 = NonFunctionPropertyNames&lt;Part&gt;;  // "id" | "name" | "subparts"
type T42 = FunctionProperties&lt;Part&gt;;  // { updatePart(newName: string): void }
type T43 = NonFunctionProperties&lt;Part&gt;;  // { id: number, name: string, subparts: Part[] }
</code></pre>

<p>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively.
For example the following is an error.</p>
    
      <h3 id="example-2">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-2" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<pre><code class="language-ts">type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T;  // Error
</code></pre>
    
      <h2 id="type-inference-in-conditional-types">
        
        
          Type inference in conditional types <a aria-label="Link to the header: Type inference in conditional types" title="Link to the header: Type inference in conditional types" href="#type-inference-in-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred.
Such inferred type variables may be referenced in the true branch of the conditional type.
It is possible to have multiple <code>infer</code> locations for the same type variable.</p>

<p>For example, the following extracts the return type of a function type:</p>

<pre><code class="language-ts">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>

<p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p>

<pre><code class="language-ts">type Unpacked&lt;T&gt; =
    T extends (infer U)[] ? U :
    T extends (...args: any[]) =&gt; infer U ? U :
    T extends Promise&lt;infer U&gt; ? U :
    T;

type T0 = Unpacked&lt;string&gt;;  // string
type T1 = Unpacked&lt;string[]&gt;;  // string
type T2 = Unpacked&lt;() =&gt; string&gt;;  // string
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  // string
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;  // Promise&lt;string&gt;
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;  // string
</code></pre>

<p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p>

<pre><code class="language-ts">type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never;
type T10 = Foo&lt;{ a: string, b: string }&gt;;  // string
type T11 = Foo&lt;{ a: string, b: number }&gt;;  // string | number
</code></pre>

<p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p>

<pre><code class="language-ts">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never;
type T20 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: string) =&gt; void }&gt;;  // string
type T21 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;;  // string &amp; number
</code></pre>

<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case).
It is not possible to perform overload resolution based on a list of argument types.</p>

<pre><code class="language-ts">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;
type T30 = ReturnType&lt;typeof foo&gt;;  // string | number
</code></pre>

<p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p>

<pre><code class="language-ts">type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;  // Error, not supported
</code></pre>

<p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p>

<pre><code class="language-ts">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
    
      <h2 id="predefined-conditional-types">
        
        
          Predefined conditional types <a aria-label="Link to the header: Predefined conditional types" title="Link to the header: Predefined conditional types" href="#predefined-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.8 adds several predefined conditional types to <code>lib.d.ts</code>:</p>

<ul>
  <li><code>Exclude&lt;T, U&gt;</code> – Exclude from <code>T</code> those types that are assignable to <code>U</code>.</li>
  <li><code>Extract&lt;T, U&gt;</code> – Extract from <code>T</code> those types that are assignable to <code>U</code>.</li>
  <li><code>NonNullable&lt;T&gt;</code> – Exclude <code>null</code> and <code>undefined</code> from <code>T</code>.</li>
  <li><code>ReturnType&lt;T&gt;</code> – Obtain the return type of a function type.</li>
  <li><code>InstanceType&lt;T&gt;</code> – Obtain the instance type of a constructor function type.</li>
</ul>
    
      <h3 id="example-3">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-3" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<pre><code class="language-ts">type T00 = Exclude&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T01 = Extract&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"

type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type T04 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;  // (() =&gt; string) | string[]

function f1(s: string) {
    return { a: 1, b: s };
}

class C {
    x = 0;
    y = 0;
}

type T10 = ReturnType&lt;() =&gt; string&gt;;  // string
type T11 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T14 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T15 = ReturnType&lt;any&gt;;  // any
type T16 = ReturnType&lt;never&gt;;  // never
type T17 = ReturnType&lt;string&gt;;  // Error
type T18 = ReturnType&lt;Function&gt;;  // Error

type T20 = InstanceType&lt;typeof C&gt;;  // C
type T21 = InstanceType&lt;any&gt;;  // any
type T22 = InstanceType&lt;never&gt;;  // never
type T23 = InstanceType&lt;string&gt;;  // Error
type T24 = InstanceType&lt;Function&gt;;  // Error
</code></pre>

<blockquote>
  <p>Note: The <code>Exclude</code> type is a proper implementation of the <code>Diff</code> type suggested <a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458">here</a>. We’ve used the name <code>Exclude</code> to avoid breaking existing code that defines a <code>Diff</code>, plus we feel that name better conveys the semantics of the type.</p>
</blockquote>


          </article>
        </div>
        </div>
    </a>

<script type="text/javascript">

      $(function() {
        //$(".tocAccordion").accordion();
        setDocTOC();
        hljs.initHighlightingOnLoad();
      });

</script>

	</main>
	<footer role="contentinfo">
    <div class="container-fluid signature-container">
        <div class="container">
            <div class="row signature">
                <div class="col-sm-7 col-xs-12">
                    <p class="pull-left">Made with <span class="glyphicon glyphicon-heart"></span> in Redmond</p>
                    <div class="twitter-buttons pull-left">
                        <a class="twitter-follow-button" href="https://twitter.com/typescript/">Follow @typescript</a>
                    </div>
                </div>
                <div class="col-sm-5 col-xs-12">
                    <img class="ms-logo-footer pull-right" src="/assets/images/Microsoft-logo_rgb_c-gray.svg" alt="Microsoft logo"/>
                    <p class="copyright pull-right">&copy;2012-2020 Microsoft</p>
                    <p class="privacy pull-right"><a href="https://go.microsoft.com/fwlink/?LinkId=521839" data-mscc-ic="false">Privacy</a></p>
                </div>
            </div>
        </div>
    </div>
</footer>

</body>
<!-- JS -->
<script src="/assets/js/libraries.5f479ded.js"></script>
<!-- at the end of the BODY -->

<script type="text/javascript">
docsearch({
  apiKey: '3c2db2aef0c7ff26e8911267474a9b2c',
  indexName: 'typescriptlang',
  inputSelector: '.site-search',
  debug: true // Set debug to true if you want to inspect the dropdown
});
</script>

</html>
