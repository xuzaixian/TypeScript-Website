<!DOCTYPE html lang="en">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us" lang="en">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Overview &middot; TypeScript
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/vendor.91c84422.css">

  <link rel="stylesheet" href="/assets/css/style.min.ea760870.css">

  <!-- Icons --> <!-- TODO: Check that these all wok -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/icons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/icons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/icons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/icons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/icons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/icons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/icons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/icons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/icons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/assets/images/icons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/assets/images/icons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/assets/images/icons/manifest.json">
  <link rel="mask-icon" href="/assets/images/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/icons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/assets/images/icons/mstile-144x144.png">
  <meta name="msapplication-config" content="/assets/images/icons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">

  <!-- JS -->
  <script src="/assets/js/vendors.4960e48a.js"></script>

  <!-- JS -->
  <script src="/assets/js/all.min.0df14029.js"></script>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Application Insights in Azure -->
  <script type="text/javascript">
    var sdkInstance="appInsightsSDK";window[sdkInstance]="appInsights";var aiName=window[sdkInstance],aisdk=window[aiName]||function(e){function n(e){t[e]=function(){var n=arguments;t.queue.push(function(){t[e].apply(t,n)})}}var t={config:e};t.initialize=!0;var i=document,a=window;setTimeout(function(){var n=i.createElement("script");n.async = true;n.src=e.url||"https://az416426.vo.msecnd.net/scripts/b/ai.2.min.js",i.getElementsByTagName("script")[0].parentNode.appendChild(n)});try{t.cookie=i.cookie}catch(e){}t.queue=[],t.version=2;for(var r=["Event","PageView","Exception","Trace","DependencyData","Metric","PageViewPerformance"];r.length;)n("track"+r.pop());n("startTrackPage"),n("stopTrackPage");var s="Track"+r[0];if(n("start"+s),n("stop"+s),n("setAuthenticatedUserContext"),n("clearAuthenticatedUserContext"),n("flush"),!(!0===e.disableExceptionTracking||e.extensionConfig&&e.extensionConfig.ApplicationInsightsAnalytics&&!0===e.extensionConfig.ApplicationInsightsAnalytics.disableExceptionTracking)){n("_"+(r="onerror"));var o=a[r];a[r]=function(e,n,i,a,s){var c=o&&o(e,n,i,a,s);return!0!==c&&t["_"+r]({message:e,url:n,lineNumber:i,columnNumber:a,error:s}),c},e.autoExceptionInstrumented=!0}return t}({ instrumentationKey: "78a8fb52-a225-4c66-ac08-92fad1c1ade1" });window[aiName]=aisdk
    if (aisdk.queue && 0 === aisdk.queue.length) {
        const locationWithoutPlaygroundCode = document.location.href.split("#code")[0].split("#src")[0]
        const referrerWithoutPlaygroundCode = document.referrer && document.referrer.split("#code")[0].split("#src")[0]
        aisdk.trackPageView({ uri: locationWithoutPlaygroundCode, refUri: referrerWithoutPlaygroundCode });
    }
  </script>

  <!-- Search -->
  <link rel="stylesheet" href="/assets/stylesheets/docsearch.css" />

</head>

<body>
	<a href="#main-content" class="main-content-skip" tabindex="0">
    Skip to main content
</a>
    <header role="banner">
    <nav role="navigation" class="navbar navbar-default navbar-fixed-top">
         <div class="container-fluid">
            <!-- Contains the logo and a toggle button for smaller screen sizes. -->
            <div class="navbar-header">
              <!-- Toggles the visibility of the nav area on smaller screen sizes. -->
              <button type="button" class="navbar-toggle pull-left collapsed" data-toggle="collapse" data-target="#navbar-collapse-div">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <!-- Top-left logo. -->
              <a class="navbar-brand" href="/index.html" aria-label="TypeScript Home Page">
                <img class="navbar-logo" src="/assets/images/logo_nocircle.svg" alt="TypeScript logo"/>
              </a>
            </div>

            <!-- The navigation items. -->
            <div class="collapse navbar-collapse centered-navbar" id="navbar-collapse-div">
              <ul class="nav navbar-nav">
                <li class="active"><a href="/docs/index.html">Documentation </a></li>
                <li><a href="/index.html#download-links">Download</a></li>
                <li class=""><a href="/community/index.html">Connect</a></li>
                <li class=""><a href="/play/index.html">Playground</a></li>
              </ul>

              <form class="navbar-form navbar-right" role="search">
                <div class="form-group">
                  <input type="search" class="form-control site-search" placeholder="Search">
                </div>
              </form>
            </div>
        </div>
    </nav>
</header>

	<div class="container-fluid update-banner">
	<div class="container">
		TypeScript <a href="/docs/handbook/release-notes/typescript-3-7.html">3.7</a> is now available. <a href="/#download-links" aria-label="Download the latest version of TypeScript">Get</a> the latest version today!
	</div>
</div>

	<main id="main-content" class="content">
		<div id="doc-content" class="container-fluid fill docs-container">
        <a id='try-beta'>Try v2 Beta Page</a>
        <script>
          const tryBeta = document.getElementById("try-beta")
          const mobile = window.outerWidth < 800
          const isHome = document.location.pathname === "/docs/home.html"
          if (!mobile && !isHome) {
            tryBeta.style.display = "block";

            tryBeta.onclick = () => {
              document.location.pathname = "v2" + document.location.pathname
            }
          }
        </script>
        <div class="container">

        <div class="col-md-2 toc-container hidden-xs hidden-sm">
          <nav class="docs-nav visible-md visible-lg affix-top" id="docs-navbar">
  <ul class="nav" id="main-nav">
    
    <li class="panel"><a class="docs-home" href="/docs/home.html">Documentation</a></li>    					

    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-tutorials" data-toggle="collapse" data-parent="#main-nav">Tutorials</a>         
        <ul class="collapse" id="toc-tutorials" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/typescript-in-5-minutes.html>TypeScript in 5 minutes</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/asp-net-core.html>ASP.NET Core</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/gulp.html>Gulp</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/migrating-from-javascript.html>Migrating from JavaScript</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/react-&-webpack.html>React & Webpack</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-whats-new" data-toggle="collapse" data-parent="#main-nav">What's New</a>         
        <ul class="collapse" id="toc-whats-new" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/overview.html class="active">Overview</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-7.html>TypeScript 3.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-6.html>TypeScript 3.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-5.html>TypeScript 3.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-4.html>TypeScript 3.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-3.html>TypeScript 3.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-2.html>TypeScript 3.2</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-1.html>TypeScript 3.1</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-3-0.html>TypeScript 3.0</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-9.html>TypeScript 2.9</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-8.html>TypeScript 2.8</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-7.html>TypeScript 2.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-6.html>TypeScript 2.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-5.html>TypeScript 2.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-4.html>TypeScript 2.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-3.html>TypeScript 2.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-2.html>TypeScript 2.2</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-1.html>TypeScript 2.1</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-2-0.html>TypeScript 2.0</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-8.html>TypeScript 1.8</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-7.html>TypeScript 1.7</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-6.html>TypeScript 1.6</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-5.html>TypeScript 1.5</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-4.html>TypeScript 1.4</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-3.html>TypeScript 1.3</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/release-notes/typescript-1-1.html>TypeScript 1.1</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-handbook" data-toggle="collapse" data-parent="#main-nav">Handbook</a>         
        <ul class="collapse" id="toc-handbook" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/basic-types.html>Basic Types</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/variable-declarations.html>Variable Declarations</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/interfaces.html>Interfaces</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/classes.html>Classes</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/functions.html>Functions</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/generics.html>Generics</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/enums.html>Enums</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-inference.html>Type Inference</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-compatibility.html>Type Compatibility</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/advanced-types.html>Advanced Types</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/symbols.html>Symbols</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/iterators-and-generators.html>Iterators and Generators</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/modules.html>Modules</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/namespaces.html>Namespaces</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/namespaces-and-modules.html>Namespaces and Modules</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/module-resolution.html>Module Resolution</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-merging.html>Declaration Merging</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/jsx.html>JSX</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/decorators.html>Decorators</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/mixins.html>Mixins</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/triple-slash-directives.html>Triple-Slash Directives</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/type-checking-javascript-files.html>Type Checking JavaScript Files</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/utility-types.html>Utility Types</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-declaration-files" data-toggle="collapse" data-parent="#main-nav">Declaration Files</a>         
        <ul class="collapse" id="toc-declaration-files" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/introduction.html>Introduction</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/library-structures.html>Library Structures</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/by-example.html>By Example</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/do-s-and-don-ts.html>Do's and Don'ts</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/deep-dive.html>Deep Dive</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/templates.html>Templates</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/publishing.html>Publishing</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/declaration-files/consumption.html>Consumption</a>
                </li>
            
        </ul>
    </li>
    
    <li class="panel collapsed">
      <a class="area collapsed" aria-expanded="false" href="#toc-project-config" data-toggle="collapse" data-parent="#main-nav">Project Configuration</a>         
        <ul class="collapse" id="toc-project-config" aria-expanded="false">
            
                <li class="toc-item">
                  <a href=/docs/handbook/tsconfig-json.html>tsconfig.json</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/compiler-options.html>Compiler Options</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/project-references.html>Project References</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/compiler-options-in-msbuild.html>Compiler Options in MSBuild</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/integrating-with-build-tools.html>Integrating with Build Tools</a>
                </li>
            
                <li class="toc-item">
                  <a href=/docs/handbook/nightly-builds.html>Nightly Builds</a>
                </li>
            
        </ul>
    </li>
        
    
	</ul>
</nav>

        </div>
        <div class="col-md-10 col-xs-12 col-sm-12  doc-content-container">
          <div class="xs-toc-container visible-xs visible-sm">
            <nav class='xs-toc'>
  <div class="toc-dropdown">
    <a class="btn btn-primary btn-sm dropdown-toggle" data-toggle="dropdown" href="#">
      Documentation
      <span class="caret"></span>
    </a>
    <ul class="dropdown-menu">
      <li>
        <a href="/docs/home.html">Documentation</a>
      </li>
      
      <li>
          <ul>
      <h2>
        
        
          Tutorials
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/typescript-in-5-minutes.html>TypeScript in 5 minutes</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/asp-net-core.html>ASP.NET Core</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/gulp.html>Gulp</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/migrating-from-javascript.html>Migrating from JavaScript</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/react-&-webpack.html>React & Webpack</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          What's New
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/overview.html class="active">Overview</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-7.html>TypeScript 3.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-6.html>TypeScript 3.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-5.html>TypeScript 3.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-4.html>TypeScript 3.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-3.html>TypeScript 3.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-2.html>TypeScript 3.2</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-1.html>TypeScript 3.1</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-3-0.html>TypeScript 3.0</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-9.html>TypeScript 2.9</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-8.html>TypeScript 2.8</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-7.html>TypeScript 2.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-6.html>TypeScript 2.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-5.html>TypeScript 2.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-4.html>TypeScript 2.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-3.html>TypeScript 2.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-2.html>TypeScript 2.2</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-1.html>TypeScript 2.1</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-2-0.html>TypeScript 2.0</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-8.html>TypeScript 1.8</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-7.html>TypeScript 1.7</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-6.html>TypeScript 1.6</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-5.html>TypeScript 1.5</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-4.html>TypeScript 1.4</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-3.html>TypeScript 1.3</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/release-notes/typescript-1-1.html>TypeScript 1.1</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Handbook
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/basic-types.html>Basic Types</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/variable-declarations.html>Variable Declarations</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/interfaces.html>Interfaces</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/classes.html>Classes</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/functions.html>Functions</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/generics.html>Generics</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/enums.html>Enums</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-inference.html>Type Inference</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-compatibility.html>Type Compatibility</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/advanced-types.html>Advanced Types</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/symbols.html>Symbols</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/iterators-and-generators.html>Iterators and Generators</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/modules.html>Modules</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/namespaces.html>Namespaces</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/namespaces-and-modules.html>Namespaces and Modules</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/module-resolution.html>Module Resolution</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-merging.html>Declaration Merging</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/jsx.html>JSX</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/decorators.html>Decorators</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/mixins.html>Mixins</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/triple-slash-directives.html>Triple-Slash Directives</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/type-checking-javascript-files.html>Type Checking JavaScript Files</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/utility-types.html>Utility Types</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Declaration Files
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/introduction.html>Introduction</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/library-structures.html>Library Structures</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/by-example.html>By Example</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/do-s-and-don-ts.html>Do's and Don'ts</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/deep-dive.html>Deep Dive</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/templates.html>Templates</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/publishing.html>Publishing</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/declaration-files/consumption.html>Consumption</a>
                  </li>
              
          </ul>
      </li>
      
      <li>
          <ul>
    
      <h2>
        
        
          Project Configuration
        
        
      </h2>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/tsconfig-json.html>tsconfig.json</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/compiler-options.html>Compiler Options</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/project-references.html>Project References</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/compiler-options-in-msbuild.html>Compiler Options in MSBuild</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/integrating-with-build-tools.html>Integrating with Build Tools</a>
                  </li>
              
                  <li class="toc-item">
                    <a href=/docs/handbook/nightly-builds.html>Nightly Builds</a>
                  </li>
              
          </ul>
      </li>
      
    </ul>
  </div>    
</nav>

          </div>
    <header class="post-header">
      <h1 class="post-title">
        
        
          Overview
        
        
      </header>
          <article class="post-content">
              <p></p>
              <p>This page is all of the release notes combined into a single page. It’s long, but comprehensive.</p>
    
      <h2 id="typescript-37">
        
        
          TypeScript 3.7 <a aria-label="Link to the header: TypeScript 3.7" title="Link to the header: TypeScript 3.7" href="#typescript-37" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="optional-chaining">
        
        
          Optional Chaining <a aria-label="Link to the header: Optional Chaining" title="Link to the header: Optional Chaining" href="#optional-chaining" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><a href="/play/#example/optional-chaining">Playground</a></p>

<p>Optional chaining is <a href="https://github.com/microsoft/TypeScript/issues/16">issue #16</a> on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</p>

<p>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a <code>null</code> or <code>undefined</code>.
The star of the show in optional chaining is the new <code>?.</code> operator for <em>optional property accesses</em>.
When we write code like</p>

<pre><code class="language-ts">let x = foo?.bar.baz();
</code></pre>

<p>this is a way of saying that when <code>foo</code> is defined, <code>foo.bar.baz()</code> will be computed; but when <code>foo</code> is <code>null</code> or <code>undefined</code>, stop what we’re doing and just return <code>undefined</code>.”</p>

<p>More plainly, that code snippet is the same as writing the following.</p>

<pre><code class="language-ts">let x = (foo === null || foo === undefined) ?
    undefined :
    foo.bar.baz();
</code></pre>

<p>Note that if <code>bar</code> is <code>null</code> or <code>undefined</code>, our code will still hit an error accessing <code>baz</code>.
Likewise, if <code>baz</code> is <code>null</code> or <code>undefined</code>, we’ll hit an error at the call site.
<code>?.</code> only checks for whether the value on the <em>left</em> of it is <code>null</code> or <code>undefined</code> - not any of the subsequent properties.</p>

<p>You might find yourself using <code>?.</code> to replace a lot of code that performs repetitive nullish checks using the <code>&amp;&amp;</code> operator.</p>

<pre><code class="language-ts">// Before
if (foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz) {
    // ...
}

// After-ish
if (foo?.bar?.baz) {
    // ...
}
</code></pre>

<p>Keep in mind that <code>?.</code> acts differently than those <code>&amp;&amp;</code> operations since <code>&amp;&amp;</code> will act specially on “falsy” values (e.g. the empty string, <code>0</code>, <code>NaN</code>, and, well, <code>false</code>), but this is an intentional feature of the construct.
It doesn’t short-circuit on valid data like <code>0</code> or empty strings.</p>

<p>Optional chaining also includes two other operations.
First there’s the <em>optional element access</em> which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</p>

<pre><code class="language-ts">/**
 * Get the first element of the array if we have an array.
 * Otherwise return undefined.
 */
function tryGetFirstElement&lt;T&gt;(arr?: T[]) {
    return arr?.[0];
    // equivalent to
    //   return (arr === null || arr === undefined) ?
    //       undefined :
    //       arr[0];
}
</code></pre>

<p>There’s also <em>optional call</em>, which allows us to conditionally call expressions if they’re not <code>null</code> or <code>undefined</code>.</p>

<pre><code class="language-ts">async function makeRequest(url: string, log?: (msg: string) =&gt; void) {
    log?.(`Request started at ${new Date().toISOString()}`);
    // roughly equivalent to
    //   if (log != null) {
    //       log(`Request started at ${new Date().toISOString()}`);
    //   }

    const result = (await fetch(url)).json();

    log?.(`Request finished at at ${new Date().toISOString()}`);

    return result;
}
</code></pre>

<p>The “short-circuiting” behavior that optional chains have is limited property accesses, calls, element accesses - it doesn’t expand any further out from these expressions.
In other words,</p>

<pre><code class="language-ts">let result = foo?.bar / someComputation()
</code></pre>

<p>doesn’t stop the division or <code>someComputation()</code> call from occurring.
It’s equivalent to</p>

<pre><code class="language-ts">let temp = (foo === null || foo === undefined) ?
    undefined :
    foo.bar;

let result = temp / someComputation();
</code></pre>

<p>That might result in dividing <code>undefined</code>, which is why in <code>strictNullChecks</code>, the following is an error.</p>

<pre><code class="language-ts">function barPercentage(foo?: { bar: number }) {
    return foo?.bar / 100;
    //     ~~~~~~~~
    // Error: Object is possibly undefined.
}
</code></pre>

<p>More more details, you can <a href="https://github.com/tc39/proposal-optional-chaining/">read up on the proposal</a> and <a href="https://github.com/microsoft/TypeScript/pull/33294">view the original pull request</a>.</p>
    
      <h2 id="nullish-coalescing">
        
        
          Nullish Coalescing <a aria-label="Link to the header: Nullish Coalescing" title="Link to the header: Nullish Coalescing" href="#nullish-coalescing" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><a href="/play/#example/nullish-coalescing">Playground</a></p>

<p>The <em>nullish coalescing operator</em> is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</p>

<p>You can think of this feature - the <code>??</code> operator - as a way to “fall back” to a default value when dealing with <code>null</code> or <code>undefined</code>.
When we write code like</p>

<pre><code class="language-ts">let x = foo ?? bar();
</code></pre>

<p>this is a new way to say that the value <code>foo</code> will be used when it’s “present”;
but when it’s <code>null</code> or <code>undefined</code>, calculate <code>bar()</code> in its place.</p>

<p>Again, the above code is equivalent to the following.</p>

<pre><code class="language-ts">let x = (foo !== null &amp;&amp; foo !== undefined) ?
    foo :
    bar();
</code></pre>

<p>The <code>??</code> operator can replace uses of <code>||</code> when trying to use a default value.
For example, the following code snippet tries to fetch the volume that was last saved in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"><code>localStorage</code></a> (if it ever was);
however, it has a bug because it uses <code>||</code>.</p>

<pre><code class="language-ts">function initializeAudio() {
    let volume = localStorage.volume || 0.5

    // ...
}
</code></pre>

<p>When <code>localStorage.volume</code> is set to <code>0</code>, the page will set the volume to <code>0.5</code> which is unintended.
<code>??</code> avoids some unintended behavior from <code>0</code>, <code>NaN</code> and <code>""</code> being treated as falsy values.</p>

<p>We owe a large thanks to community members <a href="https://github.com/Kingwl">Wenlu Wang</a> and <a href="https://github.com/dragomirtitian">Titian Cernicova Dragomir</a> for implementing this feature!
For more details, <a href="https://github.com/microsoft/TypeScript/pull/32883">check out their pull request</a> and <a href="https://github.com/tc39/proposal-nullish-coalescing/">the nullish coalescing proposal repository</a>.</p>
    
      <h2 id="assertion-functions">
        
        
          Assertion Functions <a aria-label="Link to the header: Assertion Functions" title="Link to the header: Assertion Functions" href="#assertion-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><a href="/play/#example/assertion-functions">Playground</a></p>

<p>There’s a specific set of functions that <code>throw</code> an error if something unexpected happened.
They’re called “assertion” functions.
As an example, Node.js has a dedicated function for this called <code>assert</code>.</p>

<pre><code class="language-js">assert(someValue === 42);
</code></pre>

<p>In this example if <code>someValue</code> isn’t equal to <code>42</code>, then <code>assert</code> will throw an <code>AssertionError</code>.</p>

<p>Assertions in JavaScript are often used to guard against improper types being passed in.
For example,</p>

<pre><code class="language-js">function multiply(x, y) {
    assert(typeof x === "number");
    assert(typeof y === "number");

    return x * y;
}
</code></pre>

<p>Unfortunately in TypeScript these checks could never be properly encoded.
For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</p>

<pre><code class="language-ts">function yell(str) {
    assert(typeof str === "string");

    return str.toUppercase();
    // Oops! We misspelled 'toUpperCase'.
    // Would be great if TypeScript still caught this!
}
</code></pre>

<p>The alternative was to instead rewrite the code so that the language could analyze it, but this isn’t convenient.</p>

<pre><code class="language-ts">function yell(str) {
    if (typeof str !== "string") {
        throw new TypeError("str should have been a string.")
    }
    // Error caught!
    return str.toUppercase();
}
</code></pre>

<p>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way.
For that reason, TypeScript 3.7 introduces a new concept called “assertion signatures” which model these assertion functions.</p>

<p>The first type of assertion signature models the way that Node’s <code>assert</code> function works.
It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</p>

<pre><code class="language-ts">function assert(condition: any, msg?: string): asserts condition {
    if (!condition) {
        throw new AssertionError(msg)
    }
}
</code></pre>

<p><code>asserts condition</code> says that whatever gets passed into the <code>condition</code> parameter must be true if the <code>assert</code> returns (because otherwise it would throw an error).
That means that for the rest of the scope, that condition must be truthy.
As an example, using this assertion function means we <em>do</em> catch our original <code>yell</code> example.</p>

<pre><code class="language-ts">function yell(str) {
    assert(typeof str === "string");

    return str.toUppercase();
    //         ~~~~~~~~~~~
    // error: Property 'toUppercase' does not exist on type 'string'.
    //        Did you mean 'toUpperCase'?
}

function assert(condition: any, msg?: string): asserts condition {
    if (!condition) {
        throw new AssertionError(msg)
    }
}
</code></pre>

<p>The other type of assertion signature doesn’t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</p>

<pre><code class="language-ts">function assertIsString(val: any): asserts val is string {
    if (typeof val !== "string") {
        throw new AssertionError("Not a string!");
    }
}
</code></pre>

<p>Here <code>asserts val is string</code> ensures that after any call to <code>assertIsString</code>, any variable passed in will be known to be a <code>string</code>.</p>

<pre><code class="language-ts">function yell(str: any) {
    assertIsString(str);

    // Now TypeScript knows that 'str' is a 'string'.

    return str.toUppercase();
    //         ~~~~~~~~~~~
    // error: Property 'toUppercase' does not exist on type 'string'.
    //        Did you mean 'toUpperCase'?
}
</code></pre>

<p>These assertion signatures are very similar to writing type predicate signatures:</p>

<pre><code class="language-ts">function isString(val: any): val is string {
    return typeof val === "string";
}

function yell(str: any) {
    if (isString(str)) {
        return str.toUppercase();
    }
    throw "Oops!";
}
</code></pre>

<p>And just like type predicate signatures, these assertion signatures are incredibly expressive.
We can express some fairly sophisticated ideas with these.</p>

<pre><code class="language-ts">function assertIsDefined&lt;T&gt;(val: T): asserts val is NonNullable&lt;T&gt; {
    if (val === undefined || val === null) {
        throw new AssertionError(
            `Expected 'val' to be defined, but received ${val}`
        );
    }
}
</code></pre>

<p>To read up more about assertion signatures, <a href="https://github.com/microsoft/TypeScript/pull/32695">check out the original pull request</a>.</p>
    
      <h2 id="better-support-for-never-returning-functions">
        
        
          Better Support for <code>never</code>-Returning Functions <a aria-label="Link to the header: Better Support for never-Returning Functions" title="Link to the header: Better Support for never-Returning Functions" href="#better-support-for-never-returning-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called.
This gave us the opportunity to expand support for another class of functions: functions that return <code>never</code>.</p>

<p>The intent of any function that returns <code>never</code> is that it never returns.
It indicates that an exception was thrown, a halting error condition occurred, or that the program exited.
For example, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874"><code>process.exit(...)</code> in <code>@types/node</code></a> is specified to return <code>never</code>.</p>

<p>In order to ensure that a function never potentially returned <code>undefined</code> or effectively returned from all code paths, TypeScript needed some syntactic signal - either a <code>return</code> or <code>throw</code> at the end of a function.
So users found themselves <code>return</code>-ing their failure functions.</p>

<pre><code class="language-ts">function dispatch(x: string | number): SomeType {
    if (typeof x === "string") {
        return doThingWithString(x);
    }
    else if (typeof x === "number") {
        return doThingWithNumber(x);
    }
    return process.exit(1);
}
</code></pre>

<p>Now when these <code>never</code>-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</p>

<pre><code class="language-ts">function dispatch(x: string | number): SomeType {
    if (typeof x === "string") {
        return doThingWithString(x);
    }
    else if (typeof x === "number") {
        return doThingWithNumber(x);
    }
    process.exit(1);
}
</code></pre>

<p>As with assertion functions, you can <a href="https://github.com/microsoft/TypeScript/pull/32695">read up more at the same pull request</a>.</p>
    
      <h2 id="more-recursive-type-aliases">
        
        
          (More) Recursive Type Aliases <a aria-label="Link to the header: (More) Recursive Type Aliases" title="Link to the header: (More) Recursive Type Aliases" href="#more-recursive-type-aliases" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><a href="/play/#example/recursive-type-references">Playground</a></p>

<p>Type aliases have always had a limitation in how they could be “recursively” referenced.
The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases.
In some cases, that’s not possible, so the compiler rejects certain recursive aliases like the following:</p>

<pre><code class="language-ts">type Foo = Foo;
</code></pre>

<p>This is a reasonable restriction because any use of <code>Foo</code> would need to be replaced with <code>Foo</code> which would need to be replaced with <code>Foo</code> which would need to be replaced with <code>Foo</code> which… well, hopefully you get the idea!
In the end, there isn’t a type that makes sense in place of <code>Foo</code>.</p>

<p>This is fairly <a href="https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;oldid=913091335#in_type_synonyms">consistent with how other languages treat type aliases</a>, but it does give rise to some slightly surprising scenarios for how users leverage the feature.
For example, in TypeScript 3.6 and prior, the following causes an error.</p>

<pre><code class="language-ts">type ValueOrArray&lt;T&gt; = T | Array&lt;ValueOrArray&lt;T&gt;&gt;;
//   ~~~~~~~~~~~~
// error: Type alias 'ValueOrArray' circularly references itself.
</code></pre>

<p>This is strange because there is technically nothing wrong with any use  users could always write what was effectively the same code by introducing an interface.</p>

<pre><code class="language-ts">type ValueOrArray&lt;T&gt; = T | ArrayOfValueOrArray&lt;T&gt;;

interface ArrayOfValueOrArray&lt;T&gt; extends Array&lt;ValueOrArray&lt;T&gt;&gt; {}
</code></pre>

<p>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn’t need to be eagerly built out, TypeScript has no problem working with this structure.</p>

<p>But workaround of introducing the interface wasn’t intuitive for users.
And in principle there really wasn’t anything wrong with the original version of <code>ValueOrArray</code> that used <code>Array</code> directly.
If the compiler was a little bit “lazier” and only calculated the type arguments to <code>Array</code> when necessary, then TypeScript could express these correctly.</p>

<p>That’s exactly what TypeScript 3.7 introduces.
At the “top level” of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</p>

<p>This means that code like the following that was trying to represent JSON…</p>

<pre><code class="language-ts">type Json =
    | string
    | number
    | boolean
    | null
    | JsonObject
    | JsonArray;

interface JsonObject {
    [property: string]: Json;
}

interface JsonArray extends Array&lt;Json&gt; {}
</code></pre>

<p>can finally be rewritten without helper interfaces.</p>

<pre><code class="language-ts">type Json =
    | string
    | number
    | boolean
    | null
    | { [property: string]: Json }
    | Json[];
</code></pre>

<p>This new relaxation also lets us recursively reference type aliases in tuples as well.
The following code which used to error is now valid TypeScript code.</p>

<pre><code class="language-ts">type VirtualNode =
    | string
    | [string, { [key: string]: any }, ...VirtualNode[]];

const myNode: VirtualNode =
    ["div", { id: "parent" },
        ["div", { id: "first-child" }, "I'm the first child"],
        ["div", { id: "second-child" }, "I'm the second child"]
    ];
</code></pre>

<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/33050">read up on the original pull request</a>.</p>
    
      <h2 id="--declaration-and---allowjs">
        
        
          <code>--declaration</code> and <code>--allowJs</code> <a aria-label="Link to the header: --declaration and --allowJs" title="Link to the header: --declaration and --allowJs" href="#--declaration-and---allowjs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The <code>--declaration</code> flag in TypeScript allows us to generate <code>.d.ts</code> files (declaration files) from TypeScript source files (i.e. <code>.ts</code> and <code>.tsx</code> files).
These <code>.d.ts</code> files are important for a couple of reasons.</p>

<p>First of all, they’re important because they allow TypeScript to type-check against other projects without re-checking the original source code.
They’re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren’t built with TypeScript in mind.
Finally, a benefit that is often underappreciated: both TypeScript <em>and</em> JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</p>

<p>Unfortunately, <code>--declaration</code> didn’t work with the <code>--allowJs</code> flag which allows mixing TypeScript and JavaScript input files.
This was a frustrating limitation because it meant users couldn’t use the <code>--declaration</code> flag when migrating codebases, even if they were JSDoc-annotated.
TypeScript 3.7 changes that, and allows the two options to be used together!</p>

<p>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</p>

<p>The way that this works is that when using <code>allowJs</code>, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don’t necessarily look like their equivalents in TypeScript.
When <code>declaration</code> emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output <code>.d.ts</code> files.</p>

<p>As an example, the following code snippet</p>

<pre><code class="language-js">const assert = require("assert")

module.exports.blurImage = blurImage;

/**
 * Produces a blurred image from an input buffer.
 * 
 * @param input {Uint8Array}
 * @param width {number}
 * @param height {number}
 */
function blurImage(input, width, height) {
    const numPixels = width * height * 4;
    assert(input.length === numPixels);
    const result = new Uint8Array(numPixels);

    // TODO

    return result;
}
</code></pre>

<p>Will produce a <code>.d.ts</code> file like</p>

<pre><code class="language-ts">/**
 * Produces a blurred image from an input buffer.
 *
 * @param input {Uint8Array}
 * @param width {number}
 * @param height {number}
 */
export function blurImage(input: Uint8Array, width: number, height: number): Uint8Array;
</code></pre>

<p>This can go beyond basic functions with <code>@param</code> tags too, where the following example:</p>

<pre><code class="language-js">/**
 * @callback Job
 * @returns {void}
 */

/** Queues work */
export class Worker {
    constructor(maxDepth = 10) {
        this.started = false;
        this.depthLimit = maxDepth;
        /**
         * NOTE: queued jobs may add more items to queue
         * @type {Job[]}
         */
        this.queue = [];
    }
    /**
     * Adds a work item to the queue
     * @param {Job} work 
     */
    push(work) {
        if (this.queue.length + 1 &gt; this.depthLimit) throw new Error("Queue full!");
        this.queue.push(work);
    }
    /**
     * Starts the queue if it has not yet started
     */
    start() {
        if (this.started) return false;
        this.started = true;
        while (this.queue.length) {
            /** @type {Job} */(this.queue.shift())();
        }
        return true;
    }
}
</code></pre>

<p>will be transformed into the following <code>.d.ts</code> file:</p>

<pre><code class="language-ts">/**
 * @callback Job
 * @returns {void}
 */
/** Queues work */
export class Worker {
    constructor(maxDepth?: number);
    started: boolean;
    depthLimit: number;
    /**
     * NOTE: queued jobs may add more items to queue
     * @type {Job[]}
     */
    queue: Job[];
    /**
     * Adds a work item to the queue
     * @param {Job} work
     */
    push(work: Job): void;
    /**
     * Starts the queue if it has not yet started
     */
    start(): boolean;
}
export type Job = () =&gt; void;
</code></pre>

<p>Note that when using these flags together, TypeScript doesn’t necessarily have to downlevel <code>.js</code> files.
If you simply want TypeScript to create <code>.d.ts</code> files, you can use the <code>--emitDeclarationOnly</code> compiler option.</p>

<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/32372">check out the original pull request</a>.</p>
    
      <h2 id="the-usedefineforclassfields-flag-and-the-declare-property-modifier">
        
        
          The <code>useDefineForClassFields</code> Flag and The <code>declare</code> Property Modifier <a aria-label="Link to the header: The useDefineForClassFields Flag and The declare Property Modifier" title="Link to the header: The useDefineForClassFields Flag and The declare Property Modifier" href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</p>

<pre><code class="language-ts">class C {
    foo = 100;
    bar: string;
}
</code></pre>

<p>would be equivalent to a similar assignment within a constructor body.</p>

<pre><code class="language-ts">class C {
    constructor() {
        this.foo = 100;
    }
}
</code></pre>

<p>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently.
Instead, the original code sample might need to de-sugar to something closer to the following:</p>

<pre><code class="language-ts">class C {
    constructor() {
        Object.defineProperty(this, "foo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 100
        });
        Object.defineProperty(this, "bar", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
</code></pre>

<p>While TypeScript 3.7 isn’t changing any existing emit by default, we’ve been rolling out changes incrementally to help users mitigate potential future breakage.
We’ve provided a new flag called <code>useDefineForClassFields</code> to enable this emit mode with some new checking logic.</p>

<p>The two biggest changes are the following:</p>

<ul>
  <li>Declarations are initialized with <code>Object.defineProperty</code>.</li>
  <li>Declarations are <em>always</em> initialized to <code>undefined</code>, even if they have no initializer.</li>
</ul>

<p>This can cause quite a bit of fallout for existing code that use inheritance. First of all, <code>set</code> accessors from base classes won’t get triggered - they’ll be completely overwritten.</p>

<pre><code class="language-ts">class Base {
    set data(value: string) {
        console.log("data changed to " + value);
    }
}

class Derived extends Base {
    // No longer triggers a 'console.log' 
    // when using 'useDefineForClassFields'.
    data = 10;
}
</code></pre>

<p>Secondly, using class fields to specialize properties from base classes also won’t work.</p>

<pre><code class="language-ts">interface Animal { animalStuff: any }
interface Dog extends Animal { dogStuff: any }

class AnimalHouse {
    resident: Animal;
    constructor(animal: Animal) {
        this.resident = animal;
    }
}

class DogHouse extends AnimalHouse {
    // Initializes 'resident' to 'undefined'
    // after the call to 'super()' when
    // using 'useDefineForClassFields'!
    resident: Dog;

    constructor(dog: Dog) {
        super(dog);
    }
}
</code></pre>

<p>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</p>

<p>To detect the issue around accessors, TypeScript 3.7 will now emit <code>get</code>/<code>set</code> accessors in <code>.d.ts</code> files so that in TypeScript can check for overridden accessors.</p>

<p>Code that’s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</p>

<pre><code class="language-ts">class Base {
    set data(value: string) {
        console.log("data changed to " + value);
    }
}

class Derived extends Base {
    constructor() {
        data = 10;
    }
}
</code></pre>

<p>To help mitigate the second issue, you can either add an explicit initializer or add a <code>declare</code> modifier to indicate that a property should have no emit.</p>

<pre><code class="language-ts">interface Animal { animalStuff: any }
interface Dog extends Animal { dogStuff: any }

class AnimalHouse {
    resident: Animal;
    constructor(animal: Animal) {
        this.resident = animal;
    }
}

class DogHouse extends AnimalHouse {
    declare resident: Dog;
//  ^^^^^^^
// 'resident' now has a 'declare' modifier,
// and won't produce any output code.

    constructor(dog: Dog) {
        super(dog);
    }
}
</code></pre>

<p>Currently <code>useDefineForClassFields</code> is only available when targeting ES5 and upwards, since <code>Object.defineProperty</code> doesn’t exist in ES3.
To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses <code>--noEmit</code> to avoid a full build.</p>

<p>For more information, you can <a href="https://github.com/microsoft/TypeScript/pull/33509">take a look at the original pull request for these changes</a>.</p>

<p>We strongly encourage users to try the <code>useDefineForClassFields</code> flag and report back on our issue tracker or in the comments below.
This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</p>
    
      <h2 id="build-free-editing-with-project-references">
        
        
          Build-Free Editing with Project References <a aria-label="Link to the header: Build-Free Editing with Project References" title="Link to the header: Build-Free Editing with Project References" href="#build-free-editing-with-project-references" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript’s project references provide us with an easy way to break codebases up to give us faster compiles.
Unfortunately, editing a project whose dependencies hadn’t been built (or whose output was out of date) meant that the editing experience wouldn’t work well.</p>

<p>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source <code>.ts</code>/<code>.tsx</code> files instead.
This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and “just work”.
You can disable this behavior with the compiler option <code>disableSourceOfProjectReferenceRedirect</code> which may be appropriate when working in very large projects where this change may impact editing performance.</p>

<p>You can <a href="https://github.com/microsoft/TypeScript/pull/32028">read up more about this change by reading up on its pull request</a>.</p>
    
      <h2 id="uncalled-function-checks">
        
        
          Uncalled Function Checks <a aria-label="Link to the header: Uncalled Function Checks" title="Link to the header: Uncalled Function Checks" href="#uncalled-function-checks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><a href="/play/#example/uncalled-function-checks">Playground</a></p>

<p>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</p>

<pre><code class="language-ts">interface User {
    isAdministrator(): boolean;
    notify(): void;
    doNotDisturb?(): boolean;
}

// later...

// Broken code, do not use!
function doAdminThing(user: User) {
    // oops!
    if (user.isAdministrator) {
        sudo();
        editTheConfiguration();
    }
    else {
        throw new AccessDeniedError("User is not an admin");
    }
}
</code></pre>

<p>Here, we forgot to call <code>isAdministrator</code>, and the code incorrectly allows non-adminstrator users to edit the configuration!</p>

<p>In TypeScript 3.7, this is identified as a likely error:</p>

<pre><code class="language-ts">function doAdminThing(user: User) {
    if (user.isAdministrator) {
    //  ~~~~~~~~~~~~~~~~~~~~
    // error! This condition will always return true since the function is always defined.
    //        Did you mean to call it instead?
</code></pre>

<p>This check is a breaking change, but for that reason the checks are very conservative.
This error is only issued in <code>if</code> conditions, and it is not issued on optional properties, if <code>strictNullChecks</code> is off, or if the function is later called within the body of the <code>if</code>:</p>

<pre><code class="language-ts">interface User {
    isAdministrator(): boolean;
    notify(): void;
    doNotDisturb?(): boolean;
}

function issueNotification(user: User) {
    if (user.doNotDisturb) {
        // OK, property is optional
    }
    if (user.notify) {
        // OK, called the function
        user.notify();
    }
}
</code></pre>

<p>If you intended to test the function without calling it, you can correct the definition of it to include <code>undefined</code>/<code>null</code>, or use <code>!!</code> to write something like <code>if (!!user.isAdministrator)</code> to indicate that the coercion is intentional.</p>

<p>We owe a big thanks to GitHub user <a href="https://github.com/jwbay">@jwbay</a> who took the initiative to create a <a href="https://github.com/microsoft/TypeScript/pull/32802">proof-of-concept</a> and iterated to provide us with with <a href="https://github.com/microsoft/TypeScript/pull/33178">the current version</a>.</p>
    
      <h2 id="-ts-nocheck-in-typescript-files">
        
        
          <code>// @ts-nocheck</code> in TypeScript Files <a aria-label="Link to the header: // @ts-nocheck in TypeScript Files" title="Link to the header: // @ts-nocheck in TypeScript Files" href="#-ts-nocheck-in-typescript-files" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.7 allows us to add <code>// @ts-nocheck</code> comments to the top of TypeScript files to disable semantic checks.
Historically this comment was only respected in JavaScript source files in the presence of <code>checkJs</code>, but we’ve expanded support to TypeScript files to make migrations easier for all users.</p>
    
      <h2 id="semicolon-formatter-option">
        
        
          Semicolon Formatter Option <a aria-label="Link to the header: Semicolon Formatter Option" title="Link to the header: Semicolon Formatter Option" href="#semicolon-formatter-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript’s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript’s automatic semicolon insertion (ASI) rules. The setting is available now in <a href="https://code.visualstudio.com/insiders/">Visual Studio Code Insiders</a>, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</p>

<p><img width="833" alt="New semicolon formatter option in VS Code" src="https://user-images.githubusercontent.com/3277153/65913194-10066e80-e395-11e9-8a3a-4f7305c397d5.png" /></p>

<p>Choosing a value of “insert” or “remove” also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of “ignore” makes generated code match the semicolon preference detected in the current file.</p>
    
      <h2 id="37-breaking-changes">
        
        
          3.7 Breaking Changes <a aria-label="Link to the header: 3.7 Breaking Changes" title="Link to the header: 3.7 Breaking Changes" href="#37-breaking-changes" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h3 id="dom-changes">
        
        
          DOM Changes <a aria-label="Link to the header: DOM Changes" title="Link to the header: DOM Changes" href="#dom-changes" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p><a href="https://github.com/microsoft/TypeScript/pull/33627">Types in <code>lib.dom.d.ts</code> have been updated</a>.
These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</p>
    
      <h3 id="class-field-mitigations">
        
        
          Class Field Mitigations <a aria-label="Link to the header: Class Field Mitigations" title="Link to the header: Class Field Mitigations" href="#class-field-mitigations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p><a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier">As mentioned above</a>, TypeScript 3.7 emits <code>get</code>/<code>set</code> accessors in <code>.d.ts</code> files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior.
TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</p>

<p>While not a breakage per se, opting in to the <code>useDefineForClassFields</code> flag can cause breakage when:</p>

<ul>
  <li>overriding an accessor in a derived class with a property declaration</li>
  <li>re-declaring a property declaration with no initializer</li>
</ul>

<p>To understand the full impact, read <a href="#the-usedefineforclassfields-flag-and-the-declare-property-modifier">the section above on the <code>useDefineForClassFields</code> flag</a>.</p>
    
      <h3 id="function-truthy-checks">
        
        
          Function Truthy Checks <a aria-label="Link to the header: Function Truthy Checks" title="Link to the header: Function Truthy Checks" href="#function-truthy-checks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>As mentioned above, TypeScript now errors when functions appear to be uncalled within <code>if</code> statement conditions.
An error is issued when a function type is checked in <code>if</code> conditions unless any of the following apply:</p>

<ul>
  <li>the checked value comes from an optional property</li>
  <li><code>strictNullChecks</code> is disabled</li>
  <li>the function is later called within the body of the <code>if</code></li>
</ul>
    
      <h3 id="local-and-imported-type-declarations-now-conflict">
        
        
          Local and Imported Type Declarations Now Conflict <a aria-label="Link to the header: Local and Imported Type Declarations Now Conflict" title="Link to the header: Local and Imported Type Declarations Now Conflict" href="#local-and-imported-type-declarations-now-conflict" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Due to a bug, the following construct was previously allowed in TypeScript:</p>

<pre><code class="language-ts">// ./someOtherModule.ts
interface SomeType {
    y: string;
}

// ./myModule.ts
import { SomeType } from "./someOtherModule";
export interface SomeType {
    x: number;
}

function fn(arg: SomeType) {
    console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'
}
</code></pre>

<p>Here, <code>SomeType</code> appears to originate in both the <code>import</code> declaration and the local <code>interface</code> declaration.
Perhaps surprisingly, inside the module, <code>SomeType</code> refers exclusively to the <code>import</code>ed definition, and the local declaration <code>SomeType</code> is only usable when imported from another file.
This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</p>

<p>In TypeScript 3.7, <a href="https://github.com/microsoft/TypeScript/pull/31231">this is now correctly identified as a duplicate identifier error</a>.
The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis.
Usually, the naming conflict is unintentional and the best fix is to rename the imported type.
If the intent was to augment the imported type, a proper module augmentation should be written instead.</p>
    
      <h3 id="37-api-changes">
        
        
          3.7 API Changes <a aria-label="Link to the header: 3.7 API Changes" title="Link to the header: 3.7 API Changes" href="#37-api-changes" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>To enable the recursive type alias patterns described above, the <code>typeArguments</code> property has been removed from the <code>TypeReference</code> interface. Users should instead use the <code>getTypeArguments</code> function on <code>TypeChecker</code> instances.</p>
    
      <h2 id="typescript-36">
        
        
          TypeScript 3.6 <a aria-label="Link to the header: TypeScript 3.6" title="Link to the header: TypeScript 3.6" href="#typescript-36" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="stricter-generators">
        
        
          Stricter Generators <a aria-label="Link to the header: Stricter Generators" title="Link to the header: Stricter Generators" href="#stricter-generators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.6 introduces stricter checking for iterators and generator functions.
In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</p>

<pre><code class="language-ts">function* foo() {
    if (Math.random() &lt; 0.5) yield 100;
    return "Finished!"
}

let iter = foo();
let curr = iter.next();
if (curr.done) {
    // TypeScript 3.5 and prior thought this was a 'string | number'.
    // It should know it's 'string' since 'done' was 'true'!
    curr.value
}
</code></pre>

<p>Additionally, generators just assumed the type of <code>yield</code> was always <code>any</code>.</p>

<pre><code class="language-ts">function* bar() {
    let x: { hello(): void } = yield;
    x.hello();
}

let iter = bar();
iter.next();
iter.next(123); // oops! runtime error!
</code></pre>

<p>In TypeScript 3.6, the checker now knows that the correct type for <code>curr.value</code> should be <code>string</code> in our first example, and will correctly error on our call to <code>next()</code> in our last example.
This is thanks to some changes in the <code>Iterator</code> and <code>IteratorResult</code> type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the <code>Generator</code> type.</p>

<p>The <code>Iterator</code> type now allows users to specify the yielded type, the returned type, and the type that <code>next</code> can accept.</p>

<pre><code class="language-ts">interface Iterator&lt;T, TReturn = any, TNext = undefined&gt; {
    // Takes either 0 or 1 arguments - doesn't accept 'undefined'
    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;
    return?(value?: TReturn): IteratorResult&lt;T, TReturn&gt;;
    throw?(e?: any): IteratorResult&lt;T, TReturn&gt;;
}
</code></pre>

<p>Building on that work, the new <code>Generator</code> type is an <code>Iterator</code> that always has both the <code>return</code> and <code>throw</code> methods present, and is also iterable.</p>

<pre><code class="language-ts">interface Generator&lt;T = unknown, TReturn = any, TNext = unknown&gt;
        extends Iterator&lt;T, TReturn, TNext&gt; {
    next(...args: [] | [TNext]): IteratorResult&lt;T, TReturn&gt;;
    return(value: TReturn): IteratorResult&lt;T, TReturn&gt;;
    throw(e: any): IteratorResult&lt;T, TReturn&gt;;
    [Symbol.iterator](): Generator&lt;T, TReturn, TNext&gt;;
}
</code></pre>

<p>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the <code>IteratorResult</code> type to a discriminated union type:</p>

<pre><code class="language-ts">type IteratorResult&lt;T, TReturn = any&gt; = IteratorYieldResult&lt;T&gt; | IteratorReturnResult&lt;TReturn&gt;;

interface IteratorYieldResult&lt;TYield&gt; {
    done?: false;
    value: TYield;
}

interface IteratorReturnResult&lt;TReturn&gt; {
    done: true;
    value: TReturn;
}
</code></pre>

<p>In short, what this means is that you’ll be able to appropriately narrow down values from iterators when dealing with them directly.</p>

<p>To correctly represent the types that can be passed in to a generator from calls to <code>next()</code>, TypeScript 3.6 also infers certain uses of <code>yield</code> within the body of a generator function.</p>

<pre><code class="language-ts">function* foo() {
    let x: string = yield;
    console.log(x.toUpperCase());
}

let x = foo();
x.next(); // first call to 'next' is always ignored
x.next(42); // error! 'number' is not assignable to 'string'
</code></pre>

<p>If you’d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from <code>yield</code> expressions using an explicit return type.
Below, <code>next()</code> can only be called with <code>boolean</code>s, and depending on the value of <code>done</code>, <code>value</code> is either a <code>string</code> or a <code>number</code>.</p>

<pre><code class="language-ts">/**
 * - yields numbers
 * - returns strings
 * - can be passed in booleans
 */
function* counter(): Generator&lt;number, string, boolean&gt; {
    let i = 0;
    while (true) {
        if (yield i++) {
            break;
        }
    }
    return "done!";
}

var iter = counter();
var curr = iter.next()
while (!curr.done) {
    console.log(curr.value);
    curr = iter.next(curr.value === 5)
}
console.log(curr.value.toUpperCase());

// prints:
//
// 0
// 1
// 2
// 3
// 4
// 5
// DONE!
</code></pre>

<p>For more details on the change, <a href="https://github.com/Microsoft/TypeScript/issues/2983">see the pull request here</a>.</p>
    
      <h2 id="more-accurate-array-spread">
        
        
          More Accurate Array Spread <a aria-label="Link to the header: More Accurate Array Spread" title="Link to the header: More Accurate Array Spread" href="#more-accurate-array-spread" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In pre-ES2015 targets, the most faithful emit for constructs like <code>for</code>/<code>of</code> loops and array spreads can be a bit heavy.
For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the <code>--downlevelIteration</code> flag.
The looser default without <code>--downlevelIteration</code> works fairly well; however, there were some common cases where the transformation of array spreads had observable differences.
For example, the following array containing a spread</p>

<pre><code class="language-ts">[...Array(5)]
</code></pre>

<p>can be rewritten as the following array literal</p>

<pre><code class="language-js">[undefined, undefined, undefined, undefined, undefined]
</code></pre>

<p>However, TypeScript would instead transform the original code into this code:</p>

<pre><code class="language-ts">Array(5).slice();
</code></pre>

<p>which is slightly different.
<code>Array(5)</code> produces an array with a length of 5, but with no defined property slots.</p>

<p>TypeScript 3.6 introduces a new <code>__spreadArrays</code> helper to accurately model what happens in ECMAScript 2015 in older targets outside of <code>--downlevelIteration</code>.
<code>__spreadArrays</code> is also available in <a href="https://github.com/Microsoft/tslib/">tslib</a>.</p>

<p>For more information, <a href="https://github.com/microsoft/TypeScript/pull/31166">see the relevant pull request</a>.</p>
    
      <h2 id="improved-ux-around-promises">
        
        
          Improved UX Around Promises <a aria-label="Link to the header: Improved UX Around Promises" title="Link to the header: Improved UX Around Promises" href="#improved-ux-around-promises" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.6 introduces some improvements for when <code>Promise</code>s are mis-handled.</p>

<p>For example, it’s often very common to forget to <code>.then()</code> or <code>await</code> the contents of a <code>Promise</code> before passing it to another function.
TypeScript’s error messages are now specialized, and inform the user that perhaps they should consider using the <code>await</code> keyword.</p>

<pre><code class="language-ts">interface User {
    name: string;
    age: number;
    location: string;
}

declare function getUserData(): Promise&lt;User&gt;;
declare function displayUser(user: User): void;

async function f() {
    displayUser(getUserData());
//              ~~~~~~~~~~~~~
// Argument of type 'Promise&lt;User&gt;' is not assignable to parameter of type 'User'.
//   ...
// Did you forget to use 'await'?
}
</code></pre>

<p>It’s also common to try to access a method before <code>await</code>-ing or <code>.then()</code>-ing a <code>Promise</code>.
This is another example, among many others, where we’re able to do better.</p>

<pre><code class="language-ts">async function getCuteAnimals() {
    fetch("https://reddit.com/r/aww.json")
        .json()
    //   ~~~~
    // Property 'json' does not exist on type 'Promise&lt;Response&gt;'.
    //
    // Did you forget to use 'await'?
}
</code></pre>

<p>For more details, <a href="https://github.com/microsoft/TypeScript/issues/30646">see the originating issue</a>, as well as the pull requests that link back to it.</p>
    
      <h2 id="better-unicode-support-for-identifiers">
        
        
          Better Unicode Support for Identifiers <a aria-label="Link to the header: Better Unicode Support for Identifiers" title="Link to the header: Better Unicode Support for Identifiers" href="#better-unicode-support-for-identifiers" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</p>

<pre><code class="language-ts">const 𝓱𝓮𝓵𝓵𝓸 = "world"; // previously disallowed, now allowed in '--target es2015'
</code></pre>
    
      <h2 id="importmeta-support-in-systemjs">
        
        
          <code>import.meta</code> Support in SystemJS <a aria-label="Link to the header: import.meta Support in SystemJS" title="Link to the header: import.meta Support in SystemJS" href="#importmeta-support-in-systemjs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.6 supports transforming <code>import.meta</code> to <code>context.meta</code> when your <code>module</code> target is set to <code>system</code>.</p>

<pre><code class="language-ts">// This module:

console.log(import.meta.url)

// gets turned into the following:

System.register([], function (exports, context) {
  return {
    setters: [],
    execute: function () {
      console.log(context.meta.url);
    }
  };
});
</code></pre>
    
      <h2 id="get-and-set-accessors-are-allowed-in-ambient-contexts">
        
        
          <code>get</code> and <code>set</code> Accessors Are Allowed in Ambient Contexts <a aria-label="Link to the header: get and set Accessors Are Allowed in Ambient Contexts" title="Link to the header: get and set Accessors Are Allowed in Ambient Contexts" href="#get-and-set-accessors-are-allowed-in-ambient-contexts" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In previous versions of TypeScript, the language didn’t allow <code>get</code> and <code>set</code> accessors in ambient contexts (like in <code>declare</code>-d classes, or in <code>.d.ts</code> files in general).
The rationale was that accessors weren’t distinct from properties as far as writing and reading to these properties;
however, <a href="https://github.com/tc39/proposal-class-fields/issues/248">because ECMAScript’s class fields proposal may have differing behavior from in existing versions of TypeScript</a>, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</p>

<p>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</p>

<pre><code class="language-ts">declare class Foo {
    // Allowed in 3.6+.
    get x(): number;
    set x(val: number): void;
}
</code></pre>

<p>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated <code>.d.ts</code> files will also emit <code>get</code>/<code>set</code> accessors.</p>
    
      <h2 id="ambient-classes-and-functions-can-merge">
        
        
          Ambient Classes and Functions Can Merge <a aria-label="Link to the header: Ambient Classes and Functions Can Merge" title="Link to the header: Ambient Classes and Functions Can Merge" href="#ambient-classes-and-functions-can-merge" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances.
Now, ambient classes and functions (classes/functions with the <code>declare</code> modifier, or in <code>.d.ts</code> files) can merge.
This means that now you can write the following:</p>

<pre><code class="language-ts">export declare function Point2D(x: number, y: number): Point2D;
export declare class Point2D {
    x: number;
    y: number;
    constructor(x: number, y: number);
}
</code></pre>

<p>instead of needing to use</p>

<pre><code class="language-ts">export interface Point2D {
    x: number;
    y: number;
}
export declare var Point2D: {
    (x: number, y: number): Point2D;
    new (x: number, y: number): Point2D;
}
</code></pre>

<p>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since <code>var</code> declarations can’t merge with <code>namespace</code>s).</p>

<p>In TypeScript 3.7, the compiler will take advantage of this feature so that <code>.d.ts</code> files generated from <code>.js</code> files can appropriately capture both the callability and constructability of a class-like function.</p>

<p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/32584">see the original PR on GitHub</a>.</p>
    
      <h2 id="apis-to-support---build-and---incremental">
        
        
          APIs to Support <code>--build</code> and <code>--incremental</code> <a aria-label="Link to the header: APIs to Support --build and --incremental" title="Link to the header: APIs to Support --build and --incremental" href="#apis-to-support---build-and---incremental" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.0 introduced support for referencing other and building them incrementally using the <code>--build</code> flag.
Additionally, TypeScript 3.4 introduced the <code>--incremental</code> flag for saving information about previous compilations to only rebuild certain files.
These flags were incredibly useful for structuring projects more flexibly and speeding builds up.
Unfortunately, using these flags didn’t work with 3rd party build tools like Gulp and Webpack.
TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</p>

<p>For creating <code>--incremental</code> builds, users can leverage the <code>createIncrementalProgram</code> and <code>createIncrementalCompilerHost</code> APIs.
Users can also re-hydrate old program instances from <code>.tsbuildinfo</code> files generated by this API using the newly exposed <code>readBuilderProgram</code> function, which is only meant to be used as for creating new programs (i.e. you can’t modify the returned instance - it’s only meant to be used for the <code>oldProgram</code> parameter in other <code>create*Program</code> functions).</p>

<p>For leveraging project references, a new <code>createSolutionBuilder</code> function has been exposed, which returns an instance of the new type <code>SolutionBuilder</code>.</p>

<p>For more details on these APIs, you can <a href="https://github.com/microsoft/TypeScript/pull/31432">see the original pull request</a>.</p>
    
      <h2 id="semicolon-aware-code-edits">
        
        
          Semicolon-Aware Code Edits <a aria-label="Link to the header: Semicolon-Aware Code Edits" title="Link to the header: Semicolon-Aware Code Edits" href="#semicolon-aware-code-edits" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules.
These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users’ style guidelines, and many users were displeased with the editor inserting semicolons.</p>

<p>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits.
If your file generally lacks semicolons, TypeScript won’t add one.</p>

<p>For more details, <a href="https://github.com/microsoft/TypeScript/pull/31801">see the corresponding pull request</a>.</p>
    
      <h2 id="smarter-auto-import-syntax">
        
        
          Smarter Auto-Import Syntax <a aria-label="Link to the header: Smarter Auto-Import Syntax" title="Link to the header: Smarter Auto-Import Syntax" href="#smarter-auto-import-syntax" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more!
For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and <code>require</code> calls.</p>

<p>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules.
You can <a href="https://github.com/microsoft/TypeScript/pull/32684">see more details in the original pull request here</a>.</p>
    
      <h2 id="await-completions-on-promises">
        
        
          <code>await</code> Completions on Promises <a aria-label="Link to the header: await Completions on Promises" title="Link to the header: await Completions on Promises" href="#await-completions-on-promises" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="new-typescript-playground">
        
        
          New TypeScript Playground <a aria-label="Link to the header: New TypeScript Playground" title="Link to the header: New TypeScript Playground" href="#new-typescript-playground" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The TypeScript playground has received a much-needed refresh with handy new functionality!
The new playground is largely a fork of <a href="https://github.com/agentcooper">Artem Tyurin</a>’s <a href="https://github.com/agentcooper/typescript-play">TypeScript playground</a> which community members have been using more and more.
We owe Artem a big thanks for helping out here!</p>

<p>The new playground now supports many new options including:</p>

<ul>
  <li>The <code>target</code> option (allowing users to switch out of <code>es5</code> to <code>es3</code>, <code>es2015</code>, <code>esnext</code>, etc.)</li>
  <li>All the strictness flags (including just <code>strict</code>)</li>
  <li>Support for plain JavaScript files (using <code>allowJS</code> and optionally <code>checkJs</code>)</li>
</ul>

<p>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient “oh, don’t forget to turn on the <code>noImplicitAny</code> option!”.</p>

<p>In the near future, we’re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you’ll be able to see the same experience on the playground as you’d get in your personal editor.</p>

<p>As we improve the playground and the website, <a href="https://github.com/microsoft/TypeScript-Website/">we welcome feedback and pull requests on GitHub</a>!</p>
    
      <h2 id="typescript-35">
        
        
          TypeScript 3.5 <a aria-label="Link to the header: TypeScript 3.5" title="Link to the header: TypeScript 3.5" href="#typescript-35" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="speed-improvements">
        
        
          Speed improvements <a aria-label="Link to the header: Speed improvements" title="Link to the header: Speed improvements" href="#speed-improvements" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</p>
    
      <h3 id="type-checking-speed-ups">
        
        
          Type-checking speed-ups <a aria-label="Link to the header: Type-checking speed-ups" title="Link to the header: Type-checking speed-ups" href="#type-checking-speed-ups" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently.
These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</p>
    
      <h3 id="--incremental-improvements">
        
        
          <code>--incremental</code> improvements <a aria-label="Link to the header: --incremental improvements" title="Link to the header: --incremental improvements" href="#--incremental-improvements" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript 3.5 improves on 3.4’s <code>--incremental</code> build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc.
In scenarios involving hundreds of projects using TypeScript’s project references in <code>--build</code> mode, <a href="https://github.com/Microsoft/TypeScript/pull/31101">we’ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4</a>!</p>

<p>For more details, you can see the pull requests to</p>

<ul>
  <li><a href="https://github.com/Microsoft/TypeScript/pull/31100">cache module resolution</a></li>
  <li><a href="https://github.com/Microsoft/TypeScript/pull/31101">cache settings calculated from <code>tsconfig.json</code></a></li>
</ul>
    
      <h2 id="the-omit-helper-type">
        
        
          The <code>Omit</code> helper type <a aria-label="Link to the header: The Omit helper type" title="Link to the header: The Omit helper type" href="#the-omit-helper-type" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.5 introduces the new <code>Omit</code> helper type, which creates a new type with some properties dropped from the original.</p>

<pre><code class="language-ts">type Person = {
    name: string;
    age: number;
    location: string;
};

type QuantumPerson = Omit&lt;Person, "location"&gt;;

// equivalent to
type QuantumPerson = {
    name: string;
    age: number;
};
</code></pre>

<p>Here we were able to copy over all the properties of <code>Person</code> except for <code>location</code> using the <code>Omit</code> helper.</p>

<p>For more details, <a href="https://github.com/Microsoft/TypeScript/pull/30552">see the pull request on GitHub to add <code>Omit</code></a>, as well as <a href="https://github.com/microsoft/TypeScript/pull/31134">the change to use <code>Omit</code> for object rest</a>.</p>
    
      <h3 id="improved-excess-property-checks-in-union-types">
        
        
          Improved excess property checks in union types <a aria-label="Link to the header: Improved excess property checks in union types" title="Link to the header: Improved excess property checks in union types" href="#improved-excess-property-checks-in-union-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn’t have been.
For instance, TypeScript 3.4 permitted the incorrect <code>name</code> property in the object literal even though its types don’t match between <code>Point</code> and <code>Label</code>.</p>

<pre><code class="language-ts">type Point = {
    x: number;
    y: number;
};

type Label = {
    name: string;
};

const thing: Point | Label = {
    x: 0,
    y: 0,
    name: true // uh-oh!
};
</code></pre>

<p>Previously, a non-disciminated union wouldn’t have <em>any</em> excess property checking done on its members, and as a result, the incorrectly typed <code>name</code> property slipped by.</p>

<p>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to <em>some</em> union member and have the appropriate type, meaning that the sample above correctly issues an error.</p>

<p>Note that partial overlap is still permitted as long as the property types are valid.</p>

<pre><code class="language-ts">const pl: Point | Label = {
    x: 0,
    y: 0,
    name: "origin" // okay
};
</code></pre>
    
      <h2 id="the---allowumdglobalaccess-flag">
        
        
          The <code>--allowUmdGlobalAccess</code> flag <a aria-label="Link to the header: The --allowUmdGlobalAccess flag" title="Link to the header: The --allowUmdGlobalAccess flag" href="#the---allowumdglobalaccess-flag" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 3.5, you can now reference UMD global declarations like</p>

<pre><code>export as namespace foo;
</code></pre>

<p>from anywhere - even modules - using the new <code>--allowUmdGlobalAccess</code> flag.</p>

<p>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</p>

<p>For more details, <a href="https://github.com/Microsoft/TypeScript/pull/30776/files">see the pull request on GitHub</a>.</p>
    
      <h2 id="smarter-union-type-checking">
        
        
          Smarter union type checking <a aria-label="Link to the header: Smarter union type checking" title="Link to the header: Smarter union type checking" href="#smarter-union-type-checking" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 3.4 and prior, the following example would fail:</p>

<pre><code class="language-ts">type S = { done: boolean, value: number }
type T =
    | { done: false, value: number }
    | { done: true, value: number };

declare let source: S;
declare let target: T;

target = source;
</code></pre>

<p>That’s because <code>S</code> isn’t assignable to <code>{ done: false, value: number }</code> nor <code>{ done: true, value: number }</code>.
Why?
Because the <code>done</code> property in <code>S</code> isn’t specific enough - it’s <code>boolean</code> whereas each constituent of <code>T</code> has a <code>done</code> property that’s specifically <code>true</code> or <code>false</code>.
That’s what we meant by each constituent type being checked in isolation: TypeScript doesn’t just union each property together and see if <code>S</code> is assignable to that.
If it did, some bad code could get through like the following:</p>

<pre><code class="language-ts">interface Foo {
    kind: "foo";
    value: string;
}

interface Bar {
    kind: "bar";
    value: number;
}

function doSomething(x: Foo | Bar) {
    if (x.kind === "foo") {
        x.value.toLowerCase();
    }
}

// uh-oh - luckily TypeScript errors here!
doSomething({
    kind: "foo",
    value: 123,
});
</code></pre>

<p>However, this was a bit overly strict for the original example.
If you figure out the precise type of any possible value of <code>S</code>, you can actually see that it matches the types in <code>T</code> exactly.</p>

<p>In TypeScript 3.5, when assigning to types with discriminant properties like in <code>T</code>, the language actually <em>will</em> go further and decompose types like <code>S</code> into a union of every possible inhabitant type.
In this case, since <code>boolean</code> is a union of <code>true</code> and <code>false</code>, <code>S</code> will be viewed as a union of <code>{ done: false, value: number }</code> and <code>{ done: true, value: number }</code>.</p>

<p>For more details, you can <a href="https://github.com/microsoft/TypeScript/pull/30779">see the original pull request on GitHub</a>.</p>
    
      <h2 id="higher-order-type-inference-from-generic-constructors">
        
        
          Higher order type inference from generic constructors <a aria-label="Link to the header: Higher order type inference from generic constructors" title="Link to the header: Higher order type inference from generic constructors" href="#higher-order-type-inference-from-generic-constructors" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</p>

<pre><code class="language-ts">function compose&lt;T, U, V&gt;(
    f: (x: T) =&gt; U, g: (y: U) =&gt; V): (x: T) =&gt; V {
    
    return x =&gt; g(f(x))
}
</code></pre>

<p>took other generic functions as arguments, like so:</p>

<pre><code class="language-ts">function arrayify&lt;T&gt;(x: T): T[] {
    return [x];
}

type Box&lt;U&gt; = { value: U }
function boxify&lt;U&gt;(y: U): Box&lt;U&gt; {
    return { value: y };
}

let newFn = compose(arrayify, boxify);
</code></pre>

<p>Instead of a relatively useless type like <code>(x: {}) =&gt; Box&lt;{}[]&gt;</code>, which older versions of the language would infer, TypeScript 3.4’s inference allows <code>newFn</code> to be generic.
Its new type is <code>&lt;T&gt;(x: T) =&gt; Box&lt;T[]&gt;</code>.</p>

<p>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</p>

<pre><code class="language-ts">class Box&lt;T&gt; {
    kind: "box";
    value: T;
    constructor(value: T) {
        this.value = value;
    }
}

class Bag&lt;U&gt; {
    kind: "bag";
    value: U;
    constructor(value: U) {
        this.value = value;
    }
}


function composeCtor&lt;T, U, V&gt;(
    F: new (x: T) =&gt; U, G: new (y: U) =&gt; V): (x: T) =&gt; V {
    
    return x =&gt; new G(new F(x))
}

let f = composeCtor(Box, Bag); // has type '&lt;T&gt;(x: T) =&gt; Bag&lt;Box&lt;T&gt;&gt;'
let a = f(1024); // has type 'Bag&lt;Box&lt;number&gt;&gt;'
</code></pre>

<p>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</p>

<pre><code class="language-ts">type ComponentClass&lt;P&gt; = new (props: P) =&gt; Component&lt;P&gt;;
declare class Component&lt;P&gt; {
    props: P;
    constructor(props: P);
}

declare function myHoc&lt;P&gt;(C: ComponentClass&lt;P&gt;): ComponentClass&lt;P&gt;;

type NestedProps&lt;T&gt; = { foo: number, stuff: T };

declare class GenericComponent&lt;T&gt; extends Component&lt;NestedProps&lt;T&gt;&gt; {
}

// type is 'new &lt;T&gt;(props: NestedProps&lt;T&gt;) =&gt; Component&lt;NestedProps&lt;T&gt;&gt;'
const GenericComponent2 = myHoc(GenericComponent);
</code></pre>

<p>To learn more, <a href="https://github.com/microsoft/TypeScript/pull/31116">check out the original pull request on GitHub</a>.</p>
    
      <h2 id="typescript-34">
        
        
          TypeScript 3.4 <a aria-label="Link to the header: TypeScript 3.4" title="Link to the header: TypeScript 3.4" href="#typescript-34" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="faster-subsequent-builds-with-the---incremental-flag">
        
        
          Faster subsequent builds with the <code>--incremental</code> flag <a aria-label="Link to the header: Faster subsequent builds with the --incremental flag" title="Link to the header: Faster subsequent builds with the --incremental flag" href="#faster-subsequent-builds-with-the---incremental-flag" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.4 introduces a new flag called <code>--incremental</code> which tells TypeScript to save information about the project graph from the last compilation.
The next time TypeScript is invoked with <code>--incremental</code>, it will use that information to detect the least costly way to type-check and emit changes to your project.</p>

<pre><code class="language-json5">// tsconfig.json
{
    "compilerOptions": { 
        "incremental": true,
        "outDir": "./lib"
    },
    "include": ["./src"]
}
</code></pre>

<p>By default with these settings, when we run <code>tsc</code>, TypeScript will look for a file called <code>.tsbuildinfo</code> in the output directory (<code>./lib</code>).
If <code>./lib/.tsbuildinfo</code> doesn’t exist, it’ll be generated.
But if it does, <code>tsc</code> will try to use that file to incrementally type-check and update our output files.</p>

<p>These <code>.tsbuildinfo</code> files can be safely deleted and don’t have any impact on our code at runtime - they’re purely used to make compilations faster.
We can also name them anything that we want, and place them anywhere we want using the <code>--tsBuildInfoFile</code> flag.</p>

<pre><code class="language-json5">// front-end.tsconfig.json
{
    "compilerOptions": {
        "incremental": true,
        "tsBuildInfoFile": "./buildcache/front-end",
        "outDir": "./lib"
    },
    "include": ["./src"]
}
</code></pre>
    
      <h3 id="composite-projects">
        
        
          Composite projects <a aria-label="Link to the header: Composite projects" title="Link to the header: Composite projects" href="#composite-projects" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Part of the intent with composite projects (<code>tsconfig.json</code>s with <code>composite</code> set to <code>true</code>) is that references between different projects can be built incrementally.
As such, composite projects will <strong>always</strong> produce <code>.tsbuildinfo</code> files.</p>
    
      <h3 id="outfile">
        
        
          <code>outFile</code> <a aria-label="Link to the header: outFile" title="Link to the header: outFile" href="#outfile" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>When <code>outFile</code> is used, the build information file’s name will be based on the output file’s name.
As an example, if our output JavaScript file is <code>./output/foo.js</code>, then under the <code>--incremental</code> flag, TypeScript will generate the file <code>./output/foo.tsbuildinfo</code>.
As above, this can be controlled with the <code>--tsBuildInfoFile</code> flag.</p>
    
      <h2 id="higher-order-type-inference-from-generic-functions">
        
        
          Higher order type inference from generic functions <a aria-label="Link to the header: Higher order type inference from generic functions" title="Link to the header: Higher order type inference from generic functions" href="#higher-order-type-inference-from-generic-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences.
This means many function composition patterns now work better in 3.4.</p>

<p>To get more specific, let’s build up some motivation and consider the following <code>compose</code> function:</p>

<pre><code class="language-ts">function compose&lt;A, B, C&gt;(f: (arg: A) =&gt; B, g: (arg: B) =&gt; C): (arg: A) =&gt; C {
    return x =&gt; g(f(x));
}
</code></pre>

<p><code>compose</code> takes two other functions:</p>

<ul>
  <li><code>f</code> which takes some argument (of type <code>A</code>) and returns a value of type <code>B</code></li>
  <li><code>g</code> which takes an argument of type <code>B</code> (the type <code>f</code> returned), and returns a value of type <code>C</code></li>
</ul>

<p><code>compose</code> then returns a function which feeds its argument through <code>f</code> and then <code>g</code>.</p>

<p>When calling this function, TypeScript will try to figure out the types of <code>A</code>, <code>B</code>, and <code>C</code> through a process called <em>type argument inference</em>.
This inference process usually works pretty well:</p>

<pre><code class="language-ts">interface Person {
    name: string;
    age: number;
}

function getDisplayName(p: Person) {
    return p.name.toLowerCase();
}

function getLength(s: string) {
    return s.length;
}

// has type '(p: Person) =&gt; number'
const getDisplayNameLength = compose(
    getDisplayName,
    getLength,
);

// works and returns the type 'number'
getDisplayNameLength({ name: "Person McPersonface", age: 42 });
</code></pre>

<p>The inference process is fairly straightforward here because <code>getDisplayName</code> and <code>getLength</code> use types that can easily be referenced.
However, in TypeScript 3.3 and earlier, generic functions like <code>compose</code> didn’t work so well when passed other generic functions.</p>

<pre><code class="language-ts">interface Box&lt;T&gt; {
    value: T;
}

function makeArray&lt;T&gt;(x: T): T[] {
    return [x];
}

function makeBox&lt;U&gt;(value: U): Box&lt;U&gt; {
    return { value };
}

// has type '(arg: {}) =&gt; Box&lt;{}[]&gt;'
const makeBoxedArray = compose(
    makeArray,
    makeBox,
)

makeBoxedArray("hello!").value[0].toUpperCase();
//                                ~~~~~~~~~~~
// error: Property 'toUpperCase' does not exist on type '{}'.
</code></pre>

<p>In older versions, TypeScript would infer the empty object type (<code>{}</code>) when inferring from other type variables like <code>T</code> and <code>U</code>.</p>

<p>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript <em>will</em>, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</p>

<p>In other words, instead of producing the type</p>

<pre><code>(arg: {}) =&gt; Box&lt;{}[]&gt;
</code></pre>

<p>TypeScript 3.4 produces the type</p>

<pre><code class="language-ts">&lt;T&gt;(arg: T) =&gt; Box&lt;T[]&gt;
</code></pre>

<p>Notice that <code>T</code> has been propagated from <code>makeArray</code> into the resulting type’s type parameter list.
This means that genericity from <code>compose</code>’s arguments has been preserved and our <code>makeBoxedArray</code> sample will just work!</p>

<pre><code class="language-ts">interface Box&lt;T&gt; {
    value: T;
}

function makeArray&lt;T&gt;(x: T): T[] {
    return [x];
}

function makeBox&lt;U&gt;(value: U): Box&lt;U&gt; {
    return { value };
}

// has type '&lt;T&gt;(arg: T) =&gt; Box&lt;T[]&gt;'
const makeBoxedArray = compose(
    makeArray,
    makeBox,
)

// works with no problem!
makeBoxedArray("hello!").value[0].toUpperCase();
</code></pre>

<p>For more details, you can <a href="https://github.com/Microsoft/TypeScript/pull/30215">read more at the original change</a>.</p>
    
      <h2 id="improvements-for-readonlyarray-and-readonly-tuples">
        
        
          Improvements for <code>ReadonlyArray</code> and <code>readonly</code> tuples <a aria-label="Link to the header: Improvements for ReadonlyArray and readonly tuples" title="Link to the header: Improvements for ReadonlyArray and readonly tuples" href="#improvements-for-readonlyarray-and-readonly-tuples" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</p>
    
      <h3 id="a-new-syntax-for-readonlyarray">
        
        
          A new syntax for <code>ReadonlyArray</code> <a aria-label="Link to the header: A new syntax for ReadonlyArray" title="Link to the header: A new syntax for ReadonlyArray" href="#a-new-syntax-for-readonlyarray" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The <code>ReadonlyArray</code> type describes <code>Array</code>s that can only be read from.
Any variable with a reference to a <code>ReadonlyArray</code> can’t add, remove, or replace any elements of the array.</p>

<pre><code class="language-ts">function foo(arr: ReadonlyArray&lt;string&gt;) {
    arr.slice();        // okay
    arr.push("hello!"); // error!
}
</code></pre>

<p>While it’s good practice to use <code>ReadonlyArray</code> over <code>Array</code> when no mutation is intended, it’s often been a pain given that arrays have a nicer syntax.
Specifically, <code>number[]</code> is a shorthand version of <code>Array&lt;number&gt;</code>, just as <code>Date[]</code> is a shorthand for <code>Array&lt;Date&gt;</code>.</p>

<p>TypeScript 3.4 introduces a new syntax for <code>ReadonlyArray</code> using a new <code>readonly</code> modifier for array types.</p>

<pre><code class="language-ts">function foo(arr: readonly string[]) {
    arr.slice();        // okay
    arr.push("hello!"); // error!
}
</code></pre>
    
      <h3 id="readonly-tuples">
        
        
          <code>readonly</code> tuples <a aria-label="Link to the header: readonly tuples" title="Link to the header: readonly tuples" href="#readonly-tuples" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript 3.4 also introduces new support for <code>readonly</code> tuples.
We can prefix any tuple type with the <code>readonly</code> keyword to make it a <code>readonly</code> tuple, much like we now can with array shorthand syntax.
As you might expect, unlike ordinary tuples whose slots could be written to, <code>readonly</code> tuples only permit reading from those positions.</p>

<pre><code class="language-ts">function foo(pair: readonly [string, string]) {
    console.log(pair[0]);   // okay
    pair[1] = "hello!";     // error
}
</code></pre>

<table>
  <tbody>
    <tr>
      <td>The same way that ordinary tuples are types that extend from <code>Array</code> - a tuple with elements of type <code>T</code><sub><code>1</code></sub>, <code>T</code><sub><code>2</code></sub>, … <code>T</code><sub><code>n</code></sub> extends from <code>Array&lt;</code> <code>T</code><sub><code>1</code></sub></td>
      <td><code>T</code><sub><code>2</code></sub></td>
      <td>… <code>T</code><sub><code>n</code></sub> <code>&gt;</code> - <code>readonly</code> tuples are types that extend from <code>ReadonlyArray</code>. So a <code>readonly</code> tuple with elements <code>T</code><sub><code>1</code></sub>, <code>T</code><sub><code>2</code></sub>, … <code>T</code><sub><code>n</code></sub> extends from <code>ReadonlyArray&lt;</code> <code>T</code><sub><code>1</code></sub></td>
      <td><code>T</code><sub><code>2</code></sub></td>
      <td>… <code>T</code><sub><code>n</code></sub> <code>&gt;</code>.</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="readonly-mapped-type-modifiers-and-readonly-arrays">
        
        
          <code>readonly</code> mapped type modifiers and <code>readonly</code> arrays <a aria-label="Link to the header: readonly mapped type modifiers and readonly arrays" title="Link to the header: readonly mapped type modifiers and readonly arrays" href="#readonly-mapped-type-modifiers-and-readonly-arrays" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types.
This meant that a mapped type like <code>Boxify</code> could work on arrays and tuples alike.</p>

<pre><code class="language-ts">interface Box&lt;T&gt; { value: T }

type Boxify&lt;T&gt; = {
    [K in keyof T]: Box&lt;T[K]&gt;
}

// { a: Box&lt;string&gt;, b: Box&lt;number&gt; }
type A = Boxify&lt;{ a: string, b: number }&gt;;

// Array&lt;Box&lt;number&gt;&gt;
type B = Boxify&lt;number[]&gt;;

// [Box&lt;string&gt;, Box&lt;number&gt;]
type C = Boxify&lt;[string, boolean]&gt;;
</code></pre>

<p>Unfortunately, mapped types like the <code>Readonly</code> utility type were effectively no-ops on array and tuple types.</p>

<pre><code class="language-ts">// lib.d.ts
type Readonly&lt;T&gt; = {
    readonly [K in keyof T]: T[K]
}

// How code acted *before* TypeScript 3.4

// { readonly a: string, readonly b: number }
type A = Readonly&lt;{ a: string, b: number }&gt;;

// number[]
type B = Readonly&lt;number[]&gt;;

// [string, boolean]
type C = Readonly&lt;[string, boolean]&gt;;
</code></pre>

<p>In TypeScript 3.4, the <code>readonly</code> modifier in a mapped type will automatically convert array-like types to their corresponding <code>readonly</code> counterparts.</p>

<pre><code class="language-ts">// How code acts now *with* TypeScript 3.4

// { readonly a: string, readonly b: number }
type A = Readonly&lt;{ a: string, b: number }&gt;;

// readonly number[]
type B = Readonly&lt;number[]&gt;;

// readonly [string, boolean]
type C = Readonly&lt;[string, boolean]&gt;;
</code></pre>

<p>Similarly, you could write a utility type like <code>Writable</code> mapped type that strips away <code>readonly</code>-ness, and that would convert <code>readonly</code> array containers back to their mutable equivalents.</p>

<pre><code class="language-ts">type Writable&lt;T&gt; = {
    -readonly [K in keyof T]: T[K]
}

// { a: string, b: number }
type A = Writable&lt;{
    readonly a: string;
    readonly b: number
}&gt;;

// number[]
type B = Writable&lt;readonly number[]&gt;;

// [string, boolean]
type C = Writable&lt;readonly [string, boolean]&gt;;
</code></pre>
    
      <h3 id="caveats">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Despite its appearance, the <code>readonly</code> type modifier can only be used for syntax on array types and tuple types.
It is not a general-purpose type operator.</p>

<pre><code class="language-ts">let err1: readonly Set&lt;number&gt;; // error!
let err2: readonly Array&lt;boolean&gt;; // error!

let okay: readonly boolean[]; // works fine
</code></pre>

<p>You can <a href="https://github.com/Microsoft/TypeScript/pull/29435">see more details in the pull request</a>.</p>
    
      <h2 id="const-assertions">
        
        
          <code>const</code> assertions <a aria-label="Link to the header: const assertions" title="Link to the header: const assertions" href="#const-assertions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.4 introduces a new construct for literal values called <em><code>const</code></em> assertions.
Its syntax is a type assertion with <code>const</code> in place of the type name (e.g. <code>123 as const</code>).
When we construct new literal expressions with <code>const</code> assertions, we can signal to the language that</p>

<ul>
  <li>no literal types in that expression should be widened (e.g. no going from <code>"hello"</code> to <code>string</code>)</li>
  <li>object literals get <code>readonly</code> properties</li>
  <li>array literals become <code>readonly</code> tuples</li>
</ul>

<pre><code class="language-ts">// Type '"hello"'
let x = "hello" as const;

// Type 'readonly [10, 20]'
let y = [10, 20] as const;

// Type '{ readonly text: "hello" }'
let z = { text: "hello" } as const;
</code></pre>

<p>Outside of <code>.tsx</code> files, the angle bracket assertion syntax can also be used.</p>

<pre><code class="language-ts">// Type '"hello"'
let x = &lt;const&gt;"hello";

// Type 'readonly [10, 20]'
let y = &lt;const&gt;[10, 20];

// Type '{ readonly text: "hello" }'
let z = &lt;const&gt;{ text: "hello" };
</code></pre>

<p>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p>

<pre><code class="language-ts">// Works with no types referenced or declared.
// We only needed a single const assertion.
function getShapes() {
    let result = [
        { kind: "circle", radius: 100, },
        { kind: "square", sideLength: 50, },
    ] as const;
    
    return result;
}

for (const shape of getShapes()) {
    // Narrows perfectly!
    if (shape.kind === "circle") {
        console.log("Circle radius", shape.radius);
    }
    else {
        console.log("Square side length", shape.sideLength);
    }
}
</code></pre>

<p>Notice the above needed no type annotations.
The <code>const</code> assertion allowed TypeScript to take the most specific type of the expression.</p>

<p>This can even be used to enable <code>enum</code>-like patterns in plain JavaScript code if you choose not to use TypeScript’s <code>enum</code> construct.</p>

<pre><code class="language-ts">export const Colors = {
    red: "RED",
    blue: "BLUE",
    green: "GREEN",
} as const;

// or use an 'export default'

export default {
    red: "RED",
    blue: "BLUE",
    green: "GREEN",
} as const;
</code></pre>
    
      <h3 id="caveats-1">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-1" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>One thing to note is that <code>const</code> assertions can only be applied immediately on simple literal expressions.</p>

<pre><code class="language-ts">// Error! A 'const' assertion can only be applied to a
// to a string, number, boolean, array, or object literal.
let a = (Math.random() &lt; 0.5 ? 0 : 1) as const;

// Works!
let b = Math.random() &lt; 0.5 ?
    0 as const :
    1 as const;
</code></pre>

<p>Another thing to keep in mind is that <code>const</code> contexts don’t immediately convert an expression to be fully immutable.</p>

<pre><code class="language-ts">let arr = [1, 2, 3, 4];

let foo = {
    name: "foo",
    contents: arr,
} as const;

foo.name = "bar";   // error!
foo.contents = [];  // error!

foo.contents.push(5); // ...works!
</code></pre>

<p>For more details, you can <a href="https://github.com/Microsoft/TypeScript/pull/29510">check out the respective pull request</a>.</p>
    
      <h2 id="type-checking-for-globalthis">
        
        
          Type-checking for <code>globalThis</code> <a aria-label="Link to the header: Type-checking for globalThis" title="Link to the header: Type-checking for globalThis" href="#type-checking-for-globalthis" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.4 introduces support for type-checking ECMAScript’s new <code>globalThis</code> - a global variable that, well, refers to the global scope.
Unlike the above solutions, <code>globalThis</code> provides a standard way for accessing the global scope which can be used across different environments.</p>

<pre><code class="language-ts">// in a global file:

var abc = 100;

// Refers to 'abc' from above.
globalThis.abc = 200;
</code></pre>

<p>Note that global variables declared with <code>let</code> and <code>const</code> don’t show up on <code>globalThis</code>.</p>

<pre><code class="language-ts">let answer = 42;

// error! Property 'answer' does not exist on 'typeof globalThis'.
globalThis.answer = 333333;
</code></pre>

<p>It’s also important to note that TypeScript doesn’t transform references to <code>globalThis</code> when compiling to older versions of ECMAScript.
As such, unless you’re targeting evergreen browsers (which already support <code>globalThis</code>), you may want to <a href="https://github.com/ljharb/globalThis">use an appropriate polyfill</a> instead.</p>

<p>For more details on the implementation, see <a href="https://github.com/Microsoft/TypeScript/pull/29332">the feature’s pull request</a>.</p>
    
      <h2 id="typescript-33">
        
        
          TypeScript 3.3 <a aria-label="Link to the header: TypeScript 3.3" title="Link to the header: TypeScript 3.3" href="#typescript-33" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="improved-behavior-for-calling-union-types">
        
        
          Improved behavior for calling union types <a aria-label="Link to the header: Improved behavior for calling union types" title="Link to the header: Improved behavior for calling union types" href="#improved-behavior-for-calling-union-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In prior versions of TypeScript, unions of callable types could <em>only</em> be invoked if they had identical parameter lists.</p>

<pre><code class="language-ts">type Fruit = "apple" | "orange";
type Color = "red" | "orange";

type FruitEater = (fruit: Fruit) =&gt; number;     // eats and ranks the fruit
type ColorConsumer = (color: Color) =&gt; string;  // consumes and describes the colors

declare let f: FruitEater | ColorConsumer;

// Cannot invoke an expression whose type lacks a call signature.
//   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)
f("orange");
</code></pre>

<p>However, in the above example, both <code>FruitEater</code>s and <code>ColorConsumer</code>s should be able to take the string <code>"orange"</code>, and return either a <code>number</code> or a <code>string</code>.</p>

<p>In TypeScript 3.3, this is no longer an error.</p>

<pre><code class="language-ts">type Fruit = "apple" | "orange";
type Color = "red" | "orange";

type FruitEater = (fruit: Fruit) =&gt; number;     // eats and ranks the fruit
type ColorConsumer = (color: Color) =&gt; string;  // consumes and describes the colors

declare let f: FruitEater | ColorConsumer;

f("orange"); // It works! Returns a 'number | string'.

f("apple");  // error - Argument of type '"red"' is not assignable to parameter of type '"orange"'.

f("red");    // error - Argument of type '"red"' is not assignable to parameter of type '"orange"'.
</code></pre>

<p>In TypeScript 3.3, the parameters of these signatures are <em>intersected</em> together to create a new signature.</p>

<p>In the example above, the parameters <code>fruit</code> and <code>color</code> are intersected together to a new parameter of type <code>Fruit &amp; Color</code>.
<code>Fruit &amp; Color</code> is really the same as <code>("apple" | "orange") &amp; ("red" | "orange")</code> which is equivalent to <code>("apple" &amp; "red") | ("apple" &amp; "orange") | ("orange" &amp; "red") | ("orange" &amp; "orange")</code>.
Each of those impossible intersections reduces to <code>never</code>, and we’re left with <code>"orange" &amp; "orange"</code> which is just <code>"orange"</code>.</p>
    
      <h3 id="caveats-2">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-2" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature.
That means methods on <code>number[] | string[]</code> like <code>map</code> (which is generic) still won’t be callable.</p>

<p>On the other hand, methods like <code>forEach</code> will now be callable, but under <code>noImplicitAny</code> there may be some issues.</p>

<pre><code class="language-ts">interface Dog {
    kind: "dog"
    dogProp: any;
}
interface Cat {
    kind: "cat"
    catProp: any;
}

const catOrDogArray: Dog[] | Cat[] = [];

catOrDogArray.forEach(animal =&gt; {
    //                ~~~~~~ error!
    // Parameter 'animal' implicitly has an 'any' type.
});
</code></pre>

<p>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</p>

<pre><code class="language-ts">interface Dog {
    kind: "dog"
    dogProp: any;
}
interface Cat {
    kind: "cat"
    catProp: any;
}

const catOrDogArray: Dog[] | Cat[] = [];
catOrDogArray.forEach((animal: Dog | Cat) =&gt; {
    if (animal.kind === "dog") {
        animal.dogProp;
        // ...
    }
    else if (animal.kind === "cat") {
        animal.catProp;
        // ...
    }
});
</code></pre>
    
      <h2 id="incremental-file-watching-for-composite-projects-in---build---watch">
        
        
          Incremental file watching for composite projects in <code>--build --watch</code> <a aria-label="Link to the header: Incremental file watching for composite projects in --build --watch" title="Link to the header: Incremental file watching for composite projects in --build --watch" href="#incremental-file-watching-for-composite-projects-in---build---watch" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.0 introduced a new feature for structuring builds called “composite projects”.
Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience.
Thanks to composite projects, TypeScript can use <code>--build</code> mode to recompile only the set of projects and dependencies.
You can think of this as optimizing <em>inter</em>-project builds.</p>

<p>TypeScript 2.7 also introduced <code>--watch</code> mode builds via a new incremental “builder” API.
In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking.
You can think of this as optimizing <em>intra</em>-project builds.</p>

<p>Prior to 3.3, building composite projects using <code>--build --watch</code> actually didn’t use this incremental file watching infrastructure.
An update in one project under <code>--build --watch</code> mode would force a full build of that project, rather than determining which files within that project were affected.</p>

<p>In TypeScript 3.3, <code>--build</code> mode’s <code>--watch</code> flag <em>does</em> leverage incremental file watching as well.
That can mean signficantly faster builds under <code>--build --watch</code>.
In our testing, this functionality has resulted in <strong>a reduction of 50% to 75% in build times</strong> of the original <code>--build --watch</code> times.
<a href="https://github.com/Microsoft/TypeScript/pull/29161">You can read more on the original pull request for the change</a> to see specific numbers, but we believe most composite project users will see significant wins here.</p>
    
      <h2 id="typescript-32">
        
        
          TypeScript 3.2 <a aria-label="Link to the header: TypeScript 3.2" title="Link to the header: TypeScript 3.2" href="#typescript-32" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="strictbindcallapply">
        
        
          <code>strictBindCallApply</code> <a aria-label="Link to the header: strictBindCallApply" title="Link to the header: strictBindCallApply" href="#strictbindcallapply" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.2 introduces a new <code>--strictBindCallApply</code> compiler option (in the <code>--strict</code> family of options) with which the <code>bind</code>, <code>call</code>, and <code>apply</code> methods on function objects are strongly typed and strictly checked.</p>

<pre><code class="language-ts">function foo(a: number, b: string): string {
    return a + b;
}

let a = foo.apply(undefined, [10]);              // error: too few argumnts
let b = foo.apply(undefined, [10, 20]);          // error: 2nd argument is a number
let c = foo.apply(undefined, [10, "hello", 30]); // error: too many arguments
let d = foo.apply(undefined, [10, "hello"]);     // okay! returns a string
</code></pre>

<p>This is achieved by introducing two new types, <code>CallableFunction</code> and <code>NewableFunction</code>, in <code>lib.d.ts</code>. These types contain specialized generic method declarations for <code>bind</code>, <code>call</code>, and <code>apply</code> for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In <code>--strictBindCallApply</code> mode these declarations are used in place of the (very permissive) declarations provided by type <code>Function</code>.</p>
    
      <h3 id="caveats-3">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-3" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Since the stricter checks may uncover previously unreported errors, this is a breaking change in <code>--strict</code> mode.</p>

<p>Additionally, <a href="https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450">another caveat</a> of this new functionality is that due to certain limitations, <code>bind</code>, <code>call</code>, and <code>apply</code> can’t yet fully model generic functions or functions that have overloads.
When using these methods on a generic function, type parameters will be substituted with the empty object type (<code>{}</code>), and when used on a function with overloads, only the last overload will ever be modeled.</p>
    
      <h2 id="generic-spread-expressions-in-object-literals">
        
        
          Generic spread expressions in object literals <a aria-label="Link to the header: Generic spread expressions in object literals" title="Link to the header: Generic spread expressions in object literals" href="#generic-spread-expressions-in-object-literals" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the <code>Object.assign</code> function and JSX literals. For example:</p>

<pre><code class="language-ts">function taggedObject&lt;T, U extends string&gt;(obj: T, tag: U) {
    return { ...obj, tag };  // T &amp; { tag: U }
}

let x = taggedObject({ x: 10, y: 20 }, "point");  // { x: number, y: number } &amp; { tag: "point" }
</code></pre>

<p>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</p>

<pre><code class="language-ts">function foo1&lt;T&gt;(t: T, obj1: { a: string }, obj2: { b: string }) {
    return { ...obj1, x: 1, ...t, ...obj2, y: 2 };  // { a: string, x: number } &amp; T &amp; { b: string, y: number }
}
</code></pre>

<p>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</p>

<pre><code class="language-ts">function spread&lt;T, U&gt;(t: T, u: U) {
    return { ...t, ...u };  // T &amp; U
}

declare let x: { a: string, b: number };
declare let y: { b: string, c: boolean };

let s1 = { ...x, ...y };  // { a: string, b: string, c: boolean }
let s2 = spread(x, y);    // { a: string, b: number } &amp; { b: string, c: boolean }
let b1 = s1.b;  // string
let b2 = s2.b;  // number &amp; string
</code></pre>
    
      <h2 id="generic-object-rest-variables-and-parameters">
        
        
          Generic object rest variables and parameters <a aria-label="Link to the header: Generic object rest variables and parameters" title="Link to the header: Generic object rest variables and parameters" href="#generic-object-rest-variables-and-parameters" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined <code>Pick</code> and <code>Exclude</code> helper types from <code>lib.d.ts</code>, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</p>

<pre><code class="language-ts">function excludeTag&lt;T extends { tag: string }&gt;(obj: T) {
    let { tag, ...rest } = obj;
    return rest;  // Pick&lt;T, Exclude&lt;keyof T, "tag"&gt;&gt;
}

const taggedPoint = { x: 10, y: 20, tag: "point" };
const point = excludeTag(taggedPoint);  // { x: number, y: number }
</code></pre>
    
      <h2 id="bigint">
        
        
          BigInt <a aria-label="Link to the header: BigInt" title="Link to the header: BigInt" href="#bigint" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers.
TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting <code>esnext</code>.</p>

<p>BigInt support in TypeScript introduces a new primitive type called the <code>bigint</code> (all lowercase).
You can get a <code>bigint</code> by calling the <code>BigInt()</code> function or by writing out a BigInt literal by adding an <code>n</code> to the end of any integer numeric literal:</p>

<pre><code class="language-ts">let foo: bigint = BigInt(100); // the BigInt function
let bar: bigint = 100n;        // a BigInt literal

// *Slaps roof of fibonacci function*
// This bad boy returns ints that can get *so* big!
function fibonacci(n: bigint) {
    let result = 1n;
    for (let last = 0n, i = 0n; i &lt; n; i++) {
        const current = result;
        result += last;
        last = current;
    }
    return result;
}

fibonacci(10000n)
</code></pre>

<p>While you might imagine close interaction between <code>number</code> and <code>bigint</code>, the two are separate domains.</p>

<pre><code class="language-ts">declare let foo: number;
declare let bar: bigint;

foo = bar; // error: Type 'bigint' is not assignable to type 'number'.
bar = foo; // error: Type 'number' is not assignable to type 'bigint'.
</code></pre>

<p>As specified in ECMAScript, mixing <code>number</code>s and <code>bigint</code>s in arithmetic operations is an error.
You’ll have to explicitly convert values to <code>BigInt</code>s.</p>

<pre><code class="language-ts">console.log(3.141592 * 10000n);     // error
console.log(3145 * 10n);            // error
console.log(BigInt(3145) * 10n);    // okay!
</code></pre>

<p>Also important to note is that <code>bigint</code>s produce a new string when using the <code>typeof</code> operator: the string <code>"bigint"</code>.
Thus, TypeScript correctly narrows using <code>typeof</code> as you’d expect.</p>

<pre><code class="language-ts">function whatKindOfNumberIsIt(x: number | bigint) {
    if (typeof x === "bigint") {
        console.log("'x' is a bigint!");
    }
    else {
        console.log("'x' is a floating-point number");
    }
}
</code></pre>

<p>We’d like to extend a huge thanks to <a href="https://github.com/calebsander">Caleb Sander</a> for all the work on this feature.
We’re grateful for the contribution, and we’re sure our users are too!</p>
    
      <h3 id="caveats-4">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-4" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>As we mentioned, BigInt support is only available for the <code>esnext</code> target.
It may not be obvious, but because BigInts have different behavior for mathematical operators like <code>+</code>, <code>-</code>, <code>*</code>, etc., providing functionality for older targets where the feature doesn’t exist (like <code>es2017</code> and below) would involve rewriting each of these operations.
TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</p>

<p>For that reason, we have no immediate plans to provide downleveling support.
On the bright side, Node 11 and newer versions of Chrome already support this feature, so you’ll be able to use BigInts there when targeting <code>esnext</code>.</p>

<p>Certain targets may include a polyfill or BigInt-like runtime object.
For those purposes you may want to add <code>esnext.bigint</code> to the <code>lib</code> setting in your compiler options.</p>
    
      <h2 id="non-unit-types-as-union-discriminants">
        
        
          Non-unit types as union discriminants <a aria-label="Link to the header: Non-unit types as union discriminants" title="Link to the header: Non-unit types as union discriminants" href="#non-unit-types-as-union-discriminants" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property.
Common properties of unions are now considered discriminants as long as they contain <em>some</em> singleton type (e.g. a string literal, <code>null</code>, or <code>undefined</code>), and they contain no generics.</p>

<p>As a result, TypeScript 3.2 considers the <code>error</code> property in the following example to be a discriminant, whereas before it wouldn’t since <code>Error</code> isn’t a singleton type.
Thanks to this, narrowing works correctly in the body of the <code>unwrap</code> function.</p>

<pre><code class="language-ts">type Result&lt;T&gt; =
    | { error: Error; data: null }
    | { error: null; data: T };

function unwrap&lt;T&gt;(result: Result&lt;T&gt;) {
    if (result.error) {
        // Here 'error' is non-null
        throw result.error;
    }

    // Now 'data' is non-null
    return result.data;
}
</code></pre>
    
      <h2 id="tsconfigjson-inheritance-via-nodejs-packages">
        
        
          <code>tsconfig.json</code> inheritance via Node.js packages <a aria-label="Link to the header: tsconfig.json inheritance via Node.js packages" title="Link to the header: tsconfig.json inheritance via Node.js packages" href="#tsconfigjson-inheritance-via-nodejs-packages" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.2 now resolves <code>tsconfig.json</code>s from <code>node_modules</code>. When using a bare path for the <code>"extends"</code> field in <code>tsconfig.json</code>, TypeScript will dive into <code>node_modules</code> packages for us.</p>

<pre><code class="language-json5">{
    "extends": "@my-team/tsconfig-base",
    "include": ["./**/*"]
    "compilerOptions": {
        // Override certain options on a project-by-project basis.
        "strictBindCallApply": false,
    }
}
</code></pre>

<p>Here, TypeScript will climb up <code>node_modules</code> folders looking for a <code>@my-team/tsconfig-base</code> package. For each of those packages, TypeScript will first check whether <code>package.json</code> contains a <code>"tsconfig"</code> field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a <code>tsconfig.json</code> at the root. This is similar to the lookup process for <code>.js</code> files in packages that Node uses, and the <code>.d.ts</code> lookup process that TypeScript already uses.</p>

<p>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</p>
    
      <h2 id="the-new---showconfig-flag">
        
        
          The new <code>--showConfig</code> flag <a aria-label="Link to the header: The new --showConfig flag" title="Link to the header: The new --showConfig flag" href="#the-new---showconfig-flag" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>tsc</code>, the TypeScript compiler, supports a new flag called <code>--showConfig</code>.
When running <code>tsc --showConfig</code>, TypeScript will calculate the effective <code>tsconfig.json</code> (after calculating options inherited from the <code>extends</code> field) and print that out.
This can be useful for diagnosing configuration issues in general.</p>
    
      <h2 id="objectdefineproperty-declarations-in-javascript">
        
        
          <code>Object.defineProperty</code> declarations in JavaScript <a aria-label="Link to the header: Object.defineProperty declarations in JavaScript" title="Link to the header: Object.defineProperty declarations in JavaScript" href="#objectdefineproperty-declarations-in-javascript" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>When writing in JavaScript files (using <code>allowJs</code>), TypeScript now recognizes declarations that use <code>Object.defineProperty</code>.
This means you’ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the <code>checkJs</code> option or adding a <code>// @ts-check</code> comment to the top of your file).</p>

<pre><code class="language-js">// @ts-check

let obj = {};
Object.defineProperty(obj, "x", { value: "hello", writable: false });

obj.x.toLowercase();
//    ~~~~~~~~~~~
//    error:
//     Property 'toLowercase' does not exist on type 'string'.
//     Did you mean 'toLowerCase'?

obj.x = "world";
//  ~
//  error:
//   Cannot assign to 'x' because it is a read-only property.
</code></pre>
    
      <h2 id="typescript-31">
        
        
          TypeScript 3.1 <a aria-label="Link to the header: TypeScript 3.1" title="Link to the header: TypeScript 3.1" href="#typescript-31" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="mapped-types-on-tuples-and-arrays">
        
        
          Mapped types on tuples and arrays <a aria-label="Link to the header: Mapped types on tuples and arrays" title="Link to the header: Mapped types on tuples and arrays" href="#mapped-types-on-tuples-and-arrays" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 3.1, mapped object types<sup><a href="#ts-3-1-only-homomorphic">[1]</a></sup> over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like <code>push()</code>, <code>pop()</code>, and <code>length</code> are converted.
For example:</p>

<pre><code class="language-ts">type MapToPromise&lt;T&gt; = { [K in keyof T]: Promise&lt;T[K]&gt; };

type Coordinate = [number, number]

type PromiseCoordinate = MapToPromise&lt;Coordinate&gt;; // [Promise&lt;number&gt;, Promise&lt;number&gt;]
</code></pre>

<p><code>MapToPromise</code> takes a type <code>T</code>, and when that type is a tuple like <code>Coordinate</code>, only the numeric properties are converted.
In <code>[number, number]</code>, there are two numerically named properties: <code>0</code> and <code>1</code>.
When given a tuple like that, <code>MapToPromise</code> will create a new tuple where the <code>0</code> and <code>1</code> properties are <code>Promise</code>s of the original type.
So the resulting type <code>PromiseCoordinate</code> ends up with the type <code>[Promise&lt;number&gt;, Promise&lt;number&gt;]</code>.</p>
    
      <h2 id="properties-declarations-on-functions">
        
        
          Properties declarations on functions <a aria-label="Link to the header: Properties declarations on functions" title="Link to the header: Properties declarations on functions" href="#properties-declarations-on-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.1 brings the ability to define properties on function declarations and <code>const</code>-declared functons, simply by assigning to properties on these functions in the same scope.
This allows us to write canonical JavaScript code without resorting to <code>namespace</code> hacks.
For example:</p>

<pre><code class="language-ts">function readImage(path: string, callback: (err: any, image: Image) =&gt; void) {
    // ...
}

readImage.sync = (path: string) =&gt; {
    const contents = fs.readFileSync(path);
    return decodeImageSync(contents);
}
</code></pre>

<p>Here, we have a function <code>readImage</code> which reads an image in a non-blocking asynchronous way.
In addition to <code>readImage</code>, we’ve provided a convenience function on <code>readImage</code> itself called <code>readImage.sync</code>.</p>

<p>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to “just work” TypeScript.
Additionaly, this approach for property declarations allows us to express common patterns like <code>defaultProps</code> and <code>propTypes</code> on React stateless function components (SFCs).</p>

<pre><code class="language-ts">export const FooComponent = ({ name }) =&gt; (
    &lt;div&gt;Hello! I am {name}&lt;/div&gt;
);

FooComponent.defaultProps = {
    name: "(anonymous)",
};
</code></pre>

<!--
fs.readFile(path, (err, data) => {
        if (err) callback(err, undefined);
        else decodeImage(data, (err, image) => {
            if (err) callback(err, undefined);
            else callback(undefined, image);
        });
    });
-->
    <hr />

<p><sup id="ts-3-1-only-homomorphic">[1]</sup> More specifically, homomorphic mapped types like in the above form.</p>
      <h2 id="version-selection-with-typesversions">
        
        
          Version selection with <code>typesVersions</code> <a aria-label="Link to the header: Version selection with typesVersions" title="Link to the header: Version selection with typesVersions" href="#version-selection-with-typesversions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accomodating users on the older versions are difficult.
TypeScript introduces a new feature called <code>typesVersions</code> to help accomodate these scenarios.</p>

<p>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a <code>package.json</code> file to figure out which files it needs to read, it first looks at a new field called <code>typesVersions</code>.
A <code>package.json</code> with a <code>typesVersions</code> field might look like this:</p>

<pre><code class="language-json">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    "&gt;=3.1": { "*": ["ts3.1/*"] }
  }
}
</code></pre>

<p>This <code>package.json</code> tells TypeScript to check whether the current version of TypeScript is running.
If it’s 3.1 or later, it figures out the path you’ve imported relative to the package, and reads from the package’s <code>ts3.1</code> folder.
That’s what that <code>{ "*": ["ts3.1/*"] }</code> means - if you’re familiar with path mapping today, it works exactly like that.</p>

<p>So in the above example, if we’re importing from <code>"package-name"</code>, we’ll try to resolve from <code>[...]/node_modules/package-name/ts3.1/index.d.ts</code> (and other relevant paths) when running in TypeScript 3.1.
If we import from <code>package-name/foo</code>, we’ll try to look for <code>[...]/node_modules/package-name/ts3.1/foo.d.ts</code> and <code>[...]/node_modules/package-name/ts3.1/foo/index.d.ts</code>.</p>

<p>What if we’re not running in TypeScript 3.1 in this example?
Well, if none of the fields in <code>typesVersions</code> get matched, TypeScript falls back to the <code>types</code> field, so here TypeScript 3.0 and earlier will be redirected to <code>[...]/node_modules/package-name/index.d.ts</code>.</p>
    
      <h3 id="matching-behavior">
        
        
          Matching behavior <a aria-label="Link to the header: Matching behavior" title="Link to the header: Matching behavior" href="#matching-behavior" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The way that TypeScript decides on whether a version of the compiler &amp; language matches is by using Node’s <a href="https://github.com/npm/node-semver#ranges">semver ranges</a>.</p>
    
      <h3 id="multiple-fields">
        
        
          Multiple fields <a aria-label="Link to the header: Multiple fields" title="Link to the header: Multiple fields" href="#multiple-fields" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p><code>typesVersions</code> can support multiple fields where each field name is specified by the range to match on.</p>

<pre><code class="language-json">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    "&gt;=3.2": { "*": ["ts3.2/*"] },
    "&gt;=3.1": { "*": ["ts3.1/*"] }
  }
}
</code></pre>

<p>Since ranges have the potential to overlap, determining which redirect applies is order-specific.
That means in the above example, even though both the <code>&gt;=3.2</code> and the <code>&gt;=3.1</code> matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</p>

<pre><code class="language-json5">{
  "name": "package-name",
  "version": "1.0",
  "types": "./index.d.ts",
  "typesVersions": {
    // NOTE: this doesn't work!
    "&gt;=3.1": { "*": ["ts3.1/*"] },
    "&gt;=3.2": { "*": ["ts3.2/*"] }
  }
}
</code></pre>
    
      <h2 id="typescript-30">
        
        
          TypeScript 3.0 <a aria-label="Link to the header: TypeScript 3.0" title="Link to the header: TypeScript 3.0" href="#typescript-30" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="tuples-in-rest-parameters-and-spread-expressions">
        
        
          Tuples in rest parameters and spread expressions <a aria-label="Link to the header: Tuples in rest parameters and spread expressions" title="Link to the header: Tuples in rest parameters and spread expressions" href="#tuples-in-rest-parameters-and-spread-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types.
TypeScript 3.0 adds support for:</p>

<ul>
  <li><a href="#rest-parameters-with-tuple-types">Expansion of rest parameters with tuple types into discrete parameters.</a></li>
  <li><a href="#spread-expressions-with-tuple-types">Expansion of spread expressions with tuple types into discrete arguments.</a></li>
  <li><a href="#generic-rest-parameters">Generic rest parameters and corresponding inference of tuple types.</a></li>
  <li><a href="#optional-elements-in-tuple-types">Optional elements in tuple types.</a></li>
  <li><a href="#rest-elements-in-tuple-types">Rest elements in tuple types.</a></li>
</ul>

<p>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</p>
    
      <h3 id="rest-parameters-with-tuple-types">
        
        
          Rest parameters with tuple types <a aria-label="Link to the header: Rest parameters with tuple types" title="Link to the header: Rest parameters with tuple types" href="#rest-parameters-with-tuple-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters.
For example the following two declarations are equivalent:</p>

<pre><code class="language-ts">declare function foo(...args: [number, string, boolean]): void;
</code></pre>

<pre><code class="language-ts">declare function foo(args_0: number, args_1: string, args_2: boolean): void;
</code></pre>
    
      <h3 id="spread-expressions-with-tuple-types">
        
        
          Spread expressions with tuple types <a aria-label="Link to the header: Spread expressions with tuple types" title="Link to the header: Spread expressions with tuple types" href="#spread-expressions-with-tuple-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</p>

<p>Thus, the following calls are equivalent:</p>

<pre><code class="language-ts">const args: [number, string, boolean] = [42, "hello", true];
foo(42, "hello", true);
foo(args[0], args[1], args[2]);
foo(...args);
</code></pre>
    
      <h3 id="generic-rest-parameters">
        
        
          Generic rest parameters <a aria-label="Link to the header: Generic rest parameters" title="Link to the header: Generic rest parameters" href="#generic-rest-parameters" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</p>
    
      <h5 id="example">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">declare function bind&lt;T, U extends any[], V&gt;(f: (x: T, ...args: U) =&gt; V, x: T): (...args: U) =&gt; V;

declare function f3(x: number, y: string, z: boolean): void;

const f2 = bind(f3, 42);  // (y: string, z: boolean) =&gt; void
const f1 = bind(f2, "hello");  // (z: boolean) =&gt; void
const f0 = bind(f1, true);  // () =&gt; void

f3(42, "hello", true);
f2("hello", true);
f1(true);
f0();
</code></pre>

<p>In the declaration of <code>f2</code> above, type inference infers types <code>number</code>, <code>[string, boolean]</code> and <code>void</code> for <code>T</code>, <code>U</code> and <code>V</code> respectively.</p>

<p>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for <code>U</code>, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</p>
    
      <h3 id="optional-elements-in-tuple-types">
        
        
          Optional elements in tuple types <a aria-label="Link to the header: Optional elements in tuple types" title="Link to the header: Optional elements in tuple types" href="#optional-elements-in-tuple-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Tuple types now permit a <code>?</code> postfix on element types to indicate that the element is optional:</p>
    
      <h5 id="example-1">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-1" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">let t: [number, string?, boolean?];
t = [42, "hello", true];
t = [42, "hello"];
t = [42];
</code></pre>

<p>In <code>--strictNullChecks</code> mode, a <code>?</code> modifier automatically includes <code>undefined</code> in the element type, similar to optional parameters.</p>

<p>A tuple type permits an element to be omitted if it has a postfix <code>?</code> modifier on its type and all elements to the right of it also have <code>?</code> modifiers.</p>

<p>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</p>

<p>The <code>length</code> property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths.
For example, the type of the <code>length</code> property in the tuple type <code>[number, string?, boolean?]</code> is <code>1 | 2 | 3</code>.</p>
    
      <h3 id="rest-elements-in-tuple-types">
        
        
          Rest elements in tuple types <a aria-label="Link to the header: Rest elements in tuple types" title="Link to the header: Rest elements in tuple types" href="#rest-elements-in-tuple-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The last element of a tuple type can be a rest element of the form <code>...X</code>, where <code>X</code> is an array type.
A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type.
For example, <code>[number, ...string[]]</code> means tuples with a <code>number</code> element followed by any number of <code>string</code> elements.</p>
    
      <h5 id="example-2">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-2" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function tuple&lt;T extends any[]&gt;(...args: T): T {
    return args;
}

const numbers: number[] = getArrayOfNumbers();
const t1 = tuple("foo", 1, true);  // [string, number, boolean]
const t2 = tuple("bar", ...numbers);  // [string, ...number[]]
</code></pre>

<p>The type of the <code>length</code> property of a tuple type with a rest element is <code>number</code>.</p>
    
      <h2 id="new-unknown-top-type">
        
        
          New <code>unknown</code> top type <a aria-label="Link to the header: New unknown top type" title="Link to the header: New unknown top type" href="#new-unknown-top-type" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 3.0 introduces a new top type <code>unknown</code>.
<code>unknown</code> is the type-safe counterpart of <code>any</code>.
Anything is assignable to <code>unknown</code>, but <code>unknown</code> isn’t assignable to anything but itself and <code>any</code> without a type assertion or a control flow based narrowing.
Likewise, no operations are permitted on an <code>unknown</code> without first asserting or narrowing to a more specific type.</p>
    
      <h5 id="example-3">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-3" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">// In an intersection everything absorbs unknown

type T00 = unknown &amp; null;  // null
type T01 = unknown &amp; undefined;  // undefined
type T02 = unknown &amp; null &amp; undefined;  // null &amp; undefined (which becomes never)
type T03 = unknown &amp; string;  // string
type T04 = unknown &amp; string[];  // string[]
type T05 = unknown &amp; unknown;  // unknown
type T06 = unknown &amp; any;  // any

// In a union an unknown absorbs everything

type T10 = unknown | null;  // unknown
type T11 = unknown | undefined;  // unknown
type T12 = unknown | null | undefined;  // unknown
type T13 = unknown | string;  // unknown
type T14 = unknown | string[];  // unknown
type T15 = unknown | unknown;  // unknown
type T16 = unknown | any;  // any

// Type variable and unknown in union and intersection

type T20&lt;T&gt; = T &amp; {};  // T &amp; {}
type T21&lt;T&gt; = T | {};  // T | {}
type T22&lt;T&gt; = T &amp; unknown;  // T
type T23&lt;T&gt; = T | unknown;  // unknown

// unknown in conditional types

type T30&lt;T&gt; = unknown extends T ? true : false;  // Deferred
type T31&lt;T&gt; = T extends unknown ? true : false;  // Deferred (so it distributes)
type T32&lt;T&gt; = never extends T ? true : false;  // true
type T33&lt;T&gt; = T extends never ? true : false;  // Deferred

// keyof unknown

type T40 = keyof any;  // string | number | symbol
type T41 = keyof unknown;  // never

// Only equality operators are allowed with unknown

function f10(x: unknown) {
    x == 5;
    x !== 10;
    x &gt;= 0;  // Error
    x + 1;  // Error
    x * 2;  // Error
    -x;  // Error
    +x;  // Error
}

// No property accesses, element accesses, or function calls

function f11(x: unknown) {
    x.foo;  // Error
    x[5];  // Error
    x();  // Error
    new x();  // Error
}

// typeof, instanceof, and user defined type predicates

declare function isFunction(x: unknown): x is Function;

function f20(x: unknown) {
    if (typeof x === "string" || typeof x === "number") {
        x;  // string | number
    }
    if (x instanceof Error) {
        x;  // Error
    }
    if (isFunction(x)) {
        x;  // Function
    }
}

// Homomorphic mapped type over unknown

type T50&lt;T&gt; = { [P in keyof T]: number };
type T51 = T50&lt;any&gt;;  // { [x: string]: number }
type T52 = T50&lt;unknown&gt;;  // {}

// Anything is assignable to unknown

function f21&lt;T&gt;(pAny: any, pNever: never, pT: T) {
    let x: unknown;
    x = 123;
    x = "hello";
    x = [1, 2, 3];
    x = new Error();
    x = x;
    x = pAny;
    x = pNever;
    x = pT;
}

// unknown assignable only to itself and any

function f22(x: unknown) {
    let v1: any = x;
    let v2: unknown = x;
    let v3: object = x;  // Error
    let v4: string = x;  // Error
    let v5: string[] = x;  // Error
    let v6: {} = x;  // Error
    let v7: {} | null | undefined = x;  // Error
}

// Type parameter 'T extends unknown' not related to object

function f23&lt;T extends unknown&gt;(x: T) {
    let y: object = x;  // Error
}

// Anything but primitive assignable to { [x: string]: unknown }

function f24(x: { [x: string]: unknown }) {
    x = {};
    x = { a: 5 };
    x = [1, 2, 3];
    x = 123;  // Error
}

// Locals of type unknown always considered initialized

function f25() {
    let x: unknown;
    let y = x;
}

// Spread of unknown causes result to be unknown

function f26(x: {}, y: unknown, z: any) {
    let o1 = { a: 42, ...x };  // { a: number }
    let o2 = { a: 42, ...x, ...y };  // unknown
    let o3 = { a: 42, ...x, ...y, ...z };  // any
}

// Functions with unknown return type don't need return expressions

function f27(): unknown {
}

// Rest type cannot be created from unknown

function f28(x: unknown) {
    let { ...a } = x;  // Error
}

// Class properties of type unknown don't need definite assignment

class C1 {
    a: string;  // Error
    b: unknown;
    c: any;
}
</code></pre>
    
      <h2 id="support-for-defaultprops-in-jsx">
        
        
          Support for <code>defaultProps</code> in JSX <a aria-label="Link to the header: Support for defaultProps in JSX" title="Link to the header: Support for defaultProps in JSX" href="#support-for-defaultprops-in-jsx" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.9 and earlier didn’t leverage <a href="https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values">React <code>defaultProps</code></a> declarations inside JSX components.
Users would often have to declare properties optional and use non-null assertions inside of <code>render</code>, or they’d use type-assertions to fix up the type of the component before exporting it.</p>

<p>TypeScript 3.0 adds supports a new type alias in the <code>JSX</code> namespace called <code>LibraryManagedAttributes</code>.
This helper type defines a transformation on the component’s <code>Props</code> type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</p>

<p>In short using this general type, we can model React’s specific behavior for things like <code>defaultProps</code> and, to some extent, <code>propTypes</code>.</p>

<pre><code class="language-tsx">export interface Props {
    name: string;
}

export class Greet extends React.Component&lt;Props&gt; {
    render() {
        const { name } = this.props;
        return &lt;div&gt;Hello ${name.toUpperCase()}!&lt;/div&gt;;
    }
    static defaultProps = { name: "world"};
}

// Type-checks! No type assertions needed!
let el = &lt;Greet /&gt;
</code></pre>
    
      <h3 id="caveats-5">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-5" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>
    
      <h4 id="explicit-types-on-defaultprops">
        
        
          Explicit types on <code>defaultProps</code> <a aria-label="Link to the header: Explicit types on defaultProps" title="Link to the header: Explicit types on defaultProps" href="#explicit-types-on-defaultprops" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>The default-ed properties are inferred from the <code>defaultProps</code> property type. If an explicit type annotation is added, e.g. <code>static defaultProps: Partial&lt;Props&gt;;</code> the compiler will not be able to identify which properties have defaults (since the type of <code>defaultProps</code> include all properties of <code>Props</code>).</p>

<p>Use <code>static defaultProps: Pick&lt;Props, "name"&gt;;</code> as an explicit type annotation instead, or do not add a type annotation as done in the example above.</p>

<p>For stateless function components (SFCs) use ES2015 default initializers for SFCs:</p>

<pre><code class="language-tsx">function Greet({ name = "world" }: Props) {
    return &lt;div&gt;Hello ${name.toUpperCase()}!&lt;/div&gt;;
}
</code></pre>
    
      <h5 id="changes-to-typesreact">
        
        
          Changes to <code>@types/React</code> <a aria-label="Link to the header: Changes to @types/React" title="Link to the header: Changes to @types/React" href="#changes-to-typesreact" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>Corresponding changes to add <code>LibraryManagedAttributes</code> definition to the <code>JSX</code> namespace in <code>@types/React</code> are still needed.
Keep in mind that there are some limitations.</p>
    
      <h2 id="-reference-lib--reference-directives">
        
        
          <code>/// &lt;reference lib="..." /&gt;</code> reference directives <a aria-label="Link to the header: /// &lt;reference lib="..." /&gt; reference directives" title="Link to the header: /// &lt;reference lib="..." /&gt; reference directives" href="#-reference-lib--reference-directives" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript adds a new triple-slash-reference directive (<code>/// &lt;reference lib="name" /&gt;</code>), allowing a file to explicitly include an existing built-in <em>lib</em> file.</p>

<p>Built-in <em>lib</em> files are referenced in the same fashion as the <code>"lib"</code> compiler option in <em>tsconfig.json</em> (e.g. use <code>lib="es2015"</code> and not <code>lib="lib.es2015.d.ts"</code>, etc.).</p>

<p>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like <code>Symbol</code> or <code>Iterable</code>, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</p>
    
      <h5 id="example-4">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-4" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>Using <code>/// &lt;reference lib="es2017.string" /&gt;</code> to one of the files in a compilation is equivalent to compiling with <code>--lib es2017.string</code>.</p>

<pre><code class="language-ts">/// &lt;reference lib="es2017.string" /&gt;

"foo".padStart(4);
</code></pre>
    
      <h2 id="typescript-29">
        
        
          TypeScript 2.9 <a aria-label="Link to the header: TypeScript 2.9" title="Link to the header: TypeScript 2.9" href="#typescript-29" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="support-number-and-symbol-named-properties-with-keyof-and-mapped-types">
        
        
          Support <code>number</code> and <code>symbol</code> named properties with <code>keyof</code> and mapped types <a aria-label="Link to the header: Support number and symbol named properties with keyof and mapped types" title="Link to the header: Support number and symbol named properties with keyof and mapped types" href="#support-number-and-symbol-named-properties-with-keyof-and-mapped-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.9 adds support for <code>number</code> and <code>symbol</code> named properties in index types and mapped types.
Previously, the <code>keyof</code> operator and mapped types only supported <code>string</code> named properties.</p>

<p>Changes include:</p>

<ul>
  <li>An index type <code>keyof T</code> for some type <code>T</code> is a subtype of <code>string | number | symbol</code>.</li>
  <li>A mapped type <code>{ [P in K]: XXX }</code> permits any <code>K</code> assignable to <code>string | number | symbol</code>.</li>
  <li>In a <code>for...in</code> statement for an object of a generic type <code>T</code>, the inferred type of the iteration variable was previously <code>keyof T</code> but is now <code>Extract&lt;keyof T, string&gt;</code>. (In other words, the subset of <code>keyof T</code> that includes only string-like values.)</li>
</ul>

<p>Given an object type <code>X</code>, <code>keyof X</code> is resolved as follows:</p>

<ul>
  <li>If <code>X</code> contains a string index signature, <code>keyof X</code> is a union of <code>string</code>, <code>number</code>, and the literal types representing symbol-like properties, otherwise</li>
  <li>If <code>X</code> contains a numeric index signature, <code>keyof X</code> is a union of <code>number</code> and the literal types representing string-like and symbol-like properties, otherwise</li>
  <li><code>keyof X</code> is a union of the literal types representing string-like, number-like, and symbol-like properties.</li>
</ul>

<p>Where:</p>

<ul>
  <li>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</li>
  <li>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</li>
  <li>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</li>
</ul>

<p>In a mapped type <code>{ [P in K]: XXX }</code>, each string literal type in <code>K</code> introduces a property with a string name, each numeric literal type in <code>K</code> introduces a property with a numeric name, and each unique symbol type in <code>K</code> introduces a property with a unique symbol name.
Furthermore, if <code>K</code> includes type <code>string</code>, a string index signature is introduced, and if <code>K</code> includes type <code>number</code>, a numeric index signature is introduced.</p>
    
      <h4 id="example-5">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-5" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">const c = "c";
const d = 10;
const e = Symbol();

const enum E1 { A, B, C }
const enum E2 { A = "A", B = "B", C = "C" }

type Foo = {
    a: string;       // String-like name
    5: string;       // Number-like name
    [c]: string;     // String-like name
    [d]: string;     // Number-like name
    [e]: string;     // Symbol-like name
    [E1.A]: string;  // Number-like name
    [E2.A]: string;  // String-like name
}

type K1 = keyof Foo;  // "a" | 5 | "c" | 10 | typeof e | E1.A | E2.A
type K2 = Extract&lt;keyof Foo, string&gt;;  // "a" | "c" | E2.A
type K3 = Extract&lt;keyof Foo, number&gt;;  // 5 | 10 | E1.A
type K4 = Extract&lt;keyof Foo, symbol&gt;;  // typeof e
</code></pre>

<p>Since <code>keyof</code> now reflects the presence of a numeric index signature by including type <code>number</code> in the key type, mapped types such as <code>Partial&lt;T&gt;</code> and <code>Readonly&lt;T&gt;</code> work correctly when applied to object types with numeric index signatures:</p>

<pre><code class="language-ts">type Arrayish&lt;T&gt; = {
    length: number;
    [x: number]: T;
}

type ReadonlyArrayish&lt;T&gt; = Readonly&lt;Arrayish&lt;T&gt;&gt;;

declare const map: ReadonlyArrayish&lt;string&gt;;
let n = map.length;
let x = map[123];  // Previously of type any (or an error with --noImplicitAny)
</code></pre>

<p>Furthermore, with the <code>keyof</code> operator’s support for <code>number</code> and <code>symbol</code> named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</p>

<pre><code class="language-ts">const enum Enum { A, B, C }

const enumToStringMap = {
    [Enum.A]: "Name A",
    [Enum.B]: "Name B",
    [Enum.C]: "Name C"
}

const sym1 = Symbol();
const sym2 = Symbol();
const sym3 = Symbol();

const symbolToNumberMap = {
    [sym1]: 1,
    [sym2]: 2,
    [sym3]: 3
};

type KE = keyof typeof enumToStringMap;   // Enum (i.e. Enum.A | Enum.B | Enum.C)
type KS = keyof typeof symbolToNumberMap; // typeof sym1 | typeof sym2 | typeof sym3

function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

let x1 = getValue(enumToStringMap, Enum.C);  // Returns "Name C"
let x2 = getValue(symbolToNumberMap, sym3);  // Returns 3
</code></pre>

<p>This is a breaking change; previously, the <code>keyof</code> operator and mapped types only supported <code>string</code> named properties.
Code that assumed values typed with <code>keyof T</code> were always <code>string</code>s, will now be flagged as error.</p>
    
      <h4 id="example-6">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-6" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
    var name: string = k;  // Error: keyof T is not assignable to string
}
</code></pre>
    
      <h4 id="recommendations">
        
        
          Recommendations <a aria-label="Link to the header: Recommendations" title="Link to the header: Recommendations" href="#recommendations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>
<ul>
  <li>
    <p>If your functions are only able to handle string named property keys, use <code>Extract&lt;keyof T, string&gt;</code> in the declaration:</p>

    <pre><code class="language-ts">function useKey&lt;T, K extends Extract&lt;keyof T, string&gt;&gt;(o: T, k: K) {
  var name: string = k;  // OK
}
</code></pre>
  </li>
  <li>
    <p>If your functions are open to handling all property keys, then the changes should be done down-stream:</p>

    <pre><code class="language-ts">function useKey&lt;T, K extends keyof T&gt;(o: T, k: K) {
  var name: string | number | symbol = k;
}
</code></pre>
  </li>
  <li>
    <p>Otherwise use <code>--keyofStringsOnly</code> compiler option to disable the new behavior.</p>
  </li>
</ul>
    
      <h2 id="generic-type-arguments-in-jsx-elements">
        
        
          Generic type arguments in JSX elements <a aria-label="Link to the header: Generic type arguments in JSX elements" title="Link to the header: Generic type arguments in JSX elements" href="#generic-type-arguments-in-jsx-elements" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>JSX elements now allow passing type arguments to generic components.</p>
    
      <h4 id="example-7">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-7" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">class GenericComponent&lt;P&gt; extends React.Component&lt;P&gt; {
    internalProp: P;
}

type Props = { a: number; b: string; };

const x = &lt;GenericComponent&lt;Props&gt; a={10} b="hi"/&gt;; // OK

const y = &lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;; // Error
</code></pre>
    
      <h2 id="generic-type-arguments-in-generic-tagged-templates">
        
        
          Generic type arguments in generic tagged templates <a aria-label="Link to the header: Generic type arguments in generic tagged templates" title="Link to the header: Generic type arguments in generic tagged templates" href="#generic-type-arguments-in-generic-tagged-templates" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Tagged templates are a form of invocation introduced in ECMAScript 2015.
Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</p>

<p>TypeScript 2.9  allows passing generic type arguments to tagged template strings.</p>
    
      <h4 id="example-8">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-8" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">declare function styledComponent&lt;Props&gt;(strs: TemplateStringsArray): Component&lt;Props&gt;;

interface MyProps {
  name: string;
  age: number;
}

styledComponent&lt;MyProps&gt; `
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;

declare function tag&lt;T&gt;(strs: TemplateStringsArray, ...args: T[]): T;

// inference fails because 'number' and 'string' are both candidates that conflict
let a = tag&lt;string | number&gt; `${100} ${"hello"}`;
</code></pre>
    
      <h2 id="import-types">
        
        
          <code>import</code> types <a aria-label="Link to the header: import types" title="Link to the header: import types" href="#import-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter <code>import</code> types.</p>

<p>Using <code>import("mod")</code> in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</p>
    
      <h4 id="example-9">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-9" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Given a declaration of a class <code>Pet</code> in a module file:</p>

<pre><code class="language-ts">// module.d.ts

export declare class Pet {
   name: string;
}
</code></pre>

<p>Can be used in a non-module file <code>global-script.ts</code>:</p>

<pre><code class="language-ts">// global-script.ts

function adopt(p: import("./module").Pet) {
    console.log(`Adopting ${p.name}...`);
}
</code></pre>

<p>This also works in JSDoc comments to refer to types from other modules in <code>.js</code>:</p>

<pre><code class="language-js">// a.js

/**
 * @param p { import("./module").Pet }
 */
function walk(p) {
    console.log(`Walking ${p.name}...`);
}
</code></pre>
    
      <h2 id="relaxing-declaration-emit-visiblity-rules">
        
        
          Relaxing declaration emit visiblity rules <a aria-label="Link to the header: Relaxing declaration emit visiblity rules" title="Link to the header: Relaxing declaration emit visiblity rules" href="#relaxing-declaration-emit-visiblity-rules" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With <code>import</code> types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</p>

<p>For instance:</p>

<pre><code class="language-ts">import { createHash } from "crypto";

export const hash = createHash("sha256");
//           ^^^^
// Exported variable 'hash' has or is using name 'Hash' from external module "crypto" but cannot be named.
</code></pre>

<p>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</p>

<pre><code class="language-ts">export declare const hash: import("crypto").Hash;
</code></pre>
    
      <h2 id="support-for-importmeta">
        
        
          Support for <code>import.meta</code> <a aria-label="Link to the header: Support for import.meta" title="Link to the header: Support for import.meta" href="#support-for-importmeta" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.9 introduces support for <code>import.meta</code>, a new meta-property as described by the current <a href="https://github.com/tc39/proposal-import-meta">TC39 proposal</a>.</p>

<p>The type of <code>import.meta</code> is the global <code>ImportMeta</code> type which is defined in <code>lib.es5.d.ts</code>.
This interface is extremely limited.
Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</p>
    
      <h4 id="example-10">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-10" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Assuming that <code>__dirname</code> is always available on <code>import.meta</code>, the declaration would be done through reopening <code>ImportMeta</code> interface:</p>

<pre><code class="language-ts">// node.d.ts
interface ImportMeta {
    __dirname: string;
}
</code></pre>

<p>And usage would be:</p>

<pre><code class="language-ts">import.meta.__dirname // Has type 'string'
</code></pre>

<p><code>import.meta</code> is only allowed when targeting <code>ESNext</code> modules and ECMAScript targets.</p>
    
      <h2 id="new---resolvejsonmodule">
        
        
          New <code>--resolveJsonModule</code> <a aria-label="Link to the header: New --resolveJsonModule" title="Link to the header: New --resolveJsonModule" href="#new---resolvejsonmodule" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Often in Node.js applications a <code>.json</code> is needed. With TypeScript 2.9, <code>--resolveJsonModule</code> allows for importing, extracting types from and generating <code>.json</code> files.</p>
    
      <h4 id="example-11">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-11" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// settings.json

{
    "repo": "TypeScript",
    "dry": false,
    "debug": false
}
</code></pre>

<pre><code class="language-ts">// a.ts

import settings from "./settings.json";

settings.debug === true;  // OK
settings.dry === 2;  // Error: Operator '===' cannot be applied boolean and number

</code></pre>

<pre><code class="language-ts">// tsconfig.json

{
    "compilerOptions": {
        "module": "commonjs",
        "resolveJsonModule": true,
        "esModuleInterop": true
    }
}
</code></pre>
    
      <h2 id="--pretty-output-by-default">
        
        
          <code>--pretty</code> output by default <a aria-label="Link to the header: --pretty output by default" title="Link to the header: --pretty output by default" href="#--pretty-output-by-default" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Starting TypeScript 2.9 errors are displayed under <code>--pretty</code> by default if the output device is applicable for colorful text.
TypeScript will check if the output steam has <a href="https://nodejs.org/api/tty.html"><code>isTty</code></a> property set.</p>

<p>Use <code>--pretty false</code> on the command line or set <code>"pretty": false</code> in your <code>tsconfig.json</code> to disable <code>--pretty</code> output.</p>
    
      <h2 id="new---declarationmap">
        
        
          New <code>--declarationMap</code> <a aria-label="Link to the header: New --declarationMap" title="Link to the header: New --declarationMap" href="#new---declarationmap" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Enabling <code>--declarationMap</code> alongside <code>--declaration</code> causes the compiler to emit <code>.d.ts.map</code> files alongside the output <code>.d.ts</code> files.
Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</p>

<p>In other words, hitting go-to-definition on a declaration from a <code>.d.ts</code> file generated with <code>--declarationMap</code> will take you to the source file (<code>.ts</code>) location where that declaration was defined, and not to the <code>.d.ts</code>.</p>
    
      <h2 id="typescript-28">
        
        
          TypeScript 2.8 <a aria-label="Link to the header: TypeScript 2.8" title="Link to the header: TypeScript 2.8" href="#typescript-28" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="conditional-types">
        
        
          Conditional Types <a aria-label="Link to the header: Conditional Types" title="Link to the header: Conditional Types" href="#conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.8 introduces <em>conditional types</em> which add the ability to express non-uniform type mappings.
A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p>

<pre><code class="language-ts">T extends U ? X : Y
</code></pre>

<p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p>

<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables.
Whether to resolve or defer is determined as follows:</p>

<ul>
  <li>First, given types <code>T'</code> and <code>U'</code> that are instantiations of <code>T</code> and <code>U</code> where all occurrences of type parameters are replaced with <code>any</code>, if <code>T'</code> is not assignable to <code>U'</code>, the conditional type is resolved to <code>Y</code>. Intuitively, if the most permissive instantiation of <code>T</code> is not assignable to the most permissive instantiation of <code>U</code>, we know that no instantiation will be and we can just resolve to <code>Y</code>.</li>
  <li>Next, for each type variable introduced by an <code>infer</code> (more later) declaration within <code>U</code> collect a set of candidate types by inferring from <code>T</code> to <code>U</code> (using the same inference algorithm as type inference for generic functions). For a given <code>infer</code> type variable <code>V</code>, if any candidates were inferred from co-variant positions, the type inferred for <code>V</code> is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for <code>V</code> is an intersection of those candidates. Otherwise, the type inferred for <code>V</code> is <code>never</code>.</li>
  <li>Then, given a type <code>T''</code> that is an instantiation of <code>T</code> where all <code>infer</code> type variables are replaced with the types inferred in the previous step, if <code>T''</code> is <em>definitely assignable</em> to <code>U</code>, the conditional type is resolved to <code>X</code>. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for <em>all instantiations</em> of those types.</li>
  <li>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</li>
</ul>
    
      <h4 id="example-12">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-12" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type TypeName&lt;T&gt; =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName&lt;string&gt;;  // "string"
type T1 = TypeName&lt;"a"&gt;;  // "string"
type T2 = TypeName&lt;true&gt;;  // "boolean"
type T3 = TypeName&lt;() =&gt; void&gt;;  // "function"
type T4 = TypeName&lt;string[]&gt;;  // "object"
</code></pre>
    
      <h3 id="distributive-conditional-types">
        
        
          Distributive conditional types <a aria-label="Link to the header: Distributive conditional types" title="Link to the header: Distributive conditional types" href="#distributive-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>.
Distributive conditional types are automatically distributed over union types during instantiation.
For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p>
    
      <h4 id="example-13">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-13" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type T10 = TypeName&lt;string | (() =&gt; void)&gt;;  // "string" | "function"
type T12 = TypeName&lt;string | string[] | undefined&gt;;  // "string" | "object" | "undefined"
type T11 = TypeName&lt;string[] | number[]&gt;;  // "object"
</code></pre>

<p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type).
Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p>
    
      <h4 id="example-14">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-14" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;

type T20 = Boxed&lt;string&gt;;  // BoxedValue&lt;string&gt;;
type T21 = Boxed&lt;number[]&gt;;  // BoxedArray&lt;number&gt;;
type T22 = Boxed&lt;string | number[]&gt;;  // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;
</code></pre>

<p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&lt;T&gt;</code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p>

<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p>

<pre><code class="language-ts">type Diff&lt;T, U&gt; = T extends U ? never : T;  // Remove types from T that are assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;  // Remove types from T that are not assignable to U

type T30 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T31 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"
type T32 = Diff&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T33 = Filter&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;  // Remove null and undefined from T

type T34 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T35 = NonNullable&lt;string | string[] | null | undefined&gt;;  // string | string[]

function f1&lt;T&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
}

function f2&lt;T extends string | undefined&gt;(x: T, y: NonNullable&lt;T&gt;) {
    x = y;  // Ok
    y = x;  // Error
    let s1: string = x;  // Error
    let s2: string = y;  // Ok
}
</code></pre>

<p>Conditional types are particularly useful when combined with mapped types:</p>

<pre><code class="language-ts">type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;

type NonFunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;

interface Part {
    id: number;
    name: string;
    subparts: Part[];
    updatePart(newName: string): void;
}

type T40 = FunctionPropertyNames&lt;Part&gt;;  // "updatePart"
type T41 = NonFunctionPropertyNames&lt;Part&gt;;  // "id" | "name" | "subparts"
type T42 = FunctionProperties&lt;Part&gt;;  // { updatePart(newName: string): void }
type T43 = NonFunctionProperties&lt;Part&gt;;  // { id: number, name: string, subparts: Part[] }
</code></pre>

<p>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</p>
    
      <h4 id="example-15">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-15" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T;  // Error
</code></pre>
    
      <h3 id="type-inference-in-conditional-types">
        
        
          Type inference in conditional types <a aria-label="Link to the header: Type inference in conditional types" title="Link to the header: Type inference in conditional types" href="#type-inference-in-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred.
Such inferred type variables may be referenced in the true branch of the conditional type.
It is possible to have multiple <code>infer</code> locations for the same type variable.</p>

<p>For example, the following extracts the return type of a function type:</p>

<pre><code class="language-ts">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>

<p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p>

<pre><code class="language-ts">type Unpacked&lt;T&gt; =
    T extends (infer U)[] ? U :
    T extends (...args: any[]) =&gt; infer U ? U :
    T extends Promise&lt;infer U&gt; ? U :
    T;

type T0 = Unpacked&lt;string&gt;;  // string
type T1 = Unpacked&lt;string[]&gt;;  // string
type T2 = Unpacked&lt;() =&gt; string&gt;;  // string
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;  // string
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;  // Promise&lt;string&gt;
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;  // string
</code></pre>

<p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p>

<pre><code class="language-ts">type Foo&lt;T&gt; = T extends { a: infer U, b: infer U } ? U : never;
type T10 = Foo&lt;{ a: string, b: string }&gt;;  // string
type T11 = Foo&lt;{ a: string, b: number }&gt;;  // string | number
</code></pre>

<p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p>

<pre><code class="language-ts">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void, b: (x: infer U) =&gt; void } ? U : never;
type T20 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: string) =&gt; void }&gt;;  // string
type T21 = Bar&lt;{ a: (x: string) =&gt; void, b: (x: number) =&gt; void }&gt;;  // string &amp; number
</code></pre>

<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case).
It is not possible to perform overload resolution based on a list of argument types.</p>

<pre><code class="language-ts">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;
type T30 = ReturnType&lt;typeof foo&gt;;  // string | number
</code></pre>

<p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p>

<pre><code class="language-ts">type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;  // Error, not supported
</code></pre>

<p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p>

<pre><code class="language-ts">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;
</code></pre>
    
      <h3 id="predefined-conditional-types">
        
        
          Predefined conditional types <a aria-label="Link to the header: Predefined conditional types" title="Link to the header: Predefined conditional types" href="#predefined-conditional-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript 2.8 adds several predefined conditional types to <code>lib.d.ts</code>:</p>

<ul>
  <li><code>Exclude&lt;T, U&gt;</code> – Exclude from <code>T</code> those types that are assignable to <code>U</code>.</li>
  <li><code>Extract&lt;T, U&gt;</code> – Extract from <code>T</code> those types that are assignable to <code>U</code>.</li>
  <li><code>NonNullable&lt;T&gt;</code> – Exclude <code>null</code> and <code>undefined</code> from <code>T</code>.</li>
  <li><code>ReturnType&lt;T&gt;</code> – Obtain the return type of a function type.</li>
  <li><code>InstanceType&lt;T&gt;</code> – Obtain the instance type of a constructor function type.</li>
</ul>
    
      <h4 id="example-16">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-16" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type T00 = Exclude&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "b" | "d"
type T01 = Extract&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;  // "a" | "c"

type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type T04 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;  // (() =&gt; string) | string[]

function f1(s: string) {
    return { a: 1, b: s };
}

class C {
    x = 0;
    y = 0;
}

type T10 = ReturnType&lt;() =&gt; string&gt;;  // string
type T11 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T14 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T15 = ReturnType&lt;any&gt;;  // any
type T16 = ReturnType&lt;never&gt;;  // any
type T17 = ReturnType&lt;string&gt;;  // Error
type T18 = ReturnType&lt;Function&gt;;  // Error

type T20 = InstanceType&lt;typeof C&gt;;  // C
type T21 = InstanceType&lt;any&gt;;  // any
type T22 = InstanceType&lt;never&gt;;  // any
type T23 = InstanceType&lt;string&gt;;  // Error
type T24 = InstanceType&lt;Function&gt;;  // Error
</code></pre>

<blockquote>
  <p>Note: The <code>Exclude</code> type is a proper implementation of the <code>Diff</code> type suggested <a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458">here</a>. We’ve used the name <code>Exclude</code> to avoid breaking existing code that defines a <code>Diff</code>, plus we feel that name better conveys the semantics of the type. We did not include the <code>Omit&lt;T, K&gt;</code> type because it is trivially written as <code>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code>.</p>
</blockquote>
    
      <h2 id="improved-control-over-mapped-type-modifiers">
        
        
          Improved control over mapped type modifiers <a aria-label="Link to the header: Improved control over mapped type modifiers" title="Link to the header: Improved control over mapped type modifiers" href="#improved-control-over-mapped-type-modifiers" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Mapped types support adding a <code>readonly</code> or <code>?</code> modifier to a mapped property, but they did not provide support the ability to <em>remove</em> modifiers.
This matters in <a href="https://github.com/Microsoft/TypeScript/pull/12563"><em>homomorphic mapped types</em></a> which by default preserve the modifiers of the underlying type.</p>

<p>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier.
Specifically, a <code>readonly</code> or <code>?</code> property modifier in a mapped type can now be prefixed with either <code>+</code> or <code>-</code> to indicate that the modifier should be added or removed.</p>
    
      <h4 id="example-17">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-17" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type MutableRequired&lt;T&gt; = { -readonly [P in keyof T]-?: T[P] };  // Remove readonly and ?
type ReadonlyPartial&lt;T&gt; = { +readonly [P in keyof T]+?: T[P] };  // Add readonly and ?
</code></pre>

<p>A modifier with no <code>+</code> or <code>-</code> prefix is the same as a modifier with a <code>+</code> prefix. So, the <code>ReadonlyPartial&lt;T&gt;</code> type above corresponds to</p>

<pre><code class="language-ts">type ReadonlyPartial&lt;T&gt; = { readonly [P in keyof T]?: T[P] };  // Add readonly and ?
</code></pre>

<p>Using this ability, <code>lib.d.ts</code> now has a new  <code>Required&lt;T&gt;</code> type.
This type strips <code>?</code> modifiers from all properties of <code>T</code>, thus making all properties required.</p>
    
      <h4 id="example-18">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-18" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type Required&lt;T&gt; = { [P in keyof T]-?: T[P] };
</code></pre>

<p>Note that in <code>--strictNullChecks</code> mode, when a homomorphic mapped type removes a <code>?</code> modifier from a property in the underlying type it also removes <code>undefined</code> from the type of that property:</p>
    
      <h4 id="example-19">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-19" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type Foo = { a?: string };  // Same as { a?: string | undefined }
type Bar = Required&lt;Foo&gt;;  // Same as { a: string }
</code></pre>
    
      <h2 id="improved-keyof-with-intersection-types">
        
        
          Improved <code>keyof</code> with intersection types <a aria-label="Link to the header: Improved keyof with intersection types" title="Link to the header: Improved keyof with intersection types" href="#improved-keyof-with-intersection-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With TypeScript 2.8 <code>keyof</code> applied to an intersection type is transformed to a union of <code>keyof</code> applied to each intersection constituent.
In other words, types of the form <code>keyof (A &amp; B)</code> are transformed to be <code>keyof A | keyof B</code>.
This change should address inconsistencies with inference from <code>keyof</code> expressions.</p>
    
      <h4 id="example-20">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-20" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">type A = { a: string };
type B = { b: string };

type T1 = keyof (A &amp; B);  // "a" | "b"
type T2&lt;T&gt; = keyof (T &amp; B);  // keyof T | "b"
type T3&lt;U&gt; = keyof (A &amp; U);  // "a" | keyof U
type T4&lt;T, U&gt; = keyof (T &amp; U);  // keyof T | keyof U
type T5 = T2&lt;A&gt;;  // "a" | "b"
type T6 = T3&lt;B&gt;;  // "a" | "b"
type T7 = T4&lt;A, B&gt;;  // "a" | "b"
</code></pre>
    
      <h2 id="better-handling-for-namespace-patterns-in-js-files">
        
        
          Better handling for namespace patterns in <code>.js</code> files <a aria-label="Link to the header: Better handling for namespace patterns in .js files" title="Link to the header: Better handling for namespace patterns in .js files" href="#better-handling-for-namespace-patterns-in-js-files" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.8 adds support for understanding more namespace patterns in <code>.js</code> files.
Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</p>

<pre><code class="language-js">var ns = {};     // recognized as a declaration for a namespace `ns`
ns.constant = 1; // recognized as a declaration for var `constant`
</code></pre>

<p>Assignments at the top-level should behave the same way; in other words, a <code>var</code> or <code>const</code> declaration is not required.</p>

<pre><code class="language-js">app = {}; // does NOT need to be `var app = {}`
app.C = class {
};
app.f = function() {
};
app.prop = 1;
</code></pre>
    
      <h3 id="iifes-as-namespace-declarations">
        
        
          IIFEs as namespace declarations <a aria-label="Link to the header: IIFEs as namespace declarations" title="Link to the header: IIFEs as namespace declarations" href="#iifes-as-namespace-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</p>

<pre><code class="language-js">var C = (function () {
  function C(n) {
    this.p = n;
  }
  return C;
})();
C.staticProperty = 1;
</code></pre>
    
      <h3 id="defaulted-declarations">
        
        
          Defaulted declarations <a aria-label="Link to the header: Defaulted declarations" title="Link to the header: Defaulted declarations" href="#defaulted-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>“Defaulted declarations” allow initializers that reference the declared name in the left side of a logical or:</p>

<pre><code class="language-js">my = window.my || {};
my.app = my.app || {};
</code></pre>
    
      <h3 id="prototype-assignment">
        
        
          Prototype assignment <a aria-label="Link to the header: Prototype assignment" title="Link to the header: Prototype assignment" href="#prototype-assignment" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</p>

<pre><code class="language-ts">var C = function (p) {
  this.p = p;
};
C.prototype = {
  m() {
    console.log(this.p);
  }
};
C.prototype.q = function(r) {
  return this.p === r;
};
</code></pre>
    
      <h3 id="nested-and-merged-declarations">
        
        
          Nested and merged declarations <a aria-label="Link to the header: Nested and merged declarations" title="Link to the header: Nested and merged declarations" href="#nested-and-merged-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</p>

<pre><code class="language-js">var app = window.app || {};
app.C = class { };
</code></pre>
    
      <h2 id="per-file-jsx-factories">
        
        
          Per-file JSX factories <a aria-label="Link to the header: Per-file JSX factories" title="Link to the header: Per-file JSX factories" href="#per-file-jsx-factories" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.8 adds support for a per-file configurable JSX factory name using <code>@jsx dom</code> paragma.
JSX factory can be configured for a compilation using <code>--jsxFactory</code> (default is <code>React.createElement</code>). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</p>
    
      <h4 id="example-21">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-21" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">/** @jsx dom */
import { dom } from "./renderer"
&lt;h&gt;&lt;/h&gt;
</code></pre>

<p>Generates:</p>

<pre><code class="language-js">var renderer_1 = require("./renderer");
renderer_1.dom("h", null);
</code></pre>
    
      <h2 id="locally-scoped-jsx-namespaces">
        
        
          Locally scoped JSX namespaces <a aria-label="Link to the header: Locally scoped JSX namespaces" title="Link to the header: Locally scoped JSX namespaces" href="#locally-scoped-jsx-namespaces" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>JSX type checking is driven by definitions in a JSX namespace, for instance <code>JSX.Element</code> for the type of a JSX element, and <code>JSX.IntrinsicElements</code> for built-in elements.
Before TypeScript 2.8 the <code>JSX</code> namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project.
Starting with TypeScript 2.8 the <code>JSX</code> namespace will be looked under the <code>jsxNamespace</code> (e.g. <code>React</code>) allowing for multiple jsx factories in one compilation.
For backward compatibility the global <code>JSX</code> namespace is used as a fallback if none was defined on the factory function.
Combined with the per-file <code>@jsx</code> pragma, each file can have a different JSX factory.</p>
    
      <h2 id="new---emitdeclarationsonly">
        
        
          New <code>--emitDeclarationsOnly</code> <a aria-label="Link to the header: New --emitDeclarationsOnly" title="Link to the header: New --emitDeclarationsOnly" href="#new---emitdeclarationsonly" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>--emitDeclarationsOnly</code> allows for <em>only</em> generating declaration files; <code>.js</code>/<code>.jsx</code> output generation will be skipped with this flag. The flag is useful when the <code>.js</code> output generation is handled by a different transpiler like Babel.</p>
    
      <h2 id="typescript-27">
        
        
          TypeScript 2.7 <a aria-label="Link to the header: TypeScript 2.7" title="Link to the header: TypeScript 2.7" href="#typescript-27" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="constant-named-properties">
        
        
          Constant-named properties <a aria-label="Link to the header: Constant-named properties" title="Link to the header: Constant-named properties" href="#constant-named-properties" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</p>
    
      <h4 id="example-22">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-22" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// Lib
export const SERIALIZE = Symbol("serialize-method-key");

export interface Serializable {
    [SERIALIZE](obj: {}): string;
}
</code></pre>

<pre><code class="language-ts">// consumer

import { SERIALIZE, Serializable } from "lib";

class JSONSerializableItem implements Serializable {
    [SERIALIZE](obj: {}) {
        return JSON.stringify(obj);
    }
}
</code></pre>

<p>This also applies to numeric and string literals.</p>
    
      <h4 id="example-23">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-23" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">const Foo = "Foo";
const Bar = "Bar";

let x = {
    [Foo]: 100,
    [Bar]: "hello",
};

let a = x[Foo]; // has type 'number'
let b = x[Bar]; // has type 'string'
</code></pre>
    
      <h3 id="unique-symbol">
        
        
          <code>unique symbol</code> <a aria-label="Link to the header: unique symbol" title="Link to the header: unique symbol" href="#unique-symbol" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>To enable treating symbols as unique literals  a new type <code>unique symbol</code> is available.
<code>unique symbol</code> is are subtype of <code>symbol</code>, and are produced only from calling <code>Symbol()</code> or <code>Symbol.for()</code>, or from explicit type annotations.
The new type is only allowed on <code>const</code> declarations and <code>readonly static</code> properties, and in order to reference a specific unique symbol, you’ll have to use the <code>typeof</code> operator.
Each reference to a <code>unique symbol</code> implies a completely unique identity that’s tied to a given declaration.</p>
    
      <h4 id="example-24">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-24" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// Works
declare const Foo: unique symbol;

// Error! 'Bar' isn't a constant.
let Bar: unique symbol = Symbol();

// Works - refers to a unique symbol, but its identity is tied to 'Foo'.
let Baz: typeof Foo = Foo;

// Also works.
class C {
    static readonly StaticSymbol: unique symbol = Symbol();
}
</code></pre>

<p>Because each <code>unique symbol</code> has a completely separate identity, no two <code>unique symbol</code> types are assignable or comparable to each other.</p>
    
      <h4 id="example-25">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-25" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">const Foo = Symbol();
const Bar = Symbol();

// Error: can't compare two unique symbols.
if (Foo === Bar) {
    // ...
}
</code></pre>
    
      <h2 id="strict-class-initialization">
        
        
          Strict Class Initialization <a aria-label="Link to the header: Strict Class Initialization" title="Link to the header: Strict Class Initialization" href="#strict-class-initialization" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 introduces a new flag called <code>--strictPropertyInitialization</code>.
This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer.
For example</p>

<pre><code class="language-ts">class C {
    foo: number;
    bar = "hello";
    baz: boolean;
//  ~~~
//  Error! Property 'baz' has no initializer and is not definitely assigned in the
//         constructor.

    constructor() {
        this.foo = 42;
    }
}
</code></pre>

<p>In the above, if we truly meant for <code>baz</code> to potentially be <code>undefined</code>, we should have declared it with the type <code>boolean | undefined</code>.</p>

<p>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new <em>definite assignment assertion modifiers</em> for your properties (discussed below).</p>

<pre><code class="language-ts">class C {
    foo!: number;
    // ^
    // Notice this '!' modifier.
    // This is the "definite assignment assertion"

    constructor() {
        this.initialize();
    }

    initialize() {
        this.foo = 0;
    }
}
</code></pre>

<p>Keep in mind that <code>--strictPropertyInitialization</code> will be turned on along with other <code>--strict</code> mode flags, which can impact your project.
You can set the <code>strictPropertyInitialization</code> setting to <code>false</code> in your <code>tsconfig.json</code>’s <code>compilerOptions</code>, or <code>--strictPropertyInitialization false</code> on the command line to turn off this checking.</p>
    
      <h2 id="definite-assignment-assertions">
        
        
          Definite Assignment Assertions <a aria-label="Link to the header: Definite Assignment Assertions" title="Link to the header: Definite Assignment Assertions" href="#definite-assignment-assertions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The definite assignment assertion is a feature that allows a <code>!</code> to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript’s analyses cannot detect so.</p>

<p>For example:</p>

<pre><code class="language-ts">let x: number;
initialize();
console.log(x + x);
//          ~   ~
// Error! Variable 'x' is used before being assigned.

function initialize() {
    x = 10;
}
</code></pre>

<p>With definite assignment assertions, we can assert that <code>x</code> is really assigned by appending an <code>!</code> to its declaration:</p>

<pre><code class="language-ts">// Notice the '!'
let x!: number;
initialize();

// No error!
console.log(x + x);

function initialize() {
    x = 10;
}
</code></pre>

<p>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which <em>expressions</em> are post-fixed with a <code>!</code>), which we could also have used in the example.</p>

<pre><code class="language-ts">let x: number;
initialize();

// No error!
console.log(x! + x!);

function initialize() {
    x = 10;

</code></pre>

<p>In our example, we knew that all uses of <code>x</code> would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</p>
    
      <h2 id="fixed-length-tuples">
        
        
          Fixed Length Tuples <a aria-label="Link to the header: Fixed Length Tuples" title="Link to the header: Fixed Length Tuples" href="#fixed-length-tuples" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 2.6 and earlier, <code>[number, string, string]</code> was considered a subtype of <code>[number, string]</code>.
This was motivated by TypeScript’s structural nature; the first and second elements of a <code>[number, string, string]</code> are respectively subtypes of the first and second elements of <code>[number, string]</code>.
However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</p>

<p>In TypeScript 2.7, tuples of different arities are no longer assignable to each other.
Thanks to a pull request from <a href="https://github.com/tycho01">Tycho Grouwstra</a>, tuple types now encode their arity into the type of their respective <code>length</code> property.
This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</p>

<p>Conceptually, you might consider the type <code>[number, string]</code> to be equivalent to the following declaration of <code>NumStrTuple</code>:</p>

<pre><code class="language-ts">interface NumStrTuple extends Array&lt;number | string&gt; {
    0: number;
    1: string;
    length: 2; // using the numeric literal type '2'
}
</code></pre>

<p>Note that this is a breaking change for some code.
If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a <code>length</code> property, falling back to <code>number</code>.</p>

<pre><code class="language-ts">interface MinimumNumStrTuple extends Array&lt;number | string&gt; {
    0: number;
    1: string;
}
</code></pre>

<p>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</p>
    
      <h2 id="improved-type-inference-for-object-literals">
        
        
          Improved type inference for object literals <a aria-label="Link to the header: Improved type inference for object literals" title="Link to the header: Improved type inference for object literals" href="#improved-type-inference-for-object-literals" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context.
When multiple object literal types contribute to a union type, we now <em>normalize</em> the object literal types such that all properties are present in each constituent of the union type.</p>

<p>Consider:</p>

<pre><code class="language-ts">const obj = test ? { text: "hello" } : {};  // { text: string } | { text?: undefined }
const s = obj.text;  // string | undefined
</code></pre>

<p>Previously type <code>{}</code> was inferred for <code>obj</code> and the second line subsequently caused an error because <code>obj</code> would appear to have no properties.
That obviously wasn’t ideal.</p>
    
      <h4 id="example-26">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-26" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// let obj: { a: number, b: number } |
//     { a: string, b?: undefined } |
//     { a?: undefined, b?: undefined }
let obj = [{ a: 1, b: 2 }, { a: "abc" }, {}][0];
obj.a;  // string | number | undefined
obj.b;  // number | undefined
</code></pre>

<p>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</p>

<pre><code class="language-ts">declare function f&lt;T&gt;(...items: T[]): T;
// let obj: { a: number, b: number } |
//     { a: string, b?: undefined } |
//     { a?: undefined, b?: undefined }
let obj = f({ a: 1, b: 2 }, { a: "abc" }, {});
obj.a;  // string | number | undefined
obj.b;  // number | undefined
</code></pre>
    
      <h2 id="improved-handling-of-structurally-identical-classes-and-instanceof-expressions">
        
        
          Improved handling of structurally identical classes and <code>instanceof</code> expressions <a aria-label="Link to the header: Improved handling of structurally identical classes and instanceof expressions" title="Link to the header: Improved handling of structurally identical classes and instanceof expressions" href="#improved-handling-of-structurally-identical-classes-and-instanceof-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 improves the handling of structurally identical classes in union types and <code>instanceof</code> expressions:</p>

<ul>
  <li>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</li>
  <li>Union type subtype reduction only removes a class type if it is a subclass of <em>and</em> derives from another class type in the union.</li>
  <li>Type checking of the <code>instanceof</code> operator is now based on whether the type of the left operand <em>derives from</em> the type indicated by the right operand (as opposed to a structural subtype check).</li>
</ul>

<p>This means that union types and <code>instanceof</code> properly distinguish between structurally identical classes.</p>
    
      <h4 id="example-27">
        
        
          Example: <a aria-label="Link to the header: Example:" title="Link to the header: Example:" href="#example-27" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">class A {}
class B extends A {}
class C extends A {}
class D extends A { c: string }
class E extends D {}

let x1 = !true ? new A() : new B();  // A
let x2 = !true ? new B() : new C();  // B | C (previously B)
let x3 = !true ? new C() : new D();  // C | D (previously C)

let a1 = [new A(), new B(), new C(), new D(), new E()];  // A[]
let a2 = [new B(), new C(), new D(), new E()];  // (B | C | D)[] (previously B[])

function f1(x: B | C | D) {
    if (x instanceof B) {
        x;  // B (previously B | D)
    }
    else if (x instanceof C) {
        x;  // C
    }
    else {
        x;  // D (previously never)
    }
}
</code></pre>
    
      <h2 id="type-guards-inferred-from--in-operator">
        
        
          Type guards inferred from  <code>in</code> operator <a aria-label="Link to the header: Type guards inferred from  in operator" title="Link to the header: Type guards inferred from  in operator" href="#type-guards-inferred-from--in-operator" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The <code>in</code> operator now acts as a narrowing expression for types.</p>

<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p>
    
      <h4 id="example-28">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-28" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface A { a: number };
interface B { b: string };

function foo(x: A | B) {
    if ("a" in x) {
        return x.a;
    }
    return x.b;
}
</code></pre>
    
      <h2 id="support-for-import-d-from-cjs-form-commonjs-modules-with---esmoduleinterop">
        
        
          Support for <code>import d from "cjs"</code> form CommonJS modules with <code>--esModuleInterop</code> <a aria-label="Link to the header: Support for import d from "cjs" form CommonJS modules with --esModuleInterop" title="Link to the header: Support for import d from "cjs" form CommonJS modules with --esModuleInterop" href="#support-for-import-d-from-cjs-form-commonjs-modules-with---esmoduleinterop" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an <code>__esModule</code> indicator under <code>--esModuleInterop</code>.
The change brings the generated output from TypeScript closer to that generated by Babel.</p>

<p>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</p>

<ul>
  <li>
    <p>TypeScript treats a namespace import (i.e. <code>import * as foo from "foo"</code>) for a CommonJS/AMD/UMD module as equivalent to <code>const foo = require("foo")</code>.
Things are simple here, but they don’t work out if the primary object being imported is a primitive or a class or a function.
ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (<code>foo</code> in the example above) is not callable, though allowed by TypeScript</p>
  </li>
  <li>
    <p>Similarly a default import (i.e. <code>import d from "foo"</code>) for a CommonJS/AMD/UMD module as equivalent to <code>const d = require("foo").default</code>.
Most of the CommonJS/AMD/UMD modules available today do not have a <code>default</code> export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance <code>import fs from "fs"</code> or <code>import express from "express"</code> are not allowed.</p>
  </li>
</ul>

<p>Under the new <code>--esModuleInterop</code> these two issues should be addressed:</p>
<ul>
  <li>A namespace import (i.e. <code>import * as foo from "foo"</code>) is now correctly flagged as uncallabale. Calling it will result in an error.</li>
  <li>Default imports to CommonJS/AMD/UMD are now allowed (e.g. <code>import fs from "fs"</code>), and should work as expected.</li>
</ul>

<blockquote>
  <p>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. We highly recommend applying it both to new and existing projects.
For existing projects, namespace imports (<code>import * as express from "express"; express();</code>) will need to be converted to default imports (<code>import express from "express"; express();</code>).</p>
</blockquote>
    
      <h4 id="example-29">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-29" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>With <code>--esModuleInterop</code> two new helpers are generated <code>__importStar</code> and <code>__importDefault</code> for import <code>*</code> and import <code>default</code> respectively.
For instance input like:</p>

<pre><code class="language-ts">import * as foo from "foo";
import b from "bar";
</code></pre>

<p>Will generate:</p>

<pre><code class="language-js">"use strict";
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
}
exports.__esModule = true;
var foo = __importStar(require("foo"));
var bar_1 = __importDefault(require("bar"));
</code></pre>
    
      <h2 id="numeric-separators">
        
        
          Numeric separators <a aria-label="Link to the header: Numeric separators" title="Link to the header: Numeric separators" href="#numeric-separators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.7 brings support for <a href="https://github.com/tc39/proposal-numeric-separator">ES Numeric Separators</a>.
Numeric literals can now be separated into segments using <code>_</code>.</p>
    
      <h5 id="example-30">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-30" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">const milion = 1_000_000;
const phone = 555_734_2231;
const bytes = 0xFF_0C_00_FF;
const word = 0b1100_0011_1101_0001;
</code></pre>
    
      <h2 id="cleaner-output-in---watch-mode">
        
        
          Cleaner output in <code>--watch</code> mode <a aria-label="Link to the header: Cleaner output in --watch mode" title="Link to the header: Cleaner output in --watch mode" href="#cleaner-output-in---watch-mode" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript’s <code>--watch</code> mode now clears the screen after a re-compilation is requested.</p>
    
      <h2 id="prettier---pretty-output">
        
        
          Prettier <code>--pretty</code> output <a aria-label="Link to the header: Prettier --pretty output" title="Link to the header: Prettier --pretty output" href="#prettier---pretty-output" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript’s <code>--pretty</code> flag can make error messages easier to read and manage.
<code>--pretty</code> now uses colors for file names, diagnostic codes, and line numbers.
File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</p>
    
      <h2 id="typescript-26">
        
        
          TypeScript 2.6 <a aria-label="Link to the header: TypeScript 2.6" title="Link to the header: TypeScript 2.6" href="#typescript-26" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="strict-function-types">
        
        
          Strict function types <a aria-label="Link to the header: Strict function types" title="Link to the header: Strict function types" href="#strict-function-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 introduces a new strict checking flag, <code>--strictFunctionTypes</code>.
The <code>--strictFunctionTypes</code> switch is part of the <code>--strict</code> family of switches, meaning that it defaults to on in <code>--strict</code> mode.
You can opt-out by setting <code>--strictFunctionTypes false</code> on your command line or in your tsconfig.json.</p>

<p>Under <code>--strictFunctionTypes</code> function type parameter positions are checked <em>contravariantly</em> instead of <em>bivariantly</em>.
For some background on what variance means for function types check out <a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance">What are covariance and contravariance?</a>.</p>

<p>The stricter checking applies to all function types, <em>except</em> those originating in method or constructor declarations.
Methods are excluded specifically to ensure generic classes and interfaces (such as <code>Array&lt;T&gt;</code>) continue to mostly relate covariantly.</p>

<p>Consider the following example in which <code>Animal</code> is the supertype of <code>Dog</code> and <code>Cat</code>:</p>

<pre><code class="language-ts">declare let f1: (x: Animal) =&gt; void;
declare let f2: (x: Dog) =&gt; void;
declare let f3: (x: Cat) =&gt; void;
f1 = f2;  // Error with --strictFunctionTypes
f2 = f1;  // Ok
f2 = f3;  // Error
</code></pre>

<p>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode.
Intuitively, the default mode permits the assignment because it is <em>possibly</em> sound, whereas strict function types mode makes it an error because it isn’t <em>provably</em> sound.
In either mode the third assignment is an error because it is <em>never</em> sound.</p>

<p>Another way to describe the example is that the type <code>(x: T) =&gt; void</code> is <em>bivariant</em> (i.e. covariant <em>or</em> contravariant) for <code>T</code> in default type checking mode, but <em>contravariant</em> for <code>T</code> in strict function types mode.</p>
    
      <h4 id="example-31">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-31" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface Comparer&lt;T&gt; {
    compare: (a: T, b: T) =&gt; number;
}

declare let animalComparer: Comparer&lt;Animal&gt;;
declare let dogComparer: Comparer&lt;Dog&gt;;

animalComparer = dogComparer;  // Error
dogComparer = animalComparer;  // Ok
</code></pre>

<p>The first assignment is now an error. Effectively, <code>T</code> is contravariant in <code>Comparer&lt;T&gt;</code> because it is used only in function type parameter positions.</p>

<p>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (<code>out</code>/<code>in</code> or <code>+</code>/<code>-</code>), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript’s structural type system.</p>
    
      <h4 id="note">
        
        
          Note: <a aria-label="Link to the header: Note:" title="Link to the header: Note:" href="#note" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Under <code>--strictFunctionTypes</code> the first assignment is still permitted if <code>compare</code> was declared as a method.
Effectively, <code>T</code> is bivariant in <code>Comparer&lt;T&gt;</code> because it is used only in method parameter positions.</p>

<pre><code class="language-ts">interface Comparer&lt;T&gt; {
    compare(a: T, b: T): number;
}

declare let animalComparer: Comparer&lt;Animal&gt;;
declare let dogComparer: Comparer&lt;Dog&gt;;

animalComparer = dogComparer;  // Ok because of bivariance
dogComparer = animalComparer;  // Ok
</code></pre>

<p>TypeScript 2.6 also improves type inference involving contravariant positions:</p>

<pre><code class="language-ts">function combine&lt;T&gt;(...funcs: ((x: T) =&gt; void)[]): (x: T) =&gt; void {
    return x =&gt; {
        for (const f of funcs) f(x);
    }
}

function animalFunc(x: Animal) {}
function dogFunc(x: Dog) {}

let combined = combine(animalFunc, dogFunc);  // (x: Dog) =&gt; void
</code></pre>

<p>Above, all inferences for <code>T</code> originate in contravariant positions, and we therefore infer the <em>best common subtype</em> for <code>T</code>.
This contrasts with inferences from covariant positions, where we infer the <em>best common supertype</em>.</p>
    
      <h2 id="support-for-jsx-fragment-syntax">
        
        
          Support for JSX Fragment Syntax <a aria-label="Link to the header: Support for JSX Fragment Syntax" title="Link to the header: Support for JSX Fragment Syntax" href="#support-for-jsx-fragment-syntax" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6.2 adds support for the new <code>&lt;&gt;...&lt;/&gt;</code> syntax for fragments in JSX.
It is frequently desirable to return multiple children from a component.
However, this is invalid, so the usual approach has been to wrap the text in an extra element, such as a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> as shown below.</p>

<pre><code class="language-tsx">render() {
    return (
        &lt;div&gt;
            Some text.
            &lt;h2&gt;A heading&lt;/h2&gt;
            More text.
        &lt;/div&gt;
    );
}
</code></pre>

<p>To address this pattern, React introduced the <code>React.Fragment</code> component, which provides a dedicated way to wrap such elements without adding an element to the DOM.
Correspondingly, the <code>&lt;&gt;...&lt;/&gt;</code> syntax was added to JSX to facilitate this new construct. Therefore, the above scenario becomes:</p>
<pre><code class="language-tsx">render() {
    return (
        &lt;&gt;
            Some text.
            &lt;h2&gt;A heading&lt;/h2&gt;
            More text.
        &lt;/&gt;
    );
}
</code></pre>

<p>Under <code>--jsx preserve</code>, the new syntax is left untouched for TypeScript emit. Otherwise, for <code>--jsx react</code>, <code>&lt;&gt;...&lt;/&gt;</code> is compiled to <code>React.createElement(React.Fragment, null, ...)</code>, where <code>React.createElement</code> respects <code>--jsxFactory</code>.
Note that it is an error to use <code>&lt;&gt;...&lt;/&gt;</code> when <code>--jsx react</code> and <code>--jsxFactory</code> are both enabled.</p>

<p>Please refer to <a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html">the React blog</a> for more details on fragments and the new syntax.</p>
    
      <h2 id="cache-tagged-template-objects-in-modules">
        
        
          Cache tagged template objects in modules <a aria-label="Link to the header: Cache tagged template objects in modules" title="Link to the header: Cache tagged template objects in modules" href="#cache-tagged-template-objects-in-modules" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec.
As per the <a href="https://tc39.github.io/ecma262/#sec-gettemplateobject">ECMAScript spec</a>, every time a template tag is evaluated, the <em>same</em> template strings object (the same <code>TemplateStringsArray</code>) should be passed as the first argument.
Before TypeScript 2.6, the generated output was a completely new template object each time.
Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. <a href="https://github.com/PolymerLabs/lit-html/issues/58">lit-html</a>.</p>
    
      <h4 id="example-32">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-32" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">export function id(x: TemplateStringsArray) {
    return x;
}

export function templateObjectFactory() {
    return id`hello world`;
}

let result = templateObjectFactory() === templateObjectFactory(); // true in TS 2.6
</code></pre>

<p>Results in the following generated code:</p>

<pre><code class="language-js">"use strict";
var __makeTemplateObject = (this &amp;&amp; this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function id(x) {
    return x;
}

var _a;
function templateObjectFactory() {
    return id(_a || (_a = __makeTemplateObject(["hello world"], ["hello world"])));
}

var result = templateObjectFactory() === templateObjectFactory();
</code></pre>

<blockquote>
  <p>Note: This change brings a new emit helper, <code>__makeTemplateObject</code>;
if you are using <code>--importHelpers</code> with <a href="https://github.com/Microsoft/tslib"><code>tslib</code></a>, an updated to version 1.8 or later.</p>
</blockquote>
    
      <h2 id="localized-diagnostics-on-the-command-line">
        
        
          Localized diagnostics on the command line <a aria-label="Link to the header: Localized diagnostics on the command line" title="Link to the header: Localized diagnostics on the command line" href="#localized-diagnostics-on-the-command-line" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages.
The localized messages are available when using <code>--locale</code> flag on the command line.</p>
    
      <h4 id="example-33">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-33" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Error messages in Russian:</p>

<pre><code class="language-sh">c:\ts&gt;tsc --v
Version 2.6.0-dev.20171003

c:\ts&gt;tsc --locale ru --pretty c:\test\a.ts

../test/a.ts(1,5): error TS2322: Тип ""string"" не может быть назначен для типа "number".

1 var x: number = "string";
      ~
</code></pre>

<p>And help in Japanese:</p>

<pre><code class="language-sh">PS C:\ts&gt; tsc --v
Version 2.6.0-dev.20171003

PS C:\ts&gt; tsc --locale ja-jp
バージョン 2.6.0-dev.20171003
構文: tsc [オプション] [ファイル ...]

例:  tsc hello.ts
    tsc --outFile file.js file.ts
    tsc @args.txt

オプション:
 -h, --help                                 このメッセージを表示します。
 --all                                      コンパイラ オプションをすべて表示します。
 -v, --version                              コンパイラのバージョンを表示します。
 --init                                     TypeScript プロジェクトを初期化して、tsconfig.json ファイルを作成します。
 -p ファイルまたはディレクトリ, --project ファイルまたはディレクトリ  構成ファイルか、'tsconfig.json' を含むフォルダーにパスが指定されたプロジェクトをコ
ンパイルします。
 --pretty                                   色とコンテキストを使用してエラーとメッセージにスタイルを適用します (試験的)。
 -w, --watch                                入力ファイルを監視します。
 -t バージョン, --target バージョン                   ECMAScript のターゲット バージョンを指定します: 'ES3' (既定)、'ES5'、'ES2015'、'ES2016'、'ES2017'、'ES
NEXT'。
 -m 種類, --module 種類                         モジュール コード生成を指定します: 'none'、'commonjs'、'amd'、'system'、'umd'、'es2015'、'ESNext'。
 --lib                                      コンパイルに含めるライブラリ ファイルを指定します:
                                              'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es201
5.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellkno
wn' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable'
 --allowJs                                  javascript ファイルのコンパイルを許可します。
 --jsx 種類                                   JSX コード生成を指定します: 'preserve'、'react-native'、'react'。
 -d, --declaration                          対応する '.d.ts' ファイルを生成します。
 --sourceMap                                対応する '.map' ファイルを生成します。
 --outFile ファイル                             出力を連結して 1 つのファイルを生成します。
 --outDir ディレクトリ                            ディレクトリへ出力構造をリダイレクトします。
 --removeComments                           コメントを出力しないでください。
 --noEmit                                   出力しないでください。
 --strict                                   strict 型チェックのオプションをすべて有効にします。
 --noImplicitAny                            暗黙的な 'any' 型を含む式と宣言に関するエラーを発生させます。
 --strictNullChecks                         厳格な null チェックを有効にします。
 --noImplicitThis                           暗黙的な 'any' 型を持つ 'this' 式でエラーが発生します。
 --alwaysStrict                             厳格モードで解析してソース ファイルごとに "use strict" を生成します。
 --noUnusedLocals                           使用されていないローカルに関するエラーを報告します。
 --noUnusedParameters                       使用されていないパラメーターに関するエラーを報告します。
 --noImplicitReturns                        関数の一部のコード パスが値を返さない場合にエラーを報告します。
 --noFallthroughCasesInSwitch               switch ステートメントに case のフォールスルーがある場合にエラーを報告します。
 --types                                    コンパイルに含む型宣言ファイル。
 @&lt;ファイル&gt;
</code></pre>
    
      <h2 id="suppress-errors-in-ts-files-using--ts-ignore-comments">
        
        
          Suppress errors in .ts files using ‘// @ts-ignore’ comments <a aria-label="Link to the header: Suppress errors in .ts files using ‘// @ts-ignore’ comments" title="Link to the header: Suppress errors in .ts files using ‘// @ts-ignore’ comments" href="#suppress-errors-in-ts-files-using--ts-ignore-comments" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 support suppressing errors in .js files using <code>// @ts-ignore</code> comments placed above the offending lines.</p>
    
      <h4 id="example-34">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-34" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">if (false) {
    // @ts-ignore: Unreachable code error
    console.log("hello");
}
</code></pre>

<p>A <code>// @ts-ignore</code> comment suppresses all errors that originate on the following line.
It is recommended practice to have the remainder of the comment following <code>@ts-ignore</code> explain which error is being suppressed.</p>

<p>Please note that this comment only suppresses the error reporting, and we recommend you use this comments <em>very sparingly</em>.</p>
    
      <h2 id="faster-tsc---watch">
        
        
          Faster <code>tsc --watch</code> <a aria-label="Link to the header: Faster tsc --watch" title="Link to the header: Faster tsc --watch" href="#faster-tsc---watch" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 brings a faster <code>--watch</code> implementation.
The new version optimizes code generation and checking for code bases using ES modules.
Changes detected in a module file will result in <em>only</em> regenerating the changed module, and files that depend on it, instead of the whole project.
Projects with large number of files should reap the most benefit from this change.</p>

<p>The new implementation also brings performance enhancements to watching in tsserver.
The watcher logic has been completely rewritten to respond faster to change events.</p>
    
      <h2 id="write-only-references-now-flagged-as-unused">
        
        
          Write-only references now flagged as unused <a aria-label="Link to the header: Write-only references now flagged as unused" title="Link to the header: Write-only references now flagged as unused" href="#write-only-references-now-flagged-as-unused" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.6 adds revised implementation  the <code>--noUnusedLocals</code> and <code>--noUnusedParameters</code> <a href="/docs/handbook/compiler-options.html">compiler options</a>.
Declarations are only written to but never read from are now flagged as unused.</p>
    
      <h4 id="example-35">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-35" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Bellow both <code>n</code> and <code>m</code> will be marked as unused, because their values are never <em>read</em>. Previously TypeScript would only check whether their values were <em>referenced</em>.</p>

<pre><code class="language-ts">function f(n: number) {
    n = 0;
}

class C {
    private m: number;
    constructor() {
        this.m = 0;
    }
}
</code></pre>

<p>Also functions that are only called within their own bodies are considered unused.</p>
    
      <h4 id="example-36">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-36" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">function f() {
    f(); // Error: 'f' is declared but its value is never read
}
</code></pre>
    
      <h2 id="typescript-25">
        
        
          TypeScript 2.5 <a aria-label="Link to the header: TypeScript 2.5" title="Link to the header: TypeScript 2.5" href="#typescript-25" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="optional-catch-clause-variables">
        
        
          Optional <code>catch</code> clause variables <a aria-label="Link to the header: Optional catch clause variables" title="Link to the header: Optional catch clause variables" href="#optional-catch-clause-variables" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Thanks to work done by <a href="https://github.com/tinganho">@tinganho</a>, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in <code>catch</code> clauses.
For example, when using <code>JSON.parse</code> you may need to wrap calls to the function with a <code>try</code>/<code>catch</code>, but you may not end up using the <code>SyntaxError</code> that gets thrown when input is erroneous.</p>

<pre><code class="language-ts">let input = "...";
try {
    JSON.parse(input);
}
catch {
    // ^ Notice that our `catch` clause doesn't declare a variable.
    console.log("Invalid JSON given\n\n" + input)
}
</code></pre>
    
      <h2 id="type-assertioncast-syntax-in-checkjsts-check-mode">
        
        
          Type assertion/cast syntax in <code>checkJs</code>/<code>@ts-check</code> mode <a aria-label="Link to the header: Type assertion/cast syntax in checkJs/@ts-check mode" title="Link to the header: Type assertion/cast syntax in checkJs/@ts-check mode" href="#type-assertioncast-syntax-in-checkjsts-check-mode" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.5 introduces the ability to <a href="https://github.com/Microsoft/TypeScript/issues/5158">assert the type of expressions when using plain JavaScript in your projects</a>.
The syntax is an <code>/** @type {...} */</code> annotation comment followed by a parenthesized expression whose type needs to be re-evaluated.
For example:</p>

<pre><code class="language-ts">var x = /** @type {SomeType} */ (AnyParenthesizedExpression);
</code></pre>
    
      <h2 id="deduplicated-and-redirected-packages">
        
        
          Deduplicated and redirected packages <a aria-label="Link to the header: Deduplicated and redirected packages" title="Link to the header: Deduplicated and redirected packages" href="#deduplicated-and-redirected-packages" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>When importing using the <code>Node</code> module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from “identical” packages.
If a file originates from a package with a <code>package.json</code> containing the same <code>name</code> and <code>version</code> fields as a previously encountered package, then TypeScript will redirect itself to the top-most package.
This helps resolve problems where two packages might contain identical declarations of classes, but which contain <code>private</code> members that cause them to be structurally incompatible.</p>

<p>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading <code>.d.ts</code> files from duplicate packages.</p>
    
      <h2 id="the---preservesymlinks-compiler-flag">
        
        
          The <code>--preserveSymlinks</code> compiler flag <a aria-label="Link to the header: The --preserveSymlinks compiler flag" title="Link to the header: The --preserveSymlinks compiler flag" href="#the---preservesymlinks-compiler-flag" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.5 brings the <code>preserveSymlinks</code> flag, which parallels the behavior of <a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks">the <code>--preserve-symlinks</code> flag in Node.js</a>.
This flag also exhibits the opposite behavior to Webpack’s <code>resolve.symlinks</code> option (i.e. setting TypeScript’s <code>preserveSymlinks</code> to <code>true</code> parallels setting Webpack’s <code>resolve.symlinks</code> to <code>false</code>, and vice-versa).</p>

<p>In this mode, references to modules and packages (e.g. <code>import</code>s and <code>/// &lt;reference type="..." /&gt;</code> directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.
For a more concrete example, we’ll defer to <a href="https://nodejs.org/api/cli.html#cli_preserve_symlinks">the documentation on the Node.js website</a>.</p>
    
      <h2 id="typescript-24">
        
        
          TypeScript 2.4 <a aria-label="Link to the header: TypeScript 2.4" title="Link to the header: TypeScript 2.4" href="#typescript-24" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="dynamic-import-expressions">
        
        
          Dynamic Import Expressions <a aria-label="Link to the header: Dynamic Import Expressions" title="Link to the header: Dynamic Import Expressions" href="#dynamic-import-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Dynamic <code>import</code> expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</p>

<p>This means that you can conditionally and lazily import other modules and libraries.
For example, here’s an <code>async</code> function that only imports a utility library when it’s needed:</p>

<pre><code class="language-ts">async function getZipFile(name: string, files: File[]): Promise&lt;File&gt; {
    const zipUtil = await import('./utils/create-zip-file');
    const zipContents = await zipUtil.getContentAsBlob(files);
    return new File(zipContents, name);
}
</code></pre>

<p>Many bundlers have support for automatically splitting output bundles based on these <code>import</code> expressions, so consider using this new feature with the <code>esnext</code> module target.</p>
    
      <h2 id="string-enums">
        
        
          String Enums <a aria-label="Link to the header: String Enums" title="Link to the header: String Enums" href="#string-enums" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.4 now allows enum members to contain string initializers.</p>

<pre><code class="language-ts">enum Colors {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
}
</code></pre>

<p>The caveat is that string-initialized enums can’t be reverse-mapped to get the original enum member name.
In other words, you can’t write <code>Colors["RED"]</code> to get the string <code>"Red"</code>.</p>
    
      <h2 id="improved-inference-for-generics">
        
        
          Improved inference for generics <a aria-label="Link to the header: Improved inference for generics" title="Link to the header: Improved inference for generics" href="#improved-inference-for-generics" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</p>
    
      <h3 id="return-types-as-inference-targets">
        
        
          Return types as inference targets <a aria-label="Link to the header: Return types as inference targets" title="Link to the header: Return types as inference targets" href="#return-types-as-inference-targets" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>For one, TypeScript can now make inferences for the return type of a call.
This can improve your experience and catch errors.
Something that now works:</p>

<pre><code class="language-ts">function arrayMap&lt;T, U&gt;(f: (x: T) =&gt; U): (a: T[]) =&gt; U[] {
    return a =&gt; a.map(f);
}

const lengths: (a: string[]) =&gt; number[] = arrayMap(s =&gt; s.length);
</code></pre>

<p>As an example of new errors you might spot as a result:</p>

<pre><code class="language-ts">let x: Promise&lt;string&gt; = new Promise(resolve =&gt; {
    resolve(10);
    //      ~~ Error!
});
</code></pre>
    
      <h3 id="type-parameter-inference-from-contextual-types">
        
        
          Type parameter inference from contextual types <a aria-label="Link to the header: Type parameter inference from contextual types" title="Link to the header: Type parameter inference from contextual types" href="#type-parameter-inference-from-contextual-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Prior to TypeScript 2.4, in the following example</p>

<pre><code class="language-ts">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y;
</code></pre>

<p><code>y</code> would have the type <code>any</code>.
This meant the program would type-check, but you could technically do anything with <code>y</code>, such as the following:</p>

<pre><code class="language-ts">let f: &lt;T&gt;(x: T) =&gt; T = y =&gt; y() + y.foo.bar;
</code></pre>

<p>That last example isn’t actually type-safe.</p>

<p>In TypeScript 2.4, the function on the right side implicitly <em>gains</em> type parameters, and <code>y</code> is inferred to have the type of that type-parameter.</p>

<p>If you use <code>y</code> in a way that the type parameter’s constraint doesn’t support, you’ll correctly get an error.
In this case, the constraint of <code>T</code> was (implicitly) <code>{}</code>, so the last example will appropriately fail.</p>
    
      <h3 id="stricter-checking-for-generic-functions">
        
        
          Stricter checking for generic functions <a aria-label="Link to the header: Stricter checking for generic functions" title="Link to the header: Stricter checking for generic functions" href="#stricter-checking-for-generic-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript now tries to unify type parameters when comparing two single-signature types.
As a result, you’ll get stricter checks when relating two generic signatures, and may catch some bugs.</p>

<pre><code class="language-ts">type A = &lt;T, U&gt;(x: T, y: U) =&gt; [T, U];
type B = &lt;S&gt;(x: S, y: S) =&gt; [S, S];

function f(a: A, b: B) {
    a = b;  // Error
    b = a;  // Ok
}
</code></pre>
    
      <h2 id="strict-contravariance-for-callback-parameters">
        
        
          Strict contravariance for callback parameters <a aria-label="Link to the header: Strict contravariance for callback parameters" title="Link to the header: Strict contravariance for callback parameters" href="#strict-contravariance-for-callback-parameters" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript has always compared parameters in a bivariant way.
There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with <code>Promise</code>s and <code>Observable</code>s.</p>

<p>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</p>

<pre><code class="language-ts">interface Mappable&lt;T&gt; {
    map&lt;U&gt;(f: (x: T) =&gt; U): Mappable&lt;U&gt;;
}

declare let a: Mappable&lt;number&gt;;
declare let b: Mappable&lt;string | number&gt;;

a = b;
b = a;
</code></pre>

<p>Prior to TypeScript 2.4, this example would succeed.
When relating the types of <code>map</code>, TypeScript would bidirectionally relate their parameters (i.e. the type of <code>f</code>).
When relating each <code>f</code>, TypeScript would also bidirectionally relate the type of <em>those</em> parameters.</p>

<p>When relating the type of <code>map</code> in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</p>

<p>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</p>
    
      <h2 id="weak-type-detection">
        
        
          Weak Type Detection <a aria-label="Link to the header: Weak Type Detection" title="Link to the header: Weak Type Detection" href="#weak-type-detection" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.4 introduces the concept of “weak types”.
Any type that contains nothing but a set of all-optional properties is considered to be <em>weak</em>.
For example, this <code>Options</code> type is a weak type:</p>

<pre><code class="language-ts">interface Options {
    data?: string;
    timeout?: number;
    maxRetries?: number;
}
</code></pre>

<p>In TypeScript 2.4, it’s now an error to assign anything to a weak type when there’s no overlap in properties.
For example:</p>

<pre><code class="language-ts">function sendMessage(options: Options) {
    // ...
}

const opts = {
    payload: "hello world!",
    retryOnFail: true,
}

// Error!
sendMessage(opts);
// No overlap between the type of 'opts' and 'Options' itself.
// Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.
</code></pre>

<p>You can think of this as TypeScript “toughening up” the weak guarantees of these types to catch what would otherwise be silent bugs.</p>

<p>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</p>

<ol>
  <li>Declare the properties if they really do exist.</li>
  <li>Add an index signature to the weak type (i.e. <code>[propName: string]: {}</code>).</li>
  <li>Use a type assertion (i.e. <code>opts as Options</code>).</li>
</ol>
    
      <h2 id="typescript-23">
        
        
          TypeScript 2.3 <a aria-label="Link to the header: TypeScript 2.3" title="Link to the header: TypeScript 2.3" href="#typescript-23" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="generators-and-iteration-for-es5es3">
        
        
          Generators and Iteration for ES5/ES3 <a aria-label="Link to the header: Generators and Iteration for ES5/ES3" title="Link to the header: Generators and Iteration for ES5/ES3" href="#generators-and-iteration-for-es5es3" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><em>First some ES2016 terminology:</em></p>
    
      <h4 id="iterators">
        
        
          Iterators <a aria-label="Link to the header: Iterators" title="Link to the header: Iterators" href="#iterators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iteration">ES2015 introduced <code>Iterator</code></a>, which is an object that exposes three methods, <code>next</code>, <code>return</code>, and <code>throw</code>, as per the following interface:</p>
<pre><code class="language-ts">interface Iterator&lt;T&gt; {
  next(value?: any): IteratorResult&lt;T&gt;;
  return?(value?: any): IteratorResult&lt;T&gt;;
  throw?(e?: any): IteratorResult&lt;T&gt;;
}
</code></pre>

<p>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map.
An object that supports iteration is said to be “iterable” if it has a <code>Symbol.iterator</code> method that returns an <code>Iterator</code> object.</p>

<p>The Iterator protocol also defines the target of some of the ES2015 features like <code>for..of</code> and spread operator and the array rest in destructuring assignmnets.</p>
    
      <h4 id="generators">
        
        
          Generators <a aria-label="Link to the header: Generators" title="Link to the header: Generators" href="#generators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects">ES2015 also introduced “Generators”</a>, which are functions that can be used to yield partial computation results via the <code>Iterator</code> interface and the <code>yield</code> keyword.
Generators can also internally delegate calls to another iterable through <code>yield *</code>. For example:</p>

<pre><code class="language-ts">function* f() {
  yield 1;
  yield* [2, 3];
}
</code></pre>
    
      <h4 id="new---downleveliteration">
        
        
          New <code>--downlevelIteration</code> <a aria-label="Link to the header: New --downlevelIteration" title="Link to the header: New --downlevelIteration" href="#new---downleveliteration" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Previously generators were only supported if the target is ES6/ES2015 or later.
Moreover, constructs that operate on the Iterator protocol, e.g. <code>for..of</code> were only supported if they operate on arrays for targets below ES6/ES2015.</p>

<p>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with <code>--downlevelIteration</code> flag.</p>

<p>With <code>--downlevelIteration</code>, the compiler uses new type check and emit behavior that attempts to call a <code>[Symbol.iterator]()</code> method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</p>

<blockquote>
  <p>Please note that this requires a native <code>Symbol.iterator</code> or <code>Symbol.iterator</code> shim at runtime for any non-array values.</p>
</blockquote>

<p><code>for..of</code> statements,  Array Destructuring, and Spread elements in Array, Call, and New expressions support <code>Symbol.iterator</code> in ES5/E3 if available when using <code>--downlevelIteration</code>, but can be used on an Array even if it does not define <code>Symbol.iterator</code> at run time or design time.</p>
    
      <h2 id="async-iteration">
        
        
          Async Iteration <a aria-label="Link to the header: Async Iteration" title="Link to the header: Async Iteration" href="#async-iteration" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.3 adds support for the async iterators and generators as described by the current <a href="https://github.com/tc39/proposal-async-iteration">TC39 proposal</a>.</p>
    
      <h4 id="async-iterators">
        
        
          Async iterators <a aria-label="Link to the header: Async iterators" title="Link to the header: Async iterators" href="#async-iterators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>The Async Iteration introduces an <code>AsyncIterator</code>, which is similar to <code>Iterator</code>.
The difference lies in the fact that the <code>next</code>, <code>return</code>, and <code>throw</code> methods of an <code>AsyncIterator</code> return a <code>Promise</code> for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the <code>AsyncIterator</code> has advanced to the point of yielding a value.
An <code>AsyncIterator</code> has the following shape:</p>

<pre><code class="language-ts">interface AsyncIterator&lt;T&gt; {
  next(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
  return?(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
  throw?(e?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;
}
</code></pre>

<p>An object that supports async iteration is said to be “iterable” if it has a <code>Symbol.asyncIterator</code> method that returns an <code>AsyncIterator</code> object.</p>
    
      <h4 id="async-generators">
        
        
          Async Generators <a aria-label="Link to the header: Async Generators" title="Link to the header: Async Generators" href="#async-generators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>The <a href="https://github.com/tc39/proposal-async-iteration">Async Iteration proposal</a> introduces “Async Generators”, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via <code>yield*</code> to either an iterable or async iterable:</p>

<pre><code class="language-ts">async function* g() {
  yield 1;
  await sleep(100);
  yield* [2, 3];
  yield* (async function *() {
    await sleep(100);
    yield 4;
  })();
}
</code></pre>

<p>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global <code>Promise</code> implementation (either native or an ES2015-compatible polyfill), in addition to a valid <code>Symbol.asyncIterator</code> reference (either a native symbol or a shim).</p>
    
      <h4 id="the-for-await-of-statement">
        
        
          The <code>for-await-of</code> Statement <a aria-label="Link to the header: The for-await-of Statement" title="Link to the header: The for-await-of Statement" href="#the-for-await-of-statement" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>With ES2015, ECMAScript introduced the <code>for..of</code> statement as a means of iterating over an iterable.
Similarly, the Async Iteration proposal introduces the <code>for..await..of</code> statement to iterate over an async iterable:</p>

<pre><code class="language-ts">async function f() {
  for await (const x of g()) {
     console.log(x);
  }
}
</code></pre>

<p>The <code>for..await..of</code> statement is only legal within an Async Function or Async Generator.</p>
    
      <h4 id="caveats-6">
        
        
          Caveats <a aria-label="Link to the header: Caveats" title="Link to the header: Caveats" href="#caveats-6" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<ul>
  <li>Keep in mind that our support for async iterators relies on support for <code>Symbol.asyncIterator</code> to exist at runtime.
You may need to polyfill <code>Symbol.asyncIterator</code>, which for simple purposes can be as simple as: <code>(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.from("Symbol.asyncIterator");</code></li>
  <li>You also need to include <code>esnext</code> in your <code>--lib</code> option, to get the <code>AsyncIterator</code> declaration if you do not already have it.</li>
  <li>Finally, if your target is ES5 or ES3, you’ll also need to set the <code>--downlevelIterators</code> flag.</li>
</ul>
    
      <h2 id="generic-parameter-defaults">
        
        
          Generic parameter defaults <a aria-label="Link to the header: Generic parameter defaults" title="Link to the header: Generic parameter defaults" href="#generic-parameter-defaults" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</p>
    
      <h4 id="example-37">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-37" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Consider a function that creates a new <code>HTMLElement</code>, calling it with no arguments generates a <code>Div</code>; you can optionally pass a list of children as well. Previously you would have to define it as:</p>

<pre><code class="language-ts">declare function create(): Container&lt;HTMLDivElement, HTMLDivElement[]&gt;;
declare function create&lt;T extends HTMLElement&gt;(element: T): Container&lt;T, T[]&gt;;
declare function create&lt;T extends HTMLElement, U extends HTMLElement&gt;(element: T, children: U[]): Container&lt;T, U[]&gt;;
</code></pre>

<p>With generic parameter defaults we can reduce it to:</p>

<pre><code class="language-ts">declare function create&lt;T extends HTMLElement = HTMLDivElement, U = T[]&gt;(element?: T, children?: U): Container&lt;T, U&gt;;
</code></pre>

<p>A generic parameter default follows the following rules:</p>
<ul>
  <li>A type parameter is deemed optional if it has a default.</li>
  <li>Required type parameters must not follow optional type parameters.</li>
  <li>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</li>
  <li>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</li>
  <li>If a default type is specified and inference cannot chose a candidate, the default type is inferred.</li>
  <li>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</li>
  <li>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</li>
</ul>
    
      <h2 id="new---strict-master-option">
        
        
          New <code>--strict</code> master option <a aria-label="Link to the header: New --strict master option" title="Link to the header: New --strict master option" href="#new---strict-master-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the <code>--strict</code> option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</p>

<p>The new <code>--strict</code> compiler option represents the recommended setting of a number of type checking options. Specifically, specifying <code>--strict</code> corresponds to specifying all of the following options (and may in the future include more options):</p>

<ul>
  <li><code>--strictNullChecks</code></li>
  <li><code>--noImplicitAny</code></li>
  <li><code>--noImplicitThis</code></li>
  <li><code>--alwaysStrict</code></li>
</ul>

<p>In exact terms, the <code>--strict</code> option sets the <em>default</em> value for the compiler options listed above. This means it is still possible to individually control the options. For example,</p>

<pre><code>--strict --noImplicitThis false
</code></pre>

<p>has the effect of turning on all strict options <em>except</em> the <code>--noImplicitThis</code> option. Using this scheme it is possible to express configurations consisting of <em>all</em> strict options except some explicitly listed options. In other words, it is now possible to default to the highest level of type safety but opt out of certain checks.</p>

<p>Starting with TypeScript 2.3, the default <code>tsconfig.json</code> generated by <code>tsc --init</code> includes a <code>"strict": true</code> setting in the <code>"compilerOptions"</code> section. Thus, new projects started with <code>tsc --init</code> will by default have the highest level of type safety enabled.</p>
    
      <h2 id="enhanced---init-output">
        
        
          Enhanced <code>--init</code> output <a aria-label="Link to the header: Enhanced --init output" title="Link to the header: Enhanced --init output" href="#enhanced---init-output" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Along with setting <code>--strict</code> on by default, <code>tsc --init</code> has an enhanced output. Default <code>tsconfig.json</code> files generated by <code>tsc --init</code> now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</p>
    
      <h2 id="errors-in-js-files-with---checkjs">
        
        
          Errors in .js files with <code>--checkJs</code> <a aria-label="Link to the header: Errors in .js files with --checkJs" title="Link to the header: Errors in .js files with --checkJs" href="#errors-in-js-files-with---checkjs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>By default the TypeScript compiler does not report any errors in .js files including using <code>--allowJs</code>. With TypeScript 2.3 type-checking errors can also be reported in <code>.js</code> files with <code>--checkJs</code>.</p>

<p>You can skip checking some files by adding <code>// @ts-nocheck</code> comment to them; conversely you can choose to check only a few <code>.js</code> files by adding <code>// @ts-check</code> comment to them without setting <code>--checkJs</code>. You can also ignore errors on specific lines by adding <code>// @ts-ignore</code> on the preceding line.</p>

<p><code>.js</code> files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in <code>.ts</code> files and are flagged as errors in <code>.js</code> files. JSDoc comments can be used to add some type information to your JavaScript code, see <a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript">JSDoc Support documentation</a> for more details about the supported JSDoc constructs.</p>

<p>See <a href="https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files">Type checking JavaScript Files documentation</a> for more details.</p>
    
      <h2 id="typescript-22">
        
        
          TypeScript 2.2 <a aria-label="Link to the header: TypeScript 2.2" title="Link to the header: TypeScript 2.2" href="#typescript-22" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="support-for-mix-in-classes">
        
        
          Support for Mix-in classes <a aria-label="Link to the header: Support for Mix-in classes" title="Link to the header: Support for Mix-in classes" href="#support-for-mix-in-classes" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins">MDN Mixin description</a> and <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">“Real” Mixins with JavaScript Classes</a> for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</p>
    
      <h5 id="first-some-terminology">
        
        
          First some terminology: <a aria-label="Link to the header: First some terminology:" title="Link to the header: First some terminology:" href="#first-some-terminology" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<ul>
  <li>
    <p>A <strong>mixin constructor type</strong> refers to a type that has a single construct signature with a single rest argument of type <code>any[]</code> and an object-like return type. For example, given an object-like type <code>X</code>, <code>new (...args: any[]) =&gt; X</code> is a mixin constructor type with an instance type <code>X</code>.</p>
  </li>
  <li>
    <p>A <strong>mixin class</strong> is a class declaration or expression that <code>extends</code> an expression of a type parameter type. The following rules apply to mixin class declarations:</p>
  </li>
  <li>The type parameter type of the <code>extends</code> expression must be constrained to a mixin constructor type.</li>
  <li>The constructor of a mixin class (if any) must have a single rest parameter of type <code>any[]</code> and must use the spread operator to pass those parameters as arguments in a <code>super(...args)</code> call.</li>
</ul>

<p>Given an expression <code>Base</code> of a parametric type <code>T</code> with a constraint <code>X</code>, a mixin class <code>class C extends Base {...}</code> is processed as if <code>Base</code> had type <code>X</code> and the resulting type is the intersection <code>typeof C &amp; T</code>. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</p>

<p>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type <code>{ new(...args: any[]) =&gt; A } &amp; { new(s: string) =&gt; B }</code> has a single construct signature <code>new(s: string) =&gt; A &amp; B</code>.</p>
    
      <h5 id="putting-all-of-the-above-rules-together-in-an-example">
        
        
          Putting all of the above rules together in an example: <a aria-label="Link to the header: Putting all of the above rules together in an example:" title="Link to the header: Putting all of the above rules together in an example:" href="#putting-all-of-the-above-rules-together-in-an-example" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">class Point {
    constructor(public x: number, public y: number) {}
}

class Person {
    constructor(public name: string) {}
}

type Constructor&lt;T&gt; = new(...args: any[]) =&gt; T;

function Tagged&lt;T extends Constructor&lt;{}&gt;&gt;(Base: T) {
    return class extends Base {
        _tag: string;
        constructor(...args: any[]) {
            super(...args);
            this._tag = "";
        }
    }
}

const TaggedPoint = Tagged(Point);

let point = new TaggedPoint(10, 20);
point._tag = "hello";

class Customer extends Tagged(Person) {
    accountBalance: number;
}

let customer = new Customer("Joe");
customer._tag = "test";
customer.accountBalance = 0;
</code></pre>

<p>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following <code>WithLocation</code> function implements a subclass factory that adds a <code>getLocation</code> method to any class that satisfies the <code>Point</code> interface (i.e. that has <code>x</code> and <code>y</code> properties of type <code>number</code>).</p>

<pre><code class="language-ts">interface Point {
    x: number;
    y: number;
}

const WithLocation = &lt;T extends Constructor&lt;Point&gt;&gt;(Base: T) =&gt;
    class extends Base {
        getLocation(): [number, number] {
            return [this.x, this.y];
        }
    }
</code></pre>
    
      <h2 id="object-type">
        
        
          <code>object</code> type <a aria-label="Link to the header: object type" title="Link to the header: object type" href="#object-type" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<table>
  <tbody>
    <tr>
      <td>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not <code>number</code></td>
      <td><code>string</code></td>
      <td><code>boolean</code></td>
      <td><code>symbol</code></td>
      <td><code>null</code></td>
      <td><code>undefined</code>. Enter the new <code>object</code> type.</td>
    </tr>
  </tbody>
</table>

<p>With <code>object</code> type, APIs like <code>Object.create</code> can be better represented. For example:</p>
<pre><code class="language-ts">declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
</code></pre>
    
      <h2 id="support-for-newtarget">
        
        
          Support for <code>new.target</code> <a aria-label="Link to the header: Support for new.target" title="Link to the header: Support for new.target" href="#support-for-newtarget" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The <code>new.target</code> meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via <code>new</code>, the value of <code>new.target</code> is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via <code>new</code>, <code>new.target</code> is set to <code>undefined</code>.</p>

<p><code>new.target</code> comes in handy when <code>Object.setPrototypeOf</code> or <code>__proto__</code> needs to be set in a class constructor. One such use case is inheriting from <code>Error</code> in NodeJS v4 and higher.</p>
    
      <h4 id="example-38">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-38" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">class CustomError extends Error {
    constructor(message?: string) {
        super(message); // 'Error' breaks prototype chain here
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
    }
}
</code></pre>
<p>This results in the generated JS</p>

<pre><code class="language-js">var CustomError = (function (_super) {
  __extends(CustomError, _super);
  function CustomError() {
    var _newTarget = this.constructor;
    var _this = _super.apply(this, arguments);  // 'Error' breaks prototype chain here
    _this.__proto__ = _newTarget.prototype; // restore prototype chain
    return _this;
  }
  return CustomError;
})(Error);
</code></pre>

<p><code>new.target</code> also comes in handy for writing constructable functions, for example:</p>

<pre><code class="language-ts">function f() {
  if (new.target) { /* called via 'new' */ }
}
</code></pre>

<p>Which translates to:</p>

<pre><code class="language-js">function f() {
  var _newTarget = this &amp;&amp; this instanceof f ? this.constructor : void 0;
  if (_newTarget) { /* called via 'new' */ }
}
</code></pre>
    
      <h2 id="better-checking-for-nullundefined-in-operands-of-expressions">
        
        
          Better checking for <code>null</code>/<code>undefined</code> in operands of expressions <a aria-label="Link to the header: Better checking for null/undefined in operands of expressions" title="Link to the header: Better checking for null/undefined in operands of expressions" href="#better-checking-for-nullundefined-in-operands-of-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</p>

<ul>
  <li>If either operand of a <code>+</code> operator is nullable, and neither operand is of type <code>any</code> or <code>string</code>.</li>
  <li>If either operand of a <code>-</code>, <code>*</code>, <code>**</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, or <code>^</code> operator is nullable.</li>
  <li>If either operand of a <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, or <code>in</code> operator is nullable.</li>
  <li>If the right operand of an <code>instanceof</code> operator is nullable.</li>
  <li>If the operand of a <code>+</code>, <code>-</code>, <code>~</code>, <code>++</code>, or <code>--</code> unary operator is nullable.</li>
</ul>

<p>An operand is considered nullable if the type of the operand is <code>null</code> or <code>undefined</code> or a union type that includes <code>null</code> or <code>undefined</code>. Note that the union type case only only occurs in <code>--strictNullChecks</code> mode because <code>null</code> and <code>undefined</code> disappear from unions in classic type checking mode.</p>
    
      <h2 id="dotted-property-for-types-with-string-index-signatures">
        
        
          Dotted property for types with string index signatures <a aria-label="Link to the header: Dotted property for types with string index signatures" title="Link to the header: Dotted property for types with string index signatures" href="#dotted-property-for-types-with-string-index-signatures" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Types with a string index signature can be indexed using the <code>[]</code> notation, but were not allowed to use the <code>.</code>. Starting with TypeScript 2.2 using either should be allowed.</p>

<pre><code class="language-ts">interface StringMap&lt;T&gt; {
    [x: string]: T;
}

const map: StringMap&lt;number&gt;;

map["prop1"] = 1;
map.prop2 = 2;

</code></pre>

<p>This only apply to types with an <em>explicit</em> string index signature. It is still an error to access unknown properties on a type using <code>.</code> notation.</p>
    
      <h2 id="support-for-spread-operator-on-jsx-element-children">
        
        
          Support for spread operator on JSX element children <a aria-label="Link to the header: Support for spread operator on JSX element children" title="Link to the header: Support for spread operator on JSX element children" href="#support-for-spread-operator-on-jsx-element-children" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.2 adds support for using spread on a JSX element children. Please see <a href="https://github.com/facebook/jsx/issues/57">facebook/jsx#57</a> for more details.</p>
    
      <h4 id="example-39">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-39" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">function Todo(prop: { key: number, todo: string }) {
    return &lt;div&gt;{prop.key.toString() + prop.todo}&lt;/div&gt;;
}

function TodoList({ todos }: TodoListProps) {
    return &lt;div&gt;
        {...todos.map(todo =&gt; &lt;Todo key={todo.id} todo={todo.todo} /&gt;)}
    &lt;/div&gt;;
}

let x: TodoListProps;

&lt;TodoList {...x} /&gt;
</code></pre>
    
      <h2 id="new-jsx-react-native">
        
        
          New <code>jsx: react-native</code> <a aria-label="Link to the header: New jsx: react-native" title="Link to the header: New jsx: react-native" href="#new-jsx-react-native" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>React-native build pipeline expects all files to have a <code>.js</code> extensions even if the file contains JSX syntax. The new <code>--jsx</code> value <code>react-native</code> will persevere the JSX syntax in the output file, but give it a <code>.js</code> extension.</p>
    
      <h2 id="typescript-21">
        
        
          TypeScript 2.1 <a aria-label="Link to the header: TypeScript 2.1" title="Link to the header: TypeScript 2.1" href="#typescript-21" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="keyof-and-lookup-types">
        
        
          <code>keyof</code> and Lookup Types <a aria-label="Link to the header: keyof and Lookup Types" title="Link to the header: keyof and Lookup Types" href="#keyof-and-lookup-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn’t been possible to express the type relationships that occur in those APIs.</p>

<p>Enter Index Type Query or <code>keyof</code>;
An indexed type query <code>keyof T</code> yields the type of permitted property names for <code>T</code>.
A <code>keyof T</code> type is considered a subtype of <code>string</code>.</p>
    
      <h5 id="example-40">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-40" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">interface Person {
    name: string;
    age: number;
    location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // "length" | "push" | "pop" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string
</code></pre>

<p>The dual of this is <em>indexed access types</em>, also called <em>lookup types</em>.
Syntactically, they look exactly like an element access, but are written as types:</p>
    
      <h5 id="example-41">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-41" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">type P1 = Person["name"];  // string
type P2 = Person["name" | "age"];  // string | number
type P3 = string["charAt"];  // (pos: number) =&gt; string
type P4 = string[]["push"];  // (...items: string[]) =&gt; number
type P5 = string[][0];  // string
</code></pre>

<p>You can use this pattern with other parts of the type system to get type-safe lookups.</p>

<pre><code class="language-ts">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {
    return obj[key];  // Inferred type is T[K]
}

function setProperty&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]) {
    obj[key] = value;
}

let x = { foo: 10, bar: "hello!" };

let foo = getProperty(x, "foo"); // number
let bar = getProperty(x, "bar"); // string

let oops = getProperty(x, "wargarbl"); // Error! "wargarbl" is not "foo" | "bar"

setProperty(x, "foo", "string"); // Error!, string expected number
</code></pre>
    
      <h2 id="mapped-types">
        
        
          Mapped Types <a aria-label="Link to the header: Mapped Types" title="Link to the header: Mapped Types" href="#mapped-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>One common task is to take an existing type and make each of its properties entirely optional.
Let’s say we have a `Person:</p>

<pre><code class="language-ts">interface Person {
    name: string;
    age: number;
    location: string;
}
</code></pre>

<p>A partial version of it would be:</p>

<pre><code class="language-ts">interface PartialPerson {
    name?: string;
    age?: number;
    location?: string;
}
</code></pre>

<p>with Mapped types, <code>PartialPerson</code> can be written as a generalized transformation on the type <code>Person</code> as:</p>

<pre><code class="language-ts">type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
};

type PartialPerson = Partial&lt;Person&gt;;
</code></pre>

<p>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type.
They’re like <a href="https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions">list comprehensions in Python</a>, but instead of producing new elements in a list, they produce new properties in a type.</p>

<p>In addition to <code>Partial</code>, Mapped Types can express many useful transformations on types:</p>

<pre><code class="language-ts">// Keep types the same, but make each property to be read-only.
type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
};

// Same property names, but make the value a promise instead of a concrete one
type Deferred&lt;T&gt; = {
    [P in keyof T]: Promise&lt;T[P]&gt;;
};

// Wrap proxies around properties of T
type Proxify&lt;T&gt; = {
    [P in keyof T]: { get(): T[P]; set(v: T[P]): void }
};
</code></pre>
    
      <h2 id="partial-readonly-record-and-pick">
        
        
          <code>Partial</code>, <code>Readonly</code>, <code>Record</code>, and <code>Pick</code> <a aria-label="Link to the header: Partial, Readonly, Record, and Pick" title="Link to the header: Partial, Readonly, Record, and Pick" href="#partial-readonly-record-and-pick" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>Partial</code> and <code>Readonly</code>, as described earlier, are very useful constructs.
You can use them to describe some common JS routines like:</p>

<pre><code class="language-ts">function assign&lt;T&gt;(obj: T, props: Partial&lt;T&gt;): void;
function freeze&lt;T&gt;(obj: T): Readonly&lt;T&gt;;
</code></pre>

<p>Because of that, they are now included by default in the standard library.</p>

<p>We’re also including two other utility types as well: <code>Record</code> and <code>Pick</code>.</p>

<pre><code class="language-ts">// From T pick a set of properties K
declare function pick&lt;T, K extends keyof T&gt;(obj: T, ...keys: K[]): Pick&lt;T, K&gt;;

const nameAndAgeOnly = pick(person, "name", "age");  // { name: string, age: number }
</code></pre>

<pre><code class="language-ts">// For every properties K of type T, transform it to U
function mapObject&lt;K extends string, T, U&gt;(obj: Record&lt;K, T&gt;, f: (x: T) =&gt; U): Record&lt;K, U&gt;

const names = { foo: "hello", bar: "world", baz: "bye" };
const lengths = mapObject(names, s =&gt; s.length);  // { foo: number, bar: number, baz: number }
</code></pre>
    
      <h2 id="object-spread-and-rest">
        
        
          Object Spread and Rest <a aria-label="Link to the header: Object Spread and Rest" title="Link to the header: Object Spread and Rest" href="#object-spread-and-rest" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.1 brings support for <a href="https://github.com/sebmarkbage/ecmascript-rest-spread">ES2017 Spread and Rest</a>.</p>

<p>Similar to array spread, spreading an object can be handy to get a shallow copy:</p>

<pre><code class="language-ts">let copy = { ...original };
</code></pre>

<p>Similarly, you can merge several different objects.
In the following example, <code>merged</code> will have properties from <code>foo</code>, <code>bar</code>, and <code>baz</code>.</p>

<pre><code class="language-ts">let merged = { ...foo, ...bar, ...baz };
</code></pre>

<p>You can also override existing properties and add new ones:</p>

<pre><code class="language-ts">let obj = { x: 1, y: "string" };
var newObj = {...obj, z: 3, y: 4}; // { x: number, y: number, z: number }
</code></pre>

<p>The order of specifying spread operations determines what properties end up in the resulting object;
properties in later spreads “win out” over previously created properties.</p>

<p>Object rests are the dual of object spreads, in that they can extract any extra properties that don’t get picked up when destructuring an element:</p>

<pre><code class="language-ts">let obj = { x: 1, y: 1, z: 1 };
let { z, ...obj1 } = obj;
obj1; // {x: number, y: number};
</code></pre>
    
      <h2 id="downlevel-async-functions">
        
        
          Downlevel Async Functions <a aria-label="Link to the header: Downlevel Async Functions" title="Link to the header: Downlevel Async Functions" href="#downlevel-async-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015.
TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you’ll be free to take advantage of it no matter what environment you’re using.</p>

<blockquote>
  <p>Note: first, we need to make sure our run-time has an ECMAScript-compliant <code>Promise</code> available globally.
That might involve grabbing <a href="https://github.com/stefanpenner/es6-promise">a polyfill</a> for <code>Promise</code>, or relying on one that you might have in the run-time that you’re targeting.
We also need to make sure that TypeScript knows <code>Promise</code> exists by setting your <code>lib</code> flag to something like <code>"dom", "es2015"</code> or <code>"dom", "es2015.promise", "es5"</code></p>
</blockquote>
    
      <h5 id="example-42">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-42" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>
    
      <h5 id="tsconfigjson">
        
        
          tsconfig.json <a aria-label="Link to the header: tsconfig.json" title="Link to the header: tsconfig.json" href="#tsconfigjson" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-json">{
    "compilerOptions": {
        "lib": ["dom", "es2015.promise", "es5"]
    }
}
</code></pre>
    
      <h5 id="dramaticwelcomets">
        
        
          dramaticWelcome.ts <a aria-label="Link to the header: dramaticWelcome.ts" title="Link to the header: dramaticWelcome.ts" href="#dramaticwelcomets" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function delay(milliseconds: number) {
    return new Promise&lt;void&gt;(resolve =&gt; {
        setTimeout(resolve, milliseconds);
    });
}

async function dramaticWelcome() {
    console.log("Hello");

    for (let i = 0; i &lt; 3; i++) {
        await delay(500);
        console.log(".");
    }

    console.log("World!");
}

dramaticWelcome();
</code></pre>

<p>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</p>
    
      <h2 id="support-for-external-helpers-library-tslib">
        
        
          Support for external helpers library (<code>tslib</code>) <a aria-label="Link to the header: Support for external helpers library (tslib)" title="Link to the header: Support for external helpers library (tslib)" href="#support-for-external-helpers-library-tslib" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript injects a handful of helper functions such as <code>__extends</code> for inheritance, <code>__assign</code> for spread operator in object literals and JSX elements, and <code>__awaiter</code> for async functions.</p>

<p>Previously there were two options:</p>

<ol>
  <li>inject helpers in <em>every</em> file that needs them, or</li>
  <li>no helpers at all with <code>--noEmitHelpers</code>.</li>
</ol>

<p>The two options left more to be desired;
bundling the helpers in every file was a pain point for customers trying to keep their package size small.
And not including helpers, meant customers had to maintain their own helpers library.</p>

<p>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</p>

<p>First, install the <a href="https://github.com/Microsoft/tslib"><code>tslib</code></a> utility library:</p>

<pre><code class="language-sh">npm install tslib
</code></pre>

<p>Second, compile your files using <code>--importHelpers</code>:</p>

<pre><code class="language-sh">tsc --module commonjs --importHelpers a.ts
</code></pre>

<p>So given the following input, the resulting <code>.js</code> file will include an import to <code>tslib</code> and use the <code>__assign</code> helper from it instead of inlining it.</p>

<pre><code class="language-ts">export const o = { a: 1, name: "o" };
export const copy = { ...o };
</code></pre>

<pre><code class="language-js">"use strict";
var tslib_1 = require("tslib");
exports.o = { a: 1, name: "o" };
exports.copy = tslib_1.__assign({}, exports.o);
</code></pre>
    
      <h2 id="untyped-imports">
        
        
          Untyped imports <a aria-label="Link to the header: Untyped imports" title="Link to the header: Untyped imports" href="#untyped-imports" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript has traditionally been overly strict about how you can import modules.
This was to avoid typos and prevent users from using modules incorrectly.</p>

<p>However, a lot of the time, you might just want to import an existing module that may not have its own <code>.d.ts</code> file.
Previously this was an error.
Starting with TypeScript 2.1 this is now much easier.</p>

<p>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration.
A type declaration (such as <code>declare module "foo" { ... }</code> or <code>node_modules/@types/foo</code>) still takes priority if it exists.</p>

<p>An import to a module with no declaration file will still be flagged as an error under <code>--noImplicitAny</code>.</p>
    
      <h5 id="example-43">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-43" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">// Succeeds if `node_modules/asdf/index.js` exists, or if `node_modules/asdf/package.json` defines a valid "main" entry point
import { x } from "asdf";
</code></pre>
    
      <h2 id="support-for---target-es2016---target-es2017-and---target-esnext">
        
        
          Support for <code>--target ES2016</code>, <code>--target ES2017</code> and <code>--target ESNext</code> <a aria-label="Link to the header: Support for --target ES2016, --target ES2017 and --target ESNext" title="Link to the header: Support for --target ES2016, --target ES2017 and --target ESNext" href="#support-for---target-es2016---target-es2017-and---target-esnext" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.1 supports three new target values <code>--target ES2016</code>, <code>--target ES2017</code> and <code>--target ESNext</code>.</p>

<p>Using target <code>--target ES2016</code> will instruct the compiler not to transform ES2016-specific features, e.g. <code>**</code> operator.</p>

<p>Similarly, <code>--target ES2017</code> will instruct the compiler not to transform ES2017-specific features like <code>async</code>/<code>await</code>.</p>

<p><code>--target ESNext</code> targets latest supported <a href="https://github.com/tc39/proposals">ES proposed features</a>.</p>
    
      <h2 id="improved-any-inference">
        
        
          Improved <code>any</code> Inference <a aria-label="Link to the header: Improved any Inference" title="Link to the header: Improved any Inference" href="#improved-any-inference" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Previously, if TypeScript couldn’t figure out the type of a variable, it would choose the <code>any</code> type.</p>

<pre><code class="language-ts">let x;      // implicitly 'any'
let y = []; // implicitly 'any[]'

let z: any; // explicitly 'any'.
</code></pre>

<p>With TypeScript 2.1, instead of just choosing <code>any</code>, TypeScript will infer types based on what you end up assigning later on.</p>

<p>This is only enabled if <code>--noImplicitAny</code> is set.</p>
    
      <h5 id="example-44">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-44" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">let x;

// You can still assign anything you want to 'x'.
x = () =&gt; 42;

// After that last assignment, TypeScript 2.1 knows that 'x' has type '() =&gt; number'.
let y = x();

// Thanks to that, it will now tell you that you can't add a number to a function!
console.log(x + y);
//          ~~~~~
// Error! Operator '+' cannot be applied to types '() =&gt; number' and 'number'.

// TypeScript still allows you to assign anything you want to 'x'.
x = "Hello world!";

// But now it also knows that 'x' is a 'string'!
x.toLowerCase();
</code></pre>

<p>The same sort of tracking is now also done for empty arrays.</p>

<p>A variable declared with no type annotation and an initial value of <code>[]</code> is considered an implicit <code>any[]</code> variable.
However, each subsequent <code>x.push(value)</code>, <code>x.unshift(value)</code> or <code>x[n] = value</code> operation <em>evolves</em> the type of the variable in accordance with what elements are added to it.</p>

<pre><code class="language-ts">function f1() {
    let x = [];
    x.push(5);
    x[1] = "hello";
    x.unshift(true);
    return x;  // (string | number | boolean)[]
}

function f2() {
    let x = null;
    if (cond()) {
        x = [];
        while (cond()) {
            x.push("hello");
        }
    }
    return x;  // string[] | null
}
</code></pre>
    
      <h2 id="implicit-any-errors">
        
        
          Implicit any errors <a aria-label="Link to the header: Implicit any errors" title="Link to the header: Implicit any errors" href="#implicit-any-errors" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>One great benefit of this is that you’ll see <em>way fewer</em> implicit <code>any</code> errors when running with <code>--noImplicitAny</code>.
Implicit <code>any</code> errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</p>
    
      <h5 id="example-45">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-45" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function f3() {
    let x = [];  // Error: Variable 'x' implicitly has type 'any[]' in some locations where its type cannot be determined.
    x.push(5);
    function g() {
        x;    // Error: Variable 'x' implicitly has an 'any[]' type.
    }
}
</code></pre>
    
      <h2 id="better-inference-for-literal-types">
        
        
          Better inference for literal types <a aria-label="Link to the header: Better inference for literal types" title="Link to the header: Better inference for literal types" href="#better-inference-for-literal-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>String, numeric and boolean literal types (e.g. <code>"abc"</code>, <code>1</code>, and <code>true</code>) were previously inferred only in the presence of an explicit type annotation.
Starting with TypeScript 2.1, literal types are <em>always</em> inferred for <code>const</code> variables and <code>readonly</code> properties.</p>

<p>The type inferred for a <code>const</code> variable or <code>readonly</code> property without a type annotation is the type of the literal initializer.
The type inferred for a <code>let</code> variable, <code>var</code> variable, parameter, or non-<code>readonly</code> property with an initializer and no type annotation is the widened literal type of the initializer.
Where the widened type for a string literal type is <code>string</code>, <code>number</code> for numeric literal types, <code>boolean</code> for <code>true</code> or <code>false</code> and the containing enum for enum literal types.</p>
    
      <h5 id="example-46">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-46" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">const c1 = 1;  // Type 1
const c2 = c1;  // Type 1
const c3 = "abc";  // Type "abc"
const c4 = true;  // Type true
const c5 = cond ? 1 : "abc";  // Type 1 | "abc"

let v1 = 1;  // Type number
let v2 = c2;  // Type number
let v3 = c3;  // Type string
let v4 = c4;  // Type boolean
let v5 = c5;  // Type number | string
</code></pre>

<p>Literal type widening can be controlled through explicit type annotations.
Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that <code>const</code> variable gets a widening literal type inferred.
But when a <code>const</code> location has an explicit literal type annotation, the <code>const</code> variable gets a non-widening literal type.</p>
    
      <h5 id="example-47">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-47" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">const c1 = "hello";  // Widening type "hello"
let v1 = c1;  // Type string

const c2: "hello" = "hello";  // Type "hello"
let v2 = c2;  // Type "hello"
</code></pre>
    
      <h2 id="use-returned-values-from-super-calls-as-this">
        
        
          Use returned values from super calls as ‘this’ <a aria-label="Link to the header: Use returned values from super calls as ‘this’" title="Link to the header: Use returned values from super calls as ‘this’" href="#use-returned-values-from-super-calls-as-this" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In ES2015, constructors which return an object implicitly substitute the value of <code>this</code> for any callers of <code>super()</code>.
As a result, it is necessary to capture any potential return value of <code>super()</code> and replace it with <code>this</code>.
This change enables working with <a href="https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor">Custom Elements</a>, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</p>
    
      <h5 id="example-48">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-48" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">class Base {
    x: number;
    constructor() {
        // return a new object other than `this`
        return {
            x: 1,
        };
    }
}

class Derived extends Base {
    constructor() {
        super();
        this.x = 2;
    }
}
</code></pre>

<p>Generates:</p>

<pre><code class="language-js">var Derived = (function (_super) {
    __extends(Derived, _super);
    function Derived() {
        var _this = _super.call(this) || this;
        _this.x = 2;
        return _this;
    }
    return Derived;
}(Base));
</code></pre>

<blockquote>
  <p>This change entails a break in the behavior of extending built-in classes like <code>Error</code>, <code>Array</code>, <code>Map</code>, etc.. Please see the <a href="https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work">extending built-ins breaking change documentation</a> for more details.</p>
</blockquote>
    
      <h2 id="configuration-inheritance">
        
        
          Configuration inheritance <a aria-label="Link to the header: Configuration inheritance" title="Link to the header: Configuration inheritance" href="#configuration-inheritance" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Often a project has multiple output targets, e.g. <code>ES5</code> and <code>ES2015</code>, debug and production or <code>CommonJS</code> and <code>System</code>;
Just a few configuration options change between these two targets, and maintaining multiple <code>tsconfig.json</code> files can be a hassle.</p>

<p>TypeScript 2.1 supports inheriting configuration using <code>extends</code>, where:</p>

<ul>
  <li><code>extends</code> is a new top-level property in <code>tsconfig.json</code> (alongside <code>compilerOptions</code>, <code>files</code>, <code>include</code>, and <code>exclude</code>).</li>
  <li>The value of <code>extends</code> must be a string containing a path to another configuration file to inherit from.</li>
  <li>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</li>
  <li>Circularity between configuration files is not allowed.</li>
  <li><code>files</code>, <code>include</code> and <code>exclude</code> from the inheriting config file <em>overwrite</em> those from the base config file.</li>
  <li>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</li>
</ul>
    
      <h5 id="example-49">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-49" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p><code>configs/base.json</code>:</p>

<pre><code class="language-json">{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
</code></pre>

<p><code>tsconfig.json</code>:</p>

<pre><code class="language-json">{
  "extends": "./configs/base",
  "files": [
    "main.ts",
    "supplemental.ts"
  ]
}
</code></pre>

<p><code>tsconfig.nostrictnull.json</code>:</p>

<pre><code class="language-json">{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
</code></pre>
    
      <h2 id="new---alwaysstrict">
        
        
          New <code>--alwaysStrict</code> <a aria-label="Link to the header: New --alwaysStrict" title="Link to the header: New --alwaysStrict" href="#new---alwaysstrict" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Invoking the compiler with <code>--alwaysStrict</code> causes:</p>

<ol>
  <li>Parses all the code in strict mode.</li>
  <li>Writes <code>"use strict";</code> directive atop every generated file.</li>
</ol>

<p>Modules are parsed automatically in strict mode.
The new flag is recommended for non-module code.</p>
    
      <h2 id="typescript-20">
        
        
          TypeScript 2.0 <a aria-label="Link to the header: TypeScript 2.0" title="Link to the header: TypeScript 2.0" href="#typescript-20" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="null--and-undefined-aware-types">
        
        
          Null- and undefined-aware types <a aria-label="Link to the header: Null- and undefined-aware types" title="Link to the header: Null- and undefined-aware types" href="#null--and-undefined-aware-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript has two special types, Null and Undefined, that have the values <code>null</code> and <code>undefined</code> respectively.
Previously it was not possible to explicitly name these types, but <code>null</code> and <code>undefined</code> may now be used as type names regardless of type checking mode.</p>

<p>The type checker previously considered <code>null</code> and <code>undefined</code> assignable to anything.
Effectively, <code>null</code> and <code>undefined</code> were valid values of <em>every</em> type and it wasn’t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</p>
    
      <h3 id="--strictnullchecks">
        
        
          <code>--strictNullChecks</code> <a aria-label="Link to the header: --strictNullChecks" title="Link to the header: --strictNullChecks" href="#--strictnullchecks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p><code>--strictNullChecks</code> switches to a new strict null checking mode.</p>

<p>In strict null checking mode, the <code>null</code> and <code>undefined</code> values are <em>not</em> in the domain of every type and are only assignable to themselves and <code>any</code> (the one exception being that <code>undefined</code> is also assignable to <code>void</code>).
So, whereas <code>T</code> and <code>T | undefined</code> are considered synonymous in regular type checking mode (because <code>undefined</code> is considered a subtype of any <code>T</code>), they are different types in strict type checking mode, and only <code>T | undefined</code> permits <code>undefined</code> values. The same is true for the relationship of <code>T</code> to <code>T | null</code>.</p>
    
      <h4 id="example-50">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-50" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// Compiled with --strictNullChecks
let x: number;
let y: number | undefined;
let z: number | null | undefined;
x = 1;  // Ok
y = 1;  // Ok
z = 1;  // Ok
x = undefined;  // Error
y = undefined;  // Ok
z = undefined;  // Ok
x = null;  // Error
y = null;  // Error
z = null;  // Ok
x = y;  // Error
x = z;  // Error
y = x;  // Ok
y = z;  // Error
z = x;  // Ok
z = y;  // Ok
</code></pre>
    
      <h3 id="assigned-before-use-checking">
        
        
          Assigned-before-use checking <a aria-label="Link to the header: Assigned-before-use checking" title="Link to the header: Assigned-before-use checking" href="#assigned-before-use-checking" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn’t include <code>undefined</code> to be preceded by an assignment to that variable in every possible preceding code path.</p>
    
      <h4 id="example-51">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-51" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// Compiled with --strictNullChecks
let x: number;
let y: number | null;
let z: number | undefined;
x;  // Error, reference not preceded by assignment
y;  // Error, reference not preceded by assignment
z;  // Ok
x = 1;
y = null;
x;  // Ok
y;  // Ok
</code></pre>

<p>The compiler checks that variables are definitely assigned by performing <em>control flow based type analysis</em>. See later for further details on this topic.</p>
    
      <h3 id="optional-parameters-and-properties">
        
        
          Optional parameters and properties <a aria-label="Link to the header: Optional parameters and properties" title="Link to the header: Optional parameters and properties" href="#optional-parameters-and-properties" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Optional parameters and properties automatically have <code>undefined</code> added to their types, even when their type annotations don’t specifically include <code>undefined</code>.
For example, the following two types are identical:</p>

<pre><code class="language-ts">// Compiled with --strictNullChecks
type T1 = (x?: number) =&gt; string;              // x has type number | undefined
type T2 = (x?: number | undefined) =&gt; string;  // x has type number | undefined
</code></pre>
    
      <h3 id="non-null-and-non-undefined-type-guards">
        
        
          Non-null and non-undefined type guards <a aria-label="Link to the header: Non-null and non-undefined type guards" title="Link to the header: Non-null and non-undefined type guards" href="#non-null-and-non-undefined-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>A property access or a function call produces a compile-time error if the object or function is of a type that includes <code>null</code> or <code>undefined</code>.
However, type guards are extended to support non-null and non-undefined checks.</p>
    
      <h4 id="example-52">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-52" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">// Compiled with --strictNullChecks
declare function f(x: number): string;
let x: number | null | undefined;
if (x) {
    f(x);  // Ok, type of x is number here
}
else {
    f(x);  // Error, type of x is number? here
}
let a = x != null ? f(x) : "";  // Type of a is string
let b = x &amp;&amp; f(x);  // Type of b is string | 0 | null | undefined
</code></pre>

<p>Non-null and non-undefined type guards may use the <code>==</code>, <code>!=</code>, <code>===</code>, or <code>!==</code> operator to compare to <code>null</code> or <code>undefined</code>, as in <code>x != null</code> or <code>x === undefined</code>.
The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</p>
    
      <h3 id="dotted-names-in-type-guards">
        
        
          Dotted names in type guards <a aria-label="Link to the header: Dotted names in type guards" title="Link to the header: Dotted names in type guards" href="#dotted-names-in-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Type guards previously only supported checking local variables and parameters.
Type guards now support checking “dotted names” consisting of a variable or parameter name followed one or more property accesses.</p>
    
      <h4 id="example-53">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-53" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface Options {
    location?: {
        x?: number;
        y?: number;
    };
}

function foo(options?: Options) {
    if (options &amp;&amp; options.location &amp;&amp; options.location.x) {
        const x = options.location.x;  // Type of x is number
    }
}
</code></pre>

<p>Type guards for dotted names also work with user defined type guard functions and the <code>typeof</code> and <code>instanceof</code> operators and do not depend on the <code>--strictNullChecks</code> compiler option.</p>

<p>A type guard for a dotted name has no effect following an assignment to any part of the dotted name.
For example, a type guard for <code>x.y.z</code> will have no effect following an assignment to <code>x</code>, <code>x.y</code>, or <code>x.y.z</code>.</p>
    
      <h3 id="expression-operators">
        
        
          Expression operators <a aria-label="Link to the header: Expression operators" title="Link to the header: Expression operators" href="#expression-operators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Expression operators permit operand types to include <code>null</code> and/or <code>undefined</code> but always produce values of non-null and non-undefined types.</p>

<pre><code class="language-ts">// Compiled with --strictNullChecks
function sum(a: number | null, b: number | null) {
    return a + b;  // Produces value of type number
}
</code></pre>

<p>The <code>&amp;&amp;</code> operator adds <code>null</code> and/or <code>undefined</code> to the type of the right operand depending on which are present in the type of the left operand, and the <code>||</code> operator removes both <code>null</code> and <code>undefined</code> from the type of the left operand in the resulting union type.</p>

<pre><code class="language-ts">// Compiled with --strictNullChecks
interface Entity {
    name: string;
}
let x: Entity | null;
let s = x &amp;&amp; x.name;  // s is of type string | null
let y = x || { name: "test" };  // y is of type Entity
</code></pre>
    
      <h3 id="type-widening">
        
        
          Type widening <a aria-label="Link to the header: Type widening" title="Link to the header: Type widening" href="#type-widening" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The <code>null</code> and <code>undefined</code> types are <em>not</em> widened to <code>any</code> in strict null checking mode.</p>

<pre><code class="language-ts">let z = null;  // Type of z is null
</code></pre>

<p>In regular type checking mode the inferred type of <code>z</code> is <code>any</code> because of widening, but in strict null checking mode the inferred type of <code>z</code> is <code>null</code> (and therefore, absent a type annotation, <code>null</code> is the only possible value for <code>z</code>).</p>
    
      <h3 id="non-null-assertion-operator">
        
        
          Non-null assertion operator <a aria-label="Link to the header: Non-null assertion operator" title="Link to the header: Non-null assertion operator" href="#non-null-assertion-operator" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>A new <code>!</code> post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact.
Specifically, the operation <code>x!</code> produces a value of the type of <code>x</code> with <code>null</code> and <code>undefined</code> excluded.
Similar to type assertions of the forms <code>&lt;T&gt;x</code> and <code>x as T</code>, the <code>!</code> non-null assertion operator is simply removed in the emitted JavaScript code.</p>

<pre><code class="language-ts">// Compiled with --strictNullChecks
function validateEntity(e?: Entity) {
    // Throw exception if e is null or invalid entity
}

function processEntity(e?: Entity) {
    validateEntity(e);
    let s = e!.name;  // Assert that e is non-null and access name
}
</code></pre>
    
      <h3 id="compatibility">
        
        
          Compatibility <a aria-label="Link to the header: Compatibility" title="Link to the header: Compatibility" href="#compatibility" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode.
In particular, the <code>null</code> and <code>undefined</code> types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the <code>!</code> non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</p>

<p>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</p>
    
      <h2 id="control-flow-based-type-analysis">
        
        
          Control flow based type analysis <a aria-label="Link to the header: Control flow based type analysis" title="Link to the header: Control flow based type analysis" href="#control-flow-based-type-analysis" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters.
Previously, the type analysis performed for type guards was limited to <code>if</code> statements and <code>?:</code> conditional expressions and didn’t include effects of assignments and control flow constructs such as <code>return</code> and <code>break</code> statements.
With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the <em>narrowed type</em>) at any given location for a local variable or parameter that is declared to have a union type.</p>
    
      <h4 id="example-54">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-54" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">function foo(x: string | number | boolean) {
    if (typeof x === "string") {
        x; // type of x is string here
        x = 1;
        x; // type of x is number here
    }
    x; // type of x is number | boolean here
}

function bar(x: string | number) {
    if (typeof x === "number") {
        return;
    }
    x; // type of x is string here
}
</code></pre>

<p>Control flow based type analysis is particuarly relevant in <code>--strictNullChecks</code> mode because nullable types are represented using union types:</p>

<pre><code class="language-ts">function test(x: string | null) {
    if (x === null) {
        return;
    }
    x; // type of x is string in remainder of function
}
</code></pre>

<p>Furthermore, in <code>--strictNullChecks</code> mode, control flow based type analysis includes <em>definite assignment analysis</em> for local variables of types that don’t permit the value <code>undefined</code>.</p>

<pre><code class="language-ts">function mumble(check: boolean) {
    let x: number; // Type doesn't permit undefined
    x; // Error, x is undefined
    if (check) {
        x = 1;
        x; // Ok
    }
    x; // Error, x is possibly undefined
    x = 2;
    x; // Ok
}
</code></pre>
    
      <h2 id="tagged-union-types">
        
        
          Tagged union types <a aria-label="Link to the header: Tagged union types" title="Link to the header: Tagged union types" href="#tagged-union-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 implements support for tagged (or discriminated) union types.
Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to <code>switch</code> statements.</p>
    
      <h4 id="example-55">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-55" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
    // In the following switch statement, the type of s is narrowed in each case clause
    // according to the value of the discriminant property, thus allowing the other properties
    // of that variant to be accessed without a type assertion.
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius * s.radius;
    }
}

function test1(s: Shape) {
    if (s.kind === "square") {
        s;  // Square
    }
    else {
        s;  // Rectangle | Circle
    }
}

function test2(s: Shape) {
    if (s.kind === "square" || s.kind === "rectangle") {
        return;
    }
    s;  // Circle
}
</code></pre>

<p>A <em>discriminant property type guard</em> is an expression of the form <code>x.p == v</code>, <code>x.p === v</code>, <code>x.p != v</code>, or <code>x.p !== v</code>, where <code>p</code> and <code>v</code> are a property and an expression of a string literal type or a union of string literal types.
The discriminant property type guard narrows the type of <code>x</code> to those constituent types of <code>x</code> that have a discriminant property <code>p</code> with one of the possible values of <code>v</code>.</p>

<p>Note that we currently only support discriminant properties of string literal types.
We intend to later add support for boolean and numeric literal types.</p>
    
      <h2 id="the-never-type">
        
        
          The <code>never</code> type <a aria-label="Link to the header: The never type" title="Link to the header: The never type" href="#the-never-type" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 introduces a new primitive type <code>never</code>.
The <code>never</code> type represents the type of values that never occur.
Specifically, <code>never</code> is the return type for functions that never return and <code>never</code> is the type of variables under type guards that are never true.</p>

<p>The <code>never</code> type has the following characteristics:</p>

<ul>
  <li><code>never</code> is a subtype of and assignable to every type.</li>
  <li>No type is a subtype of or assignable to <code>never</code> (except <code>never</code> itself).</li>
  <li>In a function expression or arrow function with no return type annotation, if the function has no <code>return</code> statements, or only <code>return</code> statements with expressions of type <code>never</code>, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is <code>never</code>.</li>
  <li>In a function with an explicit <code>never</code> return type annotation, all <code>return</code> statements (if any) must have expressions of type <code>never</code> and the end point of the function must not be reachable.</li>
</ul>

<p>Because <code>never</code> is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</p>

<p>Some examples of functions returning <code>never</code>:</p>

<pre><code class="language-ts">// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error("Something failed");
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre>

<p>Some examples of use of functions returning <code>never</code>:</p>

<pre><code class="language-ts">// Inferred return type is number
function move1(direction: "up" | "down") {
    switch (direction) {
        case "up":
            return 1;
        case "down":
            return -1;
    }
    return error("Should never get here");
}

// Inferred return type is number
function move2(direction: "up" | "down") {
    return direction === "up" ? 1 :
        direction === "down" ? -1 :
        error("Should never get here");
}

// Inferred return type is T
function check&lt;T&gt;(x: T | undefined) {
    return x || error("Undefined value");
}
</code></pre>

<p>Because <code>never</code> is assignable to every type, a function returning <code>never</code> can be used when a callback returning a more specific type is required:</p>

<pre><code class="language-ts">function test(cb: () =&gt; string) {
    let s = cb();
    return s;
}

test(() =&gt; "hello");
test(() =&gt; fail());
test(() =&gt; { throw new Error(); })
</code></pre>
    
      <h2 id="read-only-properties-and-index-signatures">
        
        
          Read-only properties and index signatures <a aria-label="Link to the header: Read-only properties and index signatures" title="Link to the header: Read-only properties and index signatures" href="#read-only-properties-and-index-signatures" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>A property or index signature can now be declared with the <code>readonly</code> modifier is considered read-only.</p>

<p>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</p>

<p>In addition, entities are <em>implicitly</em> read-only in several situations:</p>

<ul>
  <li>A property declared with a <code>get</code> accessor and no <code>set</code> accessor is considered read-only.</li>
  <li>In the type of an enum object, enum members are considered read-only properties.</li>
  <li>In the type of a module object, exported <code>const</code> variables are considered read-only properties.</li>
  <li>An entity declared in an <code>import</code> statement is considered read-only.</li>
  <li>An entity accessed through an ES2015 namespace import is considered read-only (e.g. <code>foo.x</code> is read-only when <code>foo</code> is declared as <code>import * as foo from "foo"</code>).</li>
</ul>
    
      <h4 id="example-56">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-56" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface Point {
    readonly x: number;
    readonly y: number;
}

var p1: Point = { x: 10, y: 20 };
p1.x = 5;  // Error, p1.x is read-only

var p2 = { x: 1, y: 1 };
var p3: Point = p2;  // Ok, read-only alias for p2
p3.x = 5;  // Error, p3.x is read-only
p2.x = 5;  // Ok, but also changes p3.x because of aliasing
</code></pre>

<pre><code class="language-ts">class Foo {
    readonly a = 1;
    readonly b: string;
    constructor() {
        this.b = "hello";  // Assignment permitted in constructor
    }
}
</code></pre>

<pre><code class="language-ts">let a: Array&lt;number&gt; = [0, 1, 2, 3, 4];
let b: ReadonlyArray&lt;number&gt; = a;
b[5] = 5;      // Error, elements are read-only
b.push(5);     // Error, no push method (because it mutates array)
b.length = 3;  // Error, length is read-only
a = b;         // Error, mutating methods are missing
</code></pre>
    
      <h2 id="specifying-the-type-of-this-for-functions">
        
        
          Specifying the type of <code>this</code> for functions <a aria-label="Link to the header: Specifying the type of this for functions" title="Link to the header: Specifying the type of this for functions" href="#specifying-the-type-of-this-for-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Following up on specifying the type of <code>this</code> in a class or an interface, functions and methods can now declare the type of <code>this</code> they expect.</p>

<p>By default the type of <code>this</code> inside a function is <code>any</code>.
Starting with TypeScript 2.0, you can provide an explicit <code>this</code> parameter.
<code>this</code> parameters are fake parameters that come first in the parameter list of a function:</p>

<pre><code class="language-ts">function f(this: void) {
    // make sure `this` is unusable in this standalone function
}
</code></pre>
    
      <h3 id="this-parameters-in-callbacks">
        
        
          <code>this</code> parameters in callbacks <a aria-label="Link to the header: this parameters in callbacks" title="Link to the header: this parameters in callbacks" href="#this-parameters-in-callbacks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Libraries can also use <code>this</code> parameters to declare how callbacks will be invoked.</p>
    
      <h4 id="example-57">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-57" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface UIElement {
    addClickListener(onclick: (this: void, e: Event) =&gt; void): void;
}
</code></pre>

<p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type.</p>

<p>Now if you annotate calling code with <code>this</code>:</p>

<pre><code class="language-ts">class Handler {
    info: string;
    onClickBad(this: Handler, e: Event) {
        // oops, used this here. using this callback would crash at runtime
        this.info = e.message;
    };
}
let h = new Handler();
uiElement.addClickListener(h.onClickBad); // error!
</code></pre>
    
      <h3 id="--noimplicitthis">
        
        
          <code>--noImplicitThis</code> <a aria-label="Link to the header: --noImplicitThis" title="Link to the header: --noImplicitThis" href="#--noimplicitthis" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>A new flag is also added in TypeScript 2.0 to flag all uses of <code>this</code> in functions without an explicit type annotation.</p>
    
      <h2 id="glob-support-in-tsconfigjson">
        
        
          Glob support in <code>tsconfig.json</code> <a aria-label="Link to the header: Glob support in tsconfig.json" title="Link to the header: Glob support in tsconfig.json" href="#glob-support-in-tsconfigjson" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Glob support is here!! Glob support has been <a href="https://github.com/Microsoft/TypeScript/issues/1927">one of the most requested features</a>.</p>

<p>Glob-like file patterns are supported two properties <code>"include"</code> and <code>"exclude"</code>.</p>
    
      <h4 id="example-58">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-58" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-json">{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "removeComments": true,
        "preserveConstEnums": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}
</code></pre>

<p>The supported glob wildcards are:</p>

<ul>
  <li><code>*</code> matches zero or more characters (excluding directory separators)</li>
  <li><code>?</code> matches any one character (excluding directory separators)</li>
  <li><code>**/</code> recursively matches any subdirectory</li>
</ul>

<p>If a segment of a glob pattern includes only <code>*</code> or <code>.*</code>, then only files with supported extensions are included (e.g. <code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code> by default with <code>.js</code> and <code>.jsx</code> if <code>allowJs</code> is set to true).</p>

<p>If the <code>"files"</code> and <code>"include"</code> are both left unspecified, the compiler defaults to including all TypeScript (<code>.ts</code>, <code>.d.ts</code> and <code>.tsx</code>) files in the containing directory and subdirectories except those excluded using the <code>"exclude"</code> property. JS files (<code>.js</code> and <code>.jsx</code>) are also included if <code>allowJs</code> is set to true.</p>

<p>If the <code>"files"</code> or <code>"include"</code> properties are specified, the compiler will instead include the union of the files included by those two properties.
Files in the directory specified using the <code>"outDir"</code> compiler option are always excluded unless explicitly included via the <code>"files"</code> property (even when the “<code>exclude</code>” property is specified).</p>

<p>Files included using <code>"include"</code> can be filtered using the <code>"exclude"</code> property.
However, files included explicitly using the <code>"files"</code> property are always included regardless of <code>"exclude"</code>.
The <code>"exclude"</code> property defaults to excluding the <code>node_modules</code>, <code>bower_components</code>, and <code>jspm_packages</code> directories when not specified.</p>
    
      <h2 id="module-resolution-enhancements-baseurl-path-mapping-rootdirs-and-tracing">
        
        
          Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing <a aria-label="Link to the header: Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing" title="Link to the header: Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing" href="#module-resolution-enhancements-baseurl-path-mapping-rootdirs-and-tracing" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 provides a set of additional module resolution knops to <em>inform</em> the compiler where to find declarations for a given module.</p>

<p>See <a href="http://www.typescriptlang.org/docs/handbook/module-resolution.html">Module Resolution</a> documentation for more details.</p>
    
      <h3 id="base-url">
        
        
          Base URL <a aria-label="Link to the header: Base URL" title="Link to the header: Base URL" href="#base-url" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Using a <code>baseUrl</code> is a common practice in applications using AMD module loaders where modules are “deployed” to a single folder at run-time.
All module imports with non-relative names are assumed to be relative to the <code>baseUrl</code>.</p>
    
      <h4 id="example-59">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-59" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-json">{
  "compilerOptions": {
    "baseUrl": "./modules"
  }
}
</code></pre>

<p>Now imports to <code>"moduleA"</code> would be looked up in <code>./modules/moduleA</code></p>

<pre><code class="language-ts">import A from "moduleA";
</code></pre>
    
      <h3 id="path-mapping">
        
        
          Path mapping <a aria-label="Link to the header: Path mapping" title="Link to the header: Path mapping" href="#path-mapping" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Sometimes modules are not directly located under <em>baseUrl</em>.
Loaders use a mapping configuration to map module names to files at run-time, see <a href="http://requirejs.org/docs/api.html#config-paths">RequireJs documentation</a> and <a href="https://github.com/systemjs/systemjs/blob/master/docs/overview.md#map-config">SystemJS documentation</a>.</p>

<p>The TypeScript compiler supports the declaration of such mappings using <code>"paths"</code> property in <code>tsconfig.json</code> files.</p>
    
      <h4 id="example-60">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-60" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>For instance, an import to a module <code>"jquery"</code> would be translated at runtime to <code>"node_modules/jquery/dist/jquery.slim.min.js"</code>.</p>

<pre><code class="language-json">{
  "compilerOptions": {
    "baseUrl": "./node_modules",
    "paths": {
      "jquery": ["jquery/dist/jquery.slim.min"]
    }
}
</code></pre>

<p>Using <code>"paths"</code> also allow for more sophisticated mappings including multiple fall back locations.
Consider a project configuration where only some modules are available in one location, and the rest are in another.</p>
    
      <h3 id="virtual-directories-with-rootdirs">
        
        
          Virtual Directories with <code>rootDirs</code> <a aria-label="Link to the header: Virtual Directories with rootDirs" title="Link to the header: Virtual Directories with rootDirs" href="#virtual-directories-with-rootdirs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Using ‘rootDirs’, you can inform the compiler of the <em>roots</em> making up this “virtual” directory;
and thus the compiler can resolve relative modules imports within these “virtual” directories <em>as if</em> were merged together in one directory.</p>
    
      <h4 id="example-61">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-61" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Given this project structure:</p>

<pre><code class="language-tree"> src
 └── views
     └── view1.ts (imports './template1')
     └── view2.ts

 generated
 └── templates
         └── views
             └── template1.ts (imports './view2')
</code></pre>

<p>A build step will copy the files in <code>/src/views</code> and <code>/generated/templates/views</code> to the same directory in the output.
At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as <code>"./template"</code>.</p>

<p><code>"rootDirs"</code> specify a list of <em>roots</em> whose contents are expected to merge at run-time.
So following our example, the <code>tsconfig.json</code> file should look like:</p>

<pre><code class="language-json">{
  "compilerOptions": {
    "rootDirs": [
      "src/views",
      "generated/templates/views"
    ]
  }
}
</code></pre>
    
      <h3 id="tracing-module-resolution">
        
        
          Tracing module resolution <a aria-label="Link to the header: Tracing module resolution" title="Link to the header: Tracing module resolution" href="#tracing-module-resolution" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p><code>--traceResolution</code> offers a handy way to understand how modules have been resolved by the compiler.</p>

<pre><code class="language-shell">tsc --traceResolution
</code></pre>
    
      <h2 id="shorthand-ambient-module-declarations">
        
        
          Shorthand ambient module declarations <a aria-label="Link to the header: Shorthand ambient module declarations" title="Link to the header: Shorthand ambient module declarations" href="#shorthand-ambient-module-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>If you don’t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</p>
    
      <h4 id="declarationsdts">
        
        
          declarations.d.ts <a aria-label="Link to the header: declarations.d.ts" title="Link to the header: declarations.d.ts" href="#declarationsdts" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>
<pre><code class="language-ts">declare module "hot-new-module";
</code></pre>

<p>All imports from a shorthand module will have the any type.</p>

<pre><code class="language-ts">import x, {y} from "hot-new-module";
x(y);
</code></pre>
    
      <h2 id="wildcard-character-in-module-names">
        
        
          Wildcard character in module names <a aria-label="Link to the header: Wildcard character in module names" title="Link to the header: Wildcard character in module names" href="#wildcard-character-in-module-names" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Importing none-code resources using module loaders extension (e.g. <a href="https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md">AMD</a> or <a href="https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.md">SystemJS</a>) has not been easy before;
previously an ambient module declaration had to be defined for each resource.</p>

<p>TypeScript 2.0 supports the use of the wildcard character (<code>*</code>) to declare a “family” of module names;
this way, a declaration is only required once for an extension, and not for every resource.</p>
    
      <h4 id="example-62">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-62" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">declare module "*!text" {
    const content: string;
    export default content;
}
// Some do it the other way around.
declare module "json!*" {
    const value: any;
    export default value;
}
</code></pre>

<p>Now you can import things that match <code>"*!text"</code> or <code>"json!*"</code>.</p>

<pre><code class="language-ts">import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";
console.log(data, fileContent);
</code></pre>

<p>Wildcard module names can be even more useful when migrating from an un-typed code base.
Combined with Shorthand ambient module declarations, a set of modules can be easily declared as <code>any</code>.</p>
    
      <h4 id="example-63">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-63" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">declare module "myLibrary/*";
</code></pre>

<p>All imports to any module under <code>myLibrary</code> would be considered to have the type <code>any</code> by the compiler;
thus, shutting down any checking on the shapes or types of these modules.</p>

<pre><code class="language-ts">import { readFile } from "myLibrary/fileSystem/readFile";

readFile(); // readFile is 'any'
</code></pre>
    
      <h2 id="support-for-umd-module-definitions">
        
        
          Support for UMD module definitions <a aria-label="Link to the header: Support for UMD module definitions" title="Link to the header: Support for UMD module definitions" href="#support-for-umd-module-definitions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Some libraries are designed to be used in many module loaders, or with no module loading (global variables).
These are known as <a href="https://github.com/umdjs/umd">UMD</a> or <a href="http://isomorphic.net">Isomorphic</a> modules.
These libraries can be accessed through either an import or a global variable.</p>

<p>For example:</p>
    
      <h5 id="math-libdts">
        
        
          math-lib.d.ts <a aria-label="Link to the header: math-lib.d.ts" title="Link to the header: math-lib.d.ts" href="#math-libdts" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">export const isPrime(x: number): boolean;
export as namespace mathLib;
</code></pre>

<p>The library can then be used as an import within modules:</p>

<pre><code class="language-ts">import { isPrime } from "math-lib";
isPrime(2);
mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module
</code></pre>

<p>It can also be used as a global variable, but only inside of a script.
(A script is a file with no imports or exports.)</p>

<pre><code class="language-ts">mathLib.isPrime(2);
</code></pre>
    
      <h2 id="optional-class-properties">
        
        
          Optional class properties <a aria-label="Link to the header: Optional class properties" title="Link to the header: Optional class properties" href="#optional-class-properties" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</p>
    
      <h4 id="example-64">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-64" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">class Bar {
    a: number;
    b?: number;
    f() {
        return 1;
    }
    g?(): number;  // Body of optional method can be omitted
    h?() {
        return 2;
    }
}
</code></pre>

<p>When compiled in <code>--strictNullChecks</code> mode, optional properties and methods automatically have <code>undefined</code> included in their type. Thus, the <code>b</code> property above is of type <code>number | undefined</code> and the <code>g</code> method above is of type <code>(() =&gt; number) | undefined</code>.
Type guards can be used to strip away the <code>undefined</code> part of the type:</p>

<pre><code class="language-ts">function test(x: Bar) {
    x.a;  // number
    x.b;  // number | undefined
    x.f;  // () =&gt; number
    x.g;  // (() =&gt; number) | undefined
    let f1 = x.f();            // number
    let g1 = x.g &amp;&amp; x.g();     // number | undefined
    let g2 = x.g ? x.g() : 0;  // number
}
</code></pre>
    
      <h2 id="private-and-protected-constructors">
        
        
          Private and Protected Constructors <a aria-label="Link to the header: Private and Protected Constructors" title="Link to the header: Private and Protected Constructors" href="#private-and-protected-constructors" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>A class constructor may be marked <code>private</code> or <code>protected</code>.
A class with private constructor cannot be instantiated outside the class body, and cannot be extended.
A class with protected constructor cannot be instantiated outside the class body, but can be extended.</p>
    
      <h4 id="example-65">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-65" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">class Singleton {
    private static instance: Singleton;

    private constructor() { }

    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}

let e = new Singleton(); // Error: constructor of 'Singleton' is private.
let v = Singleton.getInstance();
</code></pre>
    
      <h2 id="abstract-properties-and-accessors">
        
        
          Abstract properties and accessors <a aria-label="Link to the header: Abstract properties and accessors" title="Link to the header: Abstract properties and accessors" href="#abstract-properties-and-accessors" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>An abstract class can declare abstract properties and/or accessors.
Any sub class will need to declare the abstract properties or be marked as abstract.
Abstract properties cannot have an initializer.
Abstract accessors cannot have bodies.</p>
    
      <h4 id="example-66">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-66" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">abstract class Base {
    abstract name: string;
    abstract get value();
    abstract set value(v: number);
}

class Derived extends Base {
    name = "derived";

    value = 1;
}
</code></pre>
    
      <h2 id="implicit-index-signatures">
        
        
          Implicit index signatures <a aria-label="Link to the header: Implicit index signatures" title="Link to the header: Implicit index signatures" href="#implicit-index-signatures" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</p>

<pre><code class="language-ts">function httpService(path: string, headers: { [x: string]: string }) { }

const headers = {
    "Content-Type": "application/x-www-form-urlencoded"
};

httpService("", { "Content-Type": "application/x-www-form-urlencoded" });  // Ok
httpService("", headers);  // Now ok, previously wasn't
</code></pre>
    
      <h2 id="including-built-in-type-declarations-with---lib">
        
        
          Including built-in type declarations with <code>--lib</code> <a aria-label="Link to the header: Including built-in type declarations with --lib" title="Link to the header: Including built-in type declarations with --lib" href="#including-built-in-type-declarations-with---lib" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Getting to ES6/ES2015 built-in API declarations were only limited to <code>target: ES6</code>.
Enter <code>--lib</code>; with <code>--lib</code> you can specify a list of built-in API declaration groups that you can chose to include in your project.
For instance, if you expect your runtime to have support for <code>Map</code>, <code>Set</code> and <code>Promise</code> (e.g. most evergreen browsers today), just include <code>--lib es2015.collection,es2015.promise</code>.
Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using <code>--lib es5,es6</code>.</p>

<p>Here is a list of available API groups:</p>

<ul>
  <li>dom</li>
  <li>webworker</li>
  <li>es5</li>
  <li>es6 / es2015</li>
  <li>es2015.core</li>
  <li>es2015.collection</li>
  <li>es2015.iterable</li>
  <li>es2015.promise</li>
  <li>es2015.proxy</li>
  <li>es2015.reflect</li>
  <li>es2015.generator</li>
  <li>es2015.symbol</li>
  <li>es2015.symbol.wellknown</li>
  <li>es2016</li>
  <li>es2016.array.include</li>
  <li>es2017</li>
  <li>es2017.object</li>
  <li>es2017.sharedmemory</li>
  <li>scripthost</li>
</ul>
    
      <h4 id="example-67">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-67" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-bash">tsc --target es5 --lib es5,es2015.promise
</code></pre>

<pre><code class="language-json">"compilerOptions": {
    "lib": ["es5", "es2015.promise"]
}
</code></pre>
    
      <h2 id="flag-unused-declarations-with---nounusedparameters-and---nounusedlocals">
        
        
          Flag unused declarations with <code>--noUnusedParameters</code> and <code>--noUnusedLocals</code> <a aria-label="Link to the header: Flag unused declarations with --noUnusedParameters and --noUnusedLocals" title="Link to the header: Flag unused declarations with --noUnusedParameters and --noUnusedLocals" href="#flag-unused-declarations-with---nounusedparameters-and---nounusedlocals" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 has two new flags to help you maintain a clean code base.
<code>--noUnusedParameters</code> flags any unused function or method parameters errors.
<code>--noUnusedLocals</code> flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc…
Also, unused private members of a class would be flagged as errors under <code>--noUnusedLocals</code>.</p>
    
      <h4 id="example-68">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-68" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>
<pre><code class="language-ts">import B, { readFile } from "./b";
//     ^ Error: `B` declared but never used
readFile();


export function write(message: string, args: string[]) {
    //                                 ^^^^  Error: 'arg' declared but never used.
    console.log(message);
}
</code></pre>

<p>Parameters declaration with names starting with <code>_</code> are exempt from the unused parameter checking.
e.g.:</p>

<pre><code class="language-ts">function returnNull(_a) { // OK
    return null;
}
</code></pre>
    
      <h2 id="module-identifiers-allow-for-js-extension">
        
        
          Module identifiers allow for <code>.js</code> extension <a aria-label="Link to the header: Module identifiers allow for .js extension" title="Link to the header: Module identifiers allow for .js extension" href="#module-identifiers-allow-for-js-extension" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Before TypeScript 2.0, a module identifier was always assumed to be extension-less;
for instance, given an import as <code>import d from "./moduleA.js"</code>, the compiler looked up the definition of <code>"moduleA.js"</code> in <code>./moduleA.js.ts</code> or <code>./moduleA.js.d.ts</code>.
This made it hard to use bundling/loading tools like <a href="https://github.com/systemjs/systemjs">SystemJS</a> that expect URI’s in their module identifier.</p>

<p>With TypeScript 2.0, the compiler will look up definition of <code>"moduleA.js"</code> in  <code>./moduleA.ts</code> or <code>./moduleA.d.ts</code>.</p>
    
      <h2 id="support-target--es5-with-module-es6">
        
        
          Support ‘target : es5’ with ‘module: es6’ <a aria-label="Link to the header: Support ‘target : es5’ with ‘module: es6’" title="Link to the header: Support ‘target : es5’ with ‘module: es6’" href="#support-target--es5-with-module-es6" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Previously flagged as an invalid flag combination, <code>target: es5</code> and ‘module: es6’ is now supported.
This should facilitate using ES2015-based tree shakers like <a href="https://github.com/rollup/rollup">rollup</a>.</p>
    
      <h2 id="trailing-commas-in-function-parameter-and-argument-lists">
        
        
          Trailing commas in function parameter and argument lists <a aria-label="Link to the header: Trailing commas in function parameter and argument lists" title="Link to the header: Trailing commas in function parameter and argument lists" href="#trailing-commas-in-function-parameter-and-argument-lists" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Trailing comma in function parameter and argument lists are now allowed.
This is an implementation for a <a href="https://jeffmo.github.io/es-trailing-function-commas/">Stage-3 ECMAScript proposal</a> that emits down to valid ES3/ES5/ES6.</p>
    
      <h4 id="example-69">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-69" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>
<pre><code class="language-ts">function foo(
  bar: Bar,
  baz: Baz, // trailing commas are OK in parameter lists
) {
  // Implementation...
}

foo(
  bar,
  baz, // and in argument lists
);
</code></pre>
    
      <h2 id="new---skiplibcheck">
        
        
          New <code>--skipLibCheck</code> <a aria-label="Link to the header: New --skipLibCheck" title="Link to the header: New --skipLibCheck" href="#new---skiplibcheck" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 2.0 adds a new <code>--skipLibCheck</code> compiler option that causes type checking of declaration files (files with extension <code>.d.ts</code>) to be skipped.
When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</p>

<p>Since declarations in one file can affect type checking in other files, some errors may not be detected when <code>--skipLibCheck</code> is specified.
For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked.
However, in practice such situations are rare.</p>
    
      <h2 id="allow-duplicate-identifiers-across-declarations">
        
        
          Allow duplicate identifiers across declarations <a aria-label="Link to the header: Allow duplicate identifiers across declarations" title="Link to the header: Allow duplicate identifiers across declarations" href="#allow-duplicate-identifiers-across-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>This has been one common source of duplicate definition errors.
Multiple declaration files defining the same members on interfaces.</p>

<p>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have <em>identical</em> types.</p>

<p>Within the same block duplicate definitions are still disallowed.</p>
    
      <h4 id="example-70">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-70" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">interface Error {
    stack?: string;
}


interface Error {
    code?: string;
    path?: string;
    stack?: string;  // OK
}

</code></pre>
    
      <h2 id="new---declarationdir">
        
        
          New <code>--declarationDir</code> <a aria-label="Link to the header: New --declarationDir" title="Link to the header: New --declarationDir" href="#new---declarationdir" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>--declarationDir</code> allows for generating declaration files in a different location than JavaScript files.</p>
    
      <h2 id="typescript-18">
        
        
          TypeScript 1.8 <a aria-label="Link to the header: TypeScript 1.8" title="Link to the header: TypeScript 1.8" href="#typescript-18" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="type-parameters-as-constraints">
        
        
          Type parameters as constraints <a aria-label="Link to the header: Type parameters as constraints" title="Link to the header: Type parameters as constraints" href="#type-parameters-as-constraints" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as <a href="https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification">F-Bounded Polymorphism</a>.</p>
    
      <h5 id="example-71">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-71" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function assign&lt;T extends U, U&gt;(target: T, source: U): T {
    for (let id in source) {
        target[id] = source[id];
    }
    return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
assign(x, { b: 10, d: 20 });
assign(x, { e: 0 });  // Error
</code></pre>
    
      <h2 id="control-flow-analysis-errors">
        
        
          Control flow analysis errors <a aria-label="Link to the header: Control flow analysis errors" title="Link to the header: Control flow analysis errors" href="#control-flow-analysis-errors" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into.
Read on to get more details, and check out these errors in action:</p>

<p><img src="https://cloud.githubusercontent.com/assets/8052307/5210657/c5ae0f28-7585-11e4-97d8-86169ef2a160.gif" alt="cfa" /></p>
    
      <h3 id="unreachable-code">
        
        
          Unreachable code <a aria-label="Link to the header: Unreachable code" title="Link to the header: Unreachable code" href="#unreachable-code" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional <code>return</code>, <code>throw</code>, <code>break</code> or <code>continue</code> statements are considered unreachable. Use <code>--allowUnreachableCode</code> to disable unreachable code detection and reporting.</p>
    
      <h5 id="example-72">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-72" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>Here’s a simple example of an unreachable code error:</p>

<pre><code class="language-ts">function f(x) {
    if (x) {
       return true;
    }
    else {
       return false;
    }

    x = 0; // Error: Unreachable code detected.
}
</code></pre>

<p>A more common error that this feature catches is adding a newline after a <code>return</code> statement:</p>

<pre><code class="language-ts">function f() {
    return            // Automatic Semicolon Insertion triggered at newline
    {
        x: "string"   // Error: Unreachable code detected.
    }
}
</code></pre>

<p>Since JavaScript automatically terminates the <code>return</code> statement at the end of the line, the object literal becomes a block.</p>
    
      <h3 id="unused-labels">
        
        
          Unused labels <a aria-label="Link to the header: Unused labels" title="Link to the header: Unused labels" href="#unused-labels" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use <code>--allowUnusedLabels</code> to stop reporting these errors.</p>
    
      <h5 id="example-73">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-73" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">loop: while (x &gt; 0) {  // Error: Unused label.
    x++;
}
</code></pre>
    
      <h3 id="implicit-returns">
        
        
          Implicit returns <a aria-label="Link to the header: Implicit returns" title="Link to the header: Implicit returns" href="#implicit-returns" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Functions with code paths that do not return a value in JS implicitly return <code>undefined</code>. These can now be flagged by the compiler as implicit returns. The check is turned <em>off</em> by default; use <code>--noImplicitReturns</code> to turn it on.</p>
    
      <h5 id="example-74">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-74" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function f(x) { // Error: Not all code paths return a value.
    if (x) {
        return false;
    }

    // implicitly returns `undefined`
}
</code></pre>
    
      <h3 id="case-clause-fall-throughs">
        
        
          Case clause fall-throughs <a aria-label="Link to the header: Case clause fall-throughs" title="Link to the header: Case clause fall-throughs" href="#case-clause-fall-throughs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty.
This check is turned <em>off</em> by default, and can be enabled using <code>--noFallthroughCasesInSwitch</code>.</p>
    
      <h5 id="example-75">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-75" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>With <code>--noFallthroughCasesInSwitch</code>, this example will trigger an error:</p>

<pre><code class="language-ts">switch (x % 2) {
    case 0: // Error: Fallthrough case in switch.
        console.log("even");

    case 1:
        console.log("odd");
        break;
}
</code></pre>

<p>However, in the following example, no error will be reported because the fall-through case is empty:</p>

<pre><code class="language-ts">switch (x % 3) {
    case 0:
    case 1:
        console.log("Acceptable");
        break;

    case 2:
        console.log("This is *two much*!");
        break;
}
</code></pre>
    
      <h2 id="stateless-function-components-in-react">
        
        
          Stateless Function Components in React <a aria-label="Link to the header: Stateless Function Components in React" title="Link to the header: Stateless Function Components in React" href="#stateless-function-components-in-react" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript now supports <a href="https://facebook.github.io/react/docs/reusable-components.html#stateless-functions">Stateless Function components</a>.
These are lightweight components that easily compose other components:</p>

<pre><code class="language-ts">// Use parameter destructuring and defaults for easy definition of 'props' type
const Greeter = ({name = 'world'}) =&gt; &lt;div&gt;Hello, {name}!&lt;/div&gt;;

// Properties get validated
let example = &lt;Greeter name='TypeScript 1.8' /&gt;;
</code></pre>

<p>For this feature and simplified props, be sure to be use the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react">latest version of react.d.ts</a>.</p>
    
      <h2 id="simplified-props-type-management-in-react">
        
        
          Simplified <code>props</code> type management in React <a aria-label="Link to the header: Simplified props type management in React" title="Link to the header: Simplified props type management in React" href="#simplified-props-type-management-in-react" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 1.8 with the latest version of react.d.ts (see above), we’ve also greatly simplified the declaration of <code>props</code> types.</p>

<p>Specifically:</p>
<ul>
  <li>You no longer need to either explicitly declare <code>ref</code> and <code>key</code> or <code>extend React.Props</code></li>
  <li>The <code>ref</code> and <code>key</code> properties will appear with correct types on all components</li>
  <li>The <code>ref</code> property is correctly disallowed on instances of Stateless Function components</li>
</ul>
    
      <h2 id="augmenting-globalmodule-scope-from-modules">
        
        
          Augmenting global/module scope from modules <a aria-label="Link to the header: Augmenting global/module scope from modules" title="Link to the header: Augmenting global/module scope from modules" href="#augmenting-globalmodule-scope-from-modules" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module.
Module augmentations look like plain old ambient module declarations (i.e. the <code>declare module "foo" { }</code> syntax), and are directly nested either your own modules, or in another top level ambient external module.</p>

<p>Furthermore, TypeScript also has the notion of <em>global</em> augmentations of the form <code>declare global { }</code>.
This allows modules to augment global types such as <code>Array</code> if necessary.</p>

<p>The name of a module augmentation is resolved using the same set of rules as module specifiers in <code>import</code> and <code>export</code> declarations.
The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</p>

<p>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only “patch” existing declarations.</p>
    
      <h5 id="example-76">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-76" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>Here <code>map.ts</code> can declare that it will internally patch the <code>Observable</code> type from <code>observable.ts</code> and add the <code>map</code> method to it.</p>

<pre><code class="language-ts">// observable.ts
export class Observable&lt;T&gt; {
    // ...
}
</code></pre>

<pre><code class="language-ts">// map.ts
import { Observable } from "./observable";

// Create an augmentation for "./observable"
declare module "./observable" {

    // Augment the 'Observable' class definition with interface merging
    interface Observable&lt;T&gt; {
        map&lt;U&gt;(proj: (el: T) =&gt; U): Observable&lt;U&gt;;
    }

}

Observable.prototype.map = /*...*/;
</code></pre>

<pre><code class="language-ts">// consumer.ts
import { Observable } from "./observable";
import "./map";

let o: Observable&lt;number&gt;;
o.map(x =&gt; x.toFixed());
</code></pre>

<p>Similarly, the global scope can be augmented from modules using a <code>declare global</code> declarations:</p>
    
      <h5 id="example-77">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-77" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">// Ensure this is treated as a module.
export {};

declare global {
    interface Array&lt;T&gt; {
        mapToNumbers(): number[];
    }
}

Array.prototype.mapToNumbers = function () { /* ... */ }
</code></pre>
    
      <h2 id="string-literal-types">
        
        
          String literal types <a aria-label="Link to the header: String literal types" title="Link to the header: String literal types" href="#string-literal-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>It’s not uncommon for an API to expect a specific set of strings for certain values.
For instance, consider a UI library that can move elements across the screen while controlling the <a href="https://en.wikipedia.org/wiki/Inbetweening">“easing” of the animation.</a></p>

<pre><code class="language-ts">declare class UIElement {
    animate(options: AnimationOptions): void;
}

interface AnimationOptions {
    deltaX: number;
    deltaY: number;
    easing: string; // Can be "ease-in", "ease-out", "ease-in-out"
}
</code></pre>

<p>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</p>

<pre><code class="language-ts">// No errors
new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });
</code></pre>

<p>With TypeScript 1.8, we’ve introduced string literal types.
These types are written the same way string literals are, but in type positions.</p>

<p>Users can now ensure that the type system will catch such errors.
Here’s our new <code>AnimationOptions</code> using string literal types:</p>

<pre><code class="language-ts">interface AnimationOptions {
    deltaX: number;
    deltaY: number;
    easing: "ease-in" | "ease-out" | "ease-in-out";
}

// Error: Type '"ease-inout"' is not assignable to type '"ease-in" | "ease-out" | "ease-in-out"'
new UIElement().animate({ deltaX: 100, deltaY: 100, easing: "ease-inout" });
</code></pre>
    
      <h2 id="improved-unionintersection-type-inference">
        
        
          Improved union/intersection type inference <a aria-label="Link to the header: Improved union/intersection type inference" title="Link to the header: Improved union/intersection type inference" href="#improved-unionintersection-type-inference" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types.
For example, when inferring from <code>string | string[]</code> to <code>string | T</code>, we reduce the types to <code>string[]</code> and <code>T</code>, thus inferring <code>string[]</code> for <code>T</code>.</p>
    
      <h5 id="example-78">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-78" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">type Maybe&lt;T&gt; = T | void;

function isDefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is T {
    return x !== undefined &amp;&amp; x !== null;
}

function isUndefined&lt;T&gt;(x: Maybe&lt;T&gt;): x is void {
    return x === undefined || x === null;
}

function getOrElse&lt;T&gt;(x: Maybe&lt;T&gt;, defaultValue: T): T {
    return isDefined(x) ? x : defaultValue;
}

function test1(x: Maybe&lt;string&gt;) {
    let x1 = getOrElse(x, "Undefined");         // string
    let x2 = isDefined(x) ? x : "Undefined";    // string
    let x3 = isUndefined(x) ? "Undefined" : x;  // string
}

function test2(x: Maybe&lt;number&gt;) {
    let x1 = getOrElse(x, -1);         // number
    let x2 = isDefined(x) ? x : -1;    // number
    let x3 = isUndefined(x) ? -1 : x;  // number
}
</code></pre>
    
      <h2 id="concatenate-amd-and-system-modules-with---outfile">
        
        
          Concatenate <code>AMD</code> and <code>System</code> modules with <code>--outFile</code> <a aria-label="Link to the header: Concatenate AMD and System modules with --outFile" title="Link to the header: Concatenate AMD and System modules with --outFile" href="#concatenate-amd-and-system-modules-with---outfile" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Specifying <code>--outFile</code> in conjunction with <code>--module amd</code> or <code>--module system</code> will concatenate all modules in the compilation into a single output file containing multiple module closures.</p>

<p>A module name will be computed for each module based on its relative location to <code>rootDir</code>.</p>
    
      <h5 id="example-79">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-79" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>
<pre><code class="language-ts">// file src/a.ts
import * as B from "./lib/b";
export function createA() {
    return B.createB();
}
</code></pre>

<pre><code class="language-ts">// file src/lib/b.ts
export function createB() {
    return { };
}
</code></pre>

<p>Results in:</p>

<pre><code class="language-js">define("lib/b", ["require", "exports"], function (require, exports) {
    "use strict";
    function createB() {
        return {};
    }
    exports.createB = createB;
});
define("a", ["require", "exports", "lib/b"], function (require, exports, B) {
    "use strict";
    function createA() {
        return B.createB();
    }
    exports.createA = createA;
});
</code></pre>
    
      <h2 id="support-for-default-import-interop-with-systemjs">
        
        
          Support for <code>default</code> import interop with SystemJS <a aria-label="Link to the header: Support for default import interop with SystemJS" title="Link to the header: Support for default import interop with SystemJS" href="#support-for-default-import-interop-with-systemjs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Module loaders like SystemJS wrap CommonJS modules and expose then as a <code>default</code> ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</p>

<p>Setting the new compiler flag <code>--allowSyntheticDefaultImports</code> indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a <code>default</code> export that has the shape of the entire module itself.</p>

<p>System modules have this flag on by default.</p>
    
      <h2 id="allow-captured-letconst-in-loops">
        
        
          Allow captured <code>let</code>/<code>const</code> in loops <a aria-label="Link to the header: Allow captured let/const in loops" title="Link to the header: Allow captured let/const in loops" href="#allow-captured-letconst-in-loops" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Previously an error, now supported in TypeScript 1.8.
<code>let</code>/<code>const</code> declarations within loops and captured in functions are now emitted to correctly match <code>let</code>/<code>const</code> freshness semantics.</p>
    
      <h5 id="example-80">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-80" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">let list = [];
for (let i = 0; i &lt; 5; i++) {
    list.push(() =&gt; i);
}

list.forEach(f =&gt; console.log(f()));
</code></pre>

<p>is compiled to:</p>

<pre><code class="language-js">var list = [];
var _loop_1 = function(i) {
    list.push(function () { return i; });
};
for (var i = 0; i &lt; 5; i++) {
    _loop_1(i);
}
list.forEach(function (f) { return console.log(f()); });
</code></pre>

<p>And results in</p>

<pre><code class="language-cmd">0
1
2
3
4
</code></pre>
    
      <h2 id="improved-checking-for-forin-statements">
        
        
          Improved checking for <code>for..in</code> statements <a aria-label="Link to the header: Improved checking for for..in statements" title="Link to the header: Improved checking for for..in statements" href="#improved-checking-for-forin-statements" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Previously the type of a <code>for..in</code> variable is inferred to <code>any</code>; that allowed the compiler to ignore invalid uses within the <code>for..in</code> body.</p>

<p>Starting with TypeScript 1.8,:</p>
<ul>
  <li>The type of a variable declared in a <code>for..in</code> statement is implicitly <code>string</code>.</li>
  <li>When an object with a numeric index signature of type <code>T</code> (such as an array) is indexed by a <code>for..in</code> variable of a containing <code>for..in</code> statement for an object <em>with</em> a numeric index signature and <em>without</em> a string index signature (again such as an array), the value produced is of type <code>T</code>.</li>
</ul>
    
      <h5 id="example-81">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-81" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">var a: MyObject[];
for (var x in a) {   // Type of x is implicitly string
    var obj = a[x];  // Type of obj is MyObject
}
</code></pre>
    
      <h2 id="modules-are-now-emitted-with-a-use-strict-prologue">
        
        
          Modules are now emitted with a <code>"use strict";</code> prologue <a aria-label="Link to the header: Modules are now emitted with a "use strict"; prologue" title="Link to the header: Modules are now emitted with a "use strict"; prologue" href="#modules-are-now-emitted-with-a-use-strict-prologue" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn’t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to <code>NaN</code>, will now loudly fail. You can reference the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN Article</a> on strict mode for a detailed list of the differences between strict mode and non-strict mode.</p>
    
      <h2 id="including-js-files-with---allowjs">
        
        
          Including <code>.js</code> files with <code>--allowJs</code> <a aria-label="Link to the header: Including .js files with --allowJs" title="Link to the header: Including .js files with --allowJs" href="#including-js-files-with---allowjs" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Often there are external source files in your project that may not be authored in TypeScript.
Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</p>

<p><code>.js</code> files are now allowed as input to <code>tsc</code>.
The TypeScript compiler checks the input <code>.js</code> files for syntax errors, and emits valid output based on the <code>--target</code> and <code>--module</code> flags.
The output can be combined with other <code>.ts</code> files as well.
Source maps are still generated for <code>.js</code> files just like with <code>.ts</code> files.</p>
    
      <h2 id="custom-jsx-factories-using---reactnamespace">
        
        
          Custom JSX factories using <code>--reactNamespace</code> <a aria-label="Link to the header: Custom JSX factories using --reactNamespace" title="Link to the header: Custom JSX factories using --reactNamespace" href="#custom-jsx-factories-using---reactnamespace" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Passing <code>--reactNamespace &lt;JSX factory Name&gt;</code> along with <code>--jsx react</code> allows for using a different JSX factory from the default <code>React</code>.</p>

<p>The new factory name will be used to call <code>createElement</code> and <code>__spread</code> functions.</p>
    
      <h5 id="example-82">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-82" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">import {jsxFactory} from "jsxFactory";

var div = &lt;div&gt;Hello JSX!&lt;/div&gt;
</code></pre>

<p>Compiled with:</p>

<pre><code class="language-shell">tsc --jsx react --reactNamespace jsxFactory --m commonJS
</code></pre>

<p>Results in:</p>

<pre><code class="language-js">"use strict";
var jsxFactory_1 = require("jsxFactory");
var div = jsxFactory_1.jsxFactory.createElement("div", null, "Hello JSX!");
</code></pre>
    
      <h2 id="this-based-type-guards">
        
        
          <code>this</code>-based type guards <a aria-label="Link to the header: this-based type guards" title="Link to the header: this-based type guards" href="#this-based-type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.8 extends <a href="#user-defined-type-guard-functions">user-defined type guard functions</a> to class and interface methods.</p>

<p><code>this is T</code> is now valid return type annotation for methods in classes and interfaces.
When used in a type narrowing position (e.g. <code>if</code> statement), the type of the call expression target object would be narrowed to <code>T</code>.</p>
    
      <h5 id="example-83">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-83" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">
class FileSystemObject {
    isFile(): this is File { return this instanceof File; }
    isDirectory(): this is Directory { return this instanceof Directory;}
    isNetworked(): this is (Networked &amp; this) { return this.networked; }
    constructor(public path: string, private networked: boolean) {}
}

class File extends FileSystemObject {
    constructor(path: string, public content: string) { super(path, false); }
}
class Directory extends FileSystemObject {
    children: FileSystemObject[];
}
interface Networked {
    host: string;
}

let fso: FileSystemObject = new File("foo/bar.txt", "foo");
if (fso.isFile()) {
    fso.content; // fso is File
}
else if (fso.isDirectory()) {
    fso.children; // fso is Directory
}
else if (fso.isNetworked()) {
    fso.host; // fso is networked
}
</code></pre>
    
      <h2 id="official-typescript-nuget-package">
        
        
          Official TypeScript NuGet package <a aria-label="Link to the header: Official TypeScript NuGet package" title="Link to the header: Official TypeScript NuGet package" href="#official-typescript-nuget-package" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (<code>tsc.exe</code>) as well as the MSBuild integration (<code>Microsoft.TypeScript.targets</code> and <code>Microsoft.TypeScript.Tasks.dll</code>).</p>

<p>Stable packages are available here:</p>
<ul>
  <li><a href="https://www.nuget.org/packages/Microsoft.TypeScript.Compiler/">Microsoft.TypeScript.Compiler</a></li>
  <li><a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild/">Microsoft.TypeScript.MSBuild</a></li>
</ul>

<p>Also, a nightly NuGet package to match the <a href="http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx">nightly npm package</a> is available on https://myget.org:</p>

<ul>
  <li><a href="https://www.myget.org/gallery/typescript-preview">TypeScript-Preview</a></li>
</ul>
    
      <h2 id="prettier-error-messages-from-tsc">
        
        
          Prettier error messages from <code>tsc</code> <a aria-label="Link to the header: Prettier error messages from tsc" title="Link to the header: Prettier error messages from tsc" href="#prettier-error-messages-from-tsc" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>We understand that a ton of monochrome output can be a little difficult on the eyes.
Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</p>

<p>By just passing the <code>--pretty</code> command line option, TypeScript gives more colorful output with context about where things are going wrong.</p>

<p><img src="https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/pretty01.png" alt="Showing off pretty error messages in ConEmu" /></p>
    
      <h2 id="colorization-of-jsx-code-in-vs-2015">
        
        
          Colorization of JSX code in VS 2015 <a aria-label="Link to the header: Colorization of JSX code in VS 2015" title="Link to the header: Colorization of JSX code in VS 2015" href="#colorization-of-jsx-code-in-vs-2015" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</p>

<p><img src="https://cloud.githubusercontent.com/assets/8052307/12271404/b875c502-b90f-11e5-93d8-c6740be354d1.png" alt="jsx" /></p>

<p>The classification can be further customized by changing the font and color settings for the <code>VB XML</code> color and font settings through <code>Tools</code>-&gt;<code>Options</code>-&gt;<code>Environment</code>-&gt;<code>Fonts and Colors</code> page.</p>
    
      <h2 id="the---project--p-flag-can-now-take-any-file-path">
        
        
          The <code>--project</code> (<code>-p</code>) flag can now take any file path <a aria-label="Link to the header: The --project (-p) flag can now take any file path" title="Link to the header: The --project (-p) flag can now take any file path" href="#the---project--p-flag-can-now-take-any-file-path" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The <code>--project</code> command line option originally could only take paths to a folder containing a <code>tsconfig.json</code>.
Given the different scenarios for build configurations, it made sense to allow <code>--project</code> to point to any other compatible JSON file.
For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser.
With this new work, users can easily manage two separate build targets using <code>tsc</code> alone without having to perform hacky workarounds like placing <code>tsconfig.json</code> files in separate directories.</p>

<p>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named <code>tsconfig.json</code>.</p>
    
      <h2 id="allow-comments-in-tsconfigjson">
        
        
          Allow comments in tsconfig.json <a aria-label="Link to the header: Allow comments in tsconfig.json" title="Link to the header: Allow comments in tsconfig.json" href="#allow-comments-in-tsconfigjson" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>It’s always nice to be able to document your configuration!
<code>tsconfig.json</code> now accepts single and multi-line comments.</p>

<pre><code class="language-ts">{
    "compilerOptions": {
        "target": "ES2015", // running on node v5, yaay!
        "sourceMap": true   // makes debugging easier
    },
    /*
     * Excluded files
      */
    "exclude": [
        "file.d.ts"
    ]
}
</code></pre>
    
      <h2 id="support-output-to-ipc-driven-files">
        
        
          Support output to IPC-driven files <a aria-label="Link to the header: Support output to IPC-driven files" title="Link to the header: Support output to IPC-driven files" href="#support-output-to-ipc-driven-files" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.8 allows users to use the <code>--outFile</code> argument with special file system entities like named pipes, devices, etc.</p>

<p>As an example, on many Unix-like systems, the standard output stream is accessible by the file <code>/dev/stdout</code>.</p>

<pre><code class="language-shell">tsc foo.ts --outFile /dev/stdout
</code></pre>

<p>This can be used to pipe output between commands as well.</p>

<p>As an example, we can pipe our emitted JavaScript into a pretty printer like <a href="https://www.npmjs.com/package/pretty-js">pretty-js</a>:</p>

<pre><code class="language-shell">tsc foo.ts --outFile /dev/stdout | pretty-js
</code></pre>
    
      <h2 id="improved-support-for-tsconfigjson-in-visual-studio-2015">
        
        
          Improved support for <code>tsconfig.json</code> in Visual Studio 2015 <a aria-label="Link to the header: Improved support for tsconfig.json in Visual Studio 2015" title="Link to the header: Improved support for tsconfig.json in Visual Studio 2015" href="#improved-support-for-tsconfigjson-in-visual-studio-2015" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.8 allows <code>tsconfig.json</code> files in all project types.
This includes ASP.NET v4 projects, <em>Console Application</em>, and the <em>Html Application with TypeScript</em> project types.
Further, you are no longer limited to a single <code>tsconfig.json</code> file but can add multiple, and each will be built as part of the project.
This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</p>

<p><img src="https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/new-in-typescript/tsconfig-in-vs.png" alt="Showing off tsconfig.json in Visual Studio" /></p>

<p>We also disable the project properties page when you add a <code>tsconfig.json</code> file.
This means that all configuration changes have to be made in the <code>tsconfig.json</code> file itself.</p>
    
      <h3 id="a-couple-of-limitations">
        
        
          A couple of limitations: <a aria-label="Link to the header: A couple of limitations:" title="Link to the header: A couple of limitations:" href="#a-couple-of-limitations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<ul>
  <li>If you add a <code>tsconfig.json</code> file, TypeScript files that are not considered part of that context are not compiled.</li>
  <li>Apache Cordova Apps still have the existing limitation of a single <code>tsconfig.json</code> file, which must be in either the root or the <code>scripts</code> folder.</li>
  <li>There is no template for <code>tsconfig.json</code> in most project types.</li>
</ul>
    
      <h2 id="typescript-17">
        
        
          TypeScript 1.7 <a aria-label="Link to the header: TypeScript 1.7" title="Link to the header: TypeScript 1.7" href="#typescript-17" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="asyncawait-support-in-es6-targets-node-v4">
        
        
          <code>async</code>/<code>await</code> support in ES6 targets (Node v4+) <a aria-label="Link to the header: async/await support in ES6 targets (Node v4+)" title="Link to the header: async/await support in ES6 targets (Node v4+)" href="#asyncawait-support-in-es6-targets-node-v4" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above.
Asynchronous functions are prefixed with the <code>async</code> keyword; <code>await</code> suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the <code>Promise</code> returned.</p>
    
      <h5 id="example-84">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-84" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>In the following example, each input element will be printed out one at a time with a 200ms delay:</p>

<pre><code class="language-ts">"use strict";

// printDelayed is a 'Promise&lt;void&gt;'
async function printDelayed(elements: string[]) {
    for (const element of elements) {
        await delay(200);
        console.log(element);
    }
}

async function delay(milliseconds: number) {
    return new Promise&lt;void&gt;(resolve =&gt; {
        setTimeout(resolve, milliseconds);
    });
}

printDelayed(["Hello", "beautiful", "asynchronous", "world"]).then(() =&gt; {
    console.log();
    console.log("Printed every element!");
});
</code></pre>

<p>For more information see <a href="http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx">Async Functions</a> blog post.</p>
    
      <h2 id="support-for---target-es6-with---module">
        
        
          Support for <code>--target ES6</code> with <code>--module</code> <a aria-label="Link to the header: Support for --target ES6 with --module" title="Link to the header: Support for --target ES6 with --module" href="#support-for---target-es6-with---module" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.7 adds <code>ES6</code> to the list of options available for the <code>--module</code> flag and allows you to specify the module output when targeting <code>ES6</code>. This provides more flexibility to target exactly the features you want in specific runtimes.</p>
    
      <h5 id="example-85">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-85" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-json">{
    "compilerOptions": {
        "module": "amd",
        "target": "es6"
    }
}
</code></pre>
    
      <h2 id="this-typing">
        
        
          <code>this</code>-typing <a aria-label="Link to the header: this-typing" title="Link to the header: this-typing" href="#this-typing" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>It is a common pattern to return the current object (i.e. <code>this</code>) from a method to create <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent-style APIs</a>.
For instance, consider the following <code>BasicCalculator</code> module:</p>

<pre><code class="language-ts">export default class BasicCalculator {
    public constructor(protected value: number = 0) { }

    public currentValue(): number {
        return this.value;
    }

    public add(operand: number) {
        this.value += operand;
        return this;
    }

    public subtract(operand: number) {
        this.value -= operand;
        return this;
    }

    public multiply(operand: number) {
        this.value *= operand;
        return this;
    }

    public divide(operand: number) {
        this.value /= operand;
        return this;
    }
}
</code></pre>

<p>A user could express <code>2 * 5 + 1</code> as</p>

<pre><code class="language-ts">import calc from "./BasicCalculator";

let v = new calc(2)
    .multiply(5)
    .add(1)
    .currentValue();
</code></pre>

<p>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from <code>BasicCalculator</code>.
Imagine a user wanted to start writing a <code>ScientificCalculator</code>:</p>

<pre><code class="language-ts">import BasicCalculator from "./BasicCalculator";

export default class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }

    public square() {
        this.value = this.value ** 2;
        return this;
    }

    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
}
</code></pre>

<p>Because TypeScript used to infer the type <code>BasicCalculator</code> for each method in <code>BasicCalculator</code> that returned <code>this</code>, the type system would forget that it had <code>ScientificCalculator</code> whenever using a <code>BasicCalculator</code> method.</p>

<p>For instance:</p>

<pre><code class="language-ts">import calc from "./ScientificCalculator";

let v = new calc(0.5)
    .square()
    .divide(2)
    .sin()    // Error: 'BasicCalculator' has no 'sin' method.
    .currentValue();
</code></pre>

<p>This is no longer the case - TypeScript now infers <code>this</code> to have a special type called <code>this</code> whenever inside an instance method of a class.
The <code>this</code> type is written as so, and basically means “the type of the left side of the dot in a method call”.</p>

<p>The <code>this</code> type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</p>

<pre><code class="language-ts">interface MyType {
    extend&lt;T&gt;(other: T): this &amp; T;
}
</code></pre>
    
      <h2 id="es7-exponentiation-operator">
        
        
          ES7 exponentiation operator <a aria-label="Link to the header: ES7 exponentiation operator" title="Link to the header: ES7 exponentiation operator" href="#es7-exponentiation-operator" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.7 supports upcoming <a href="https://github.com/rwaldron/exponentiation-operator">ES7/ES2016 exponentiation operators</a>: <code>**</code> and <code>**=</code>. The operators will be transformed in the output to ES3/ES5 using <code>Math.pow</code>.</p>
    
      <h5 id="example-86">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-86" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">var x = 2 ** 3;
var y = 10;
y **= 2;
var z =  -(4 ** 3);
</code></pre>

<p>Will generate the following JavaScript output:</p>

<pre><code class="language-js">var x = Math.pow(2, 3);
var y = 10;
y = Math.pow(y, 2);
var z = -(Math.pow(4, 3));
</code></pre>
    
      <h2 id="improved-checking-for-destructuring-object-literal">
        
        
          Improved checking for destructuring object literal <a aria-label="Link to the header: Improved checking for destructuring object literal" title="Link to the header: Improved checking for destructuring object literal" href="#improved-checking-for-destructuring-object-literal" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</p>

<p>When an object literal is contextually typed by the implied type of an object binding pattern:</p>
<ul>
  <li>Properties with default values in the object binding pattern become optional in the object literal.</li>
  <li>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</li>
  <li>Properties in the object literal that have no match in the object binding pattern are an error.</li>
</ul>

<p>When an array literal is contextually typed by the implied type of an array binding pattern:</p>

<ul>
  <li>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</li>
</ul>
    
      <h5 id="example-87">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-87" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">// Type of f1 is (arg?: { x?: number, y?: number }) =&gt; void
function f1({ x = 0, y = 0 } = {}) { }

// And can be called as:
f1();
f1({});
f1({ x: 1 });
f1({ y: 1 });
f1({ x: 1, y: 1 });

// Type of f2 is (arg?: (x: number, y?: number) =&gt; void
function f2({ x, y = 0 } = { x: 0 }) { }

f2();
f2({});        // Error, x not optional
f2({ x: 1 });
f2({ y: 1 });  // Error, x not optional
f2({ x: 1, y: 1 });
</code></pre>
    
      <h2 id="support-for-decorators-when-targeting-es3">
        
        
          Support for decorators when targeting ES3 <a aria-label="Link to the header: Support for decorators when targeting ES3" title="Link to the header: Support for decorators when targeting ES3" href="#support-for-decorators-when-targeting-es3" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of <code>reduceRight</code> from the <code>__decorate</code> helper. The changes also inline calls to <code>Object.getOwnPropertyDescriptor</code> and <code>Object.defineProperty</code> in a backwards-compatible fashion that allows for clean up of the emit for ES5 and later by removing various repetitive calls to the aforementioned <code>Object</code> methods.</p>
    
      <h2 id="typescript-16">
        
        
          TypeScript 1.6 <a aria-label="Link to the header: TypeScript 1.6" title="Link to the header: TypeScript 1.6" href="#typescript-16" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="jsx-support">
        
        
          JSX support <a aria-label="Link to the header: JSX support" title="Link to the header: JSX support" href="#jsx-support" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</p>
    
      <h4 id="new-tsx-file-extension-and-as-operator">
        
        
          New <code>.tsx</code> file extension and <code>as</code> operator <a aria-label="Link to the header: New .tsx file extension and as operator" title="Link to the header: New .tsx file extension and as operator" href="#new-tsx-file-extension-and-as-operator" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>TypeScript 1.6 introduces a new <code>.tsx</code> file extension.  This extension does two things: it enables JSX inside of TypeScript files, and it makes the new <code>as</code> operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</p>

<pre><code class="language-ts">var x = &lt;any&gt; foo;
// is equivalent to:
var x = foo as any;
</code></pre>
    
      <h4 id="using-react">
        
        
          Using React <a aria-label="Link to the header: Using React" title="Link to the header: Using React" href="#using-react" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>To use JSX-support with React you should use the <a href="https://github.com/borisyankov/DefinitelyTyped/tree/master/react">React typings</a>. These typings define the <code>JSX</code> namespace so that TypeScript can correctly check JSX expressions for React. For example:</p>

<pre><code class="language-ts">/// &lt;reference path="react.d.ts" /&gt;

interface Props {
  name: string;
}

class MyComponent extends React.Component&lt;Props, {}&gt; {
  render() {
    return &lt;span&gt;{this.props.foo}&lt;/span&gt;
  }
}

&lt;MyComponent name="bar" /&gt;; // OK
&lt;MyComponent name={0} /&gt;; // error, `name` is not a number
</code></pre>
    
      <h4 id="using-other-jsx-frameworks">
        
        
          Using other JSX frameworks <a aria-label="Link to the header: Using other JSX frameworks" title="Link to the header: Using other JSX frameworks" href="#using-other-jsx-frameworks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>JSX element names and properties are validated against the <code>JSX</code> namespace. Please see the [[JSX]] wiki page for defining the <code>JSX</code> namespace for your framework.</p>
    
      <h4 id="output-generation">
        
        
          Output generation <a aria-label="Link to the header: Output generation" title="Link to the header: Output generation" href="#output-generation" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>TypeScript ships with two JSX modes: <code>preserve</code> and <code>react</code>.</p>
<ul>
  <li>The <code>preserve</code> mode will keep JSX expressions as part of the output to be further consumed by another transform step. <em>Additionally the output will have a <code>.jsx</code> file extension.</em></li>
  <li>The <code>react</code> mode will emit <code>React.createElement</code>, does not need to go through a JSX transformation before use, and the output will have a <code>.js</code> file extension.</li>
</ul>

<p>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</p>
    
      <h2 id="intersection-types">
        
        
          Intersection types <a aria-label="Link to the header: Intersection types" title="Link to the header: Intersection types" href="#intersection-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type <code>A | B</code> represents an entity that is either of type <code>A</code> or type <code>B</code>, whereas an intersection type <code>A &amp; B</code> represents an entity that is both of type <code>A</code> <em>and</em> type <code>B</code>.</p>
    
      <h5 id="example-88">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-88" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
    let result = &lt;T &amp; U&gt; {};
    for (let id in first) {
        result[id] = first[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            result[id] = second[id];
        }
    }
    return result;
}

var x = extend({ a: "hello" }, { b: 42 });
var s = x.a;
var n = x.b;
</code></pre>

<pre><code class="language-ts">type LinkedList&lt;T&gt; = T &amp; { next: LinkedList&lt;T&gt; };

interface Person {
    name: string;
}

var people: LinkedList&lt;Person&gt;;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;
</code></pre>

<pre><code class="language-ts">interface A { a: string }
interface B { b: string }
interface C { c: string }

var abc: A &amp; B &amp; C;
abc.a = "hello";
abc.b = "hello";
abc.c = "hello";
</code></pre>

<p>See <a href="https://github.com/Microsoft/TypeScript/issues/1256">issue #1256</a> for more information.</p>
    
      <h2 id="local-type-declarations">
        
        
          Local type declarations <a aria-label="Link to the header: Local type declarations" title="Link to the header: Local type declarations" href="#local-type-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with <code>let</code> and <code>const</code>. For example:</p>

<pre><code class="language-ts">function f() {
    if (true) {
        interface T { x: number }
        let v: T;
        v.x = 5;
    }
    else {
        interface T { x: string }
        let v: T;
        v.x = "hello";
    }
}
</code></pre>

<p>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</p>

<pre><code class="language-ts">interface Point {
    x: number;
    y: number;
}

function getPointFactory(x: number, y: number) {
    class P {
        x = x;
        y = y;
    }
    return P;
}

var PointZero = getPointFactory(0, 0);
var PointOne = getPointFactory(1, 1);
var p1 = new PointZero();
var p2 = new PointZero();
var p3 = new PointOne();
</code></pre>

<p>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</p>

<pre><code class="language-ts">function f3() {
    function f&lt;X, Y&gt;(x: X, y: Y) {
        class C {
            public x = x;
            public y = y;
        }
        return C;
    }
    let C = f(10, "hello");
    let v = new C();
    let x = v.x;  // number
    let y = v.y;  // string
}
</code></pre>
    
      <h2 id="class-expressions">
        
        
          Class expressions <a aria-label="Link to the header: Class expressions" title="Link to the header: Class expressions" href="#class-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</p>

<pre><code class="language-ts">let Point = class {
    constructor(public x: number, public y: number) { }
    public length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
};
var p = new Point(3, 4);  // p has anonymous class type
console.log(p.length());
</code></pre>
    
      <h2 id="extending-expressions">
        
        
          Extending expressions <a aria-label="Link to the header: Extending expressions" title="Link to the header: Extending expressions" href="#extending-expressions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</p>

<p>The <code>extends</code> clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the <code>extends</code> clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and “class-like” expressions to be specified in the <code>extends</code> clause.</p>

<p>Some examples:</p>

<pre><code class="language-ts">// Extend built-in types

class MyArray extends Array&lt;number&gt; { }
class MyError extends Error { }

// Extend computed base class

class ThingA {
    getGreeting() { return "Hello from A"; }
}

class ThingB {
    getGreeting() { return "Hello from B"; }
}

interface Greeter {
    getGreeting(): string;
}

interface GreeterConstructor {
    new (): Greeter;
}

function getGreeterBase(): GreeterConstructor {
    return Math.random() &gt;= 0.5 ? ThingA : ThingB;
}

class Test extends getGreeterBase() {
    sayHello() {
        console.log(this.getGreeting());
    }
}
</code></pre>
    
      <h2 id="abstract-classes-and-methods">
        
        
          <code>abstract</code> classes and methods <a aria-label="Link to the header: abstract classes and methods" title="Link to the header: abstract classes and methods" href="#abstract-classes-and-methods" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 adds support for <code>abstract</code> keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</p>
    
      <h5 id="examples">
        
        
          Examples <a aria-label="Link to the header: Examples" title="Link to the header: Examples" href="#examples" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">abstract class Base {
    abstract getThing(): string;
    getOtherThing() { return 'hello'; }
}

let x = new Base(); // Error, 'Base' is abstract

// Error, must either be 'abstract' or implement concrete 'getThing'
class Derived1 extends Base { }

class Derived2 extends Base {
    getThing() { return 'hello'; }
    foo() {
        super.getThing(); // Error: cannot invoke abstract members through 'super'
    }
}

var x = new Derived2(); // OK
var y: Base = new Derived2(); // Also OK
y.getThing(); // OK
y.getOtherThing(); // OK
</code></pre>
    
      <h2 id="generic-type-aliases">
        
        
          Generic type aliases <a aria-label="Link to the header: Generic type aliases" title="Link to the header: Generic type aliases" href="#generic-type-aliases" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>With TypeScript 1.6, type aliases can be generic. For example:</p>

<pre><code class="language-ts">type Lazy&lt;T&gt; = T | (() =&gt; T);

var s: Lazy&lt;string&gt;;
s = "eager";
s = () =&gt; "lazy";

interface Tuple&lt;A, B&gt; {
    a: A;
    b: B;
}

type Pair&lt;T&gt; = Tuple&lt;T, T&gt;;
</code></pre>
    
      <h2 id="stricter-object-literal-assignment-checks">
        
        
          Stricter object literal assignment checks <a aria-label="Link to the header: Stricter object literal assignment checks" title="Link to the header: Stricter object literal assignment checks" href="#stricter-object-literal-assignment-checks" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don’t exist in the target type.</p>
    
      <h5 id="examples-1">
        
        
          Examples <a aria-label="Link to the header: Examples" title="Link to the header: Examples" href="#examples-1" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">var x: { foo: number };
x = { foo: 1, baz: 2 };  // Error, excess property `baz`

var y: { foo: number, bar?: number };
y = { foo: 1, baz: 2 };  // Error, excess or misspelled property `baz`
</code></pre>

<p>A type can include an index signature to explicitly indicate that excess properties are permitted:</p>

<pre><code class="language-ts">var x: { foo: number, [x: string]: any };
x = { foo: 1, baz: 2 };  // Ok, `baz` matched by index signature
</code></pre>
    
      <h2 id="es6-generators">
        
        
          ES6 generators <a aria-label="Link to the header: ES6 generators" title="Link to the header: ES6 generators" href="#es6-generators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 adds support for generators when targeting ES6.</p>

<p>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</p>

<pre><code class="language-ts">function *g(): Iterable&lt;string&gt; {
    for (var i = 0; i &lt; 100; i++) {
        yield ""; // string is assignable to string
    }
    yield * otherStringGenerator(); // otherStringGenerator must be iterable and element type assignable to string
}
</code></pre>

<p>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</p>

<pre><code class="language-ts">function *g() {
    for (var i = 0; i &lt; 100; i++) {
        yield ""; // infer string
    }
    yield * otherStringGenerator(); // infer element type of otherStringGenerator
}
</code></pre>
    
      <h2 id="experimental-support-for-async-functions">
        
        
          Experimental support for <code>async</code> functions <a aria-label="Link to the header: Experimental support for async functions" title="Link to the header: Experimental support for async functions" href="#experimental-support-for-async-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 introduces experimental support of <code>async</code> functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible <code>Promise</code> implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</p>

<p>An <em>async function</em> is a function or method that has been prefixed with the <code>async</code> modifier. This modifier informs the compiler that function body transposition is required, and that the keyword <code>await</code> should be treated as a unary expression instead of an identifier. An <em>Async Function</em> must provide a return type annotation that points to a compatible <code>Promise</code> type. Return type inference can only be used if there is a globally defined, compatible <code>Promise</code> type.</p>
    
      <h5 id="example-89">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-89" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">var p: Promise&lt;number&gt; = /* ... */;
async function fn(): Promise&lt;number&gt; {
  var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
  return 1 + i;
}

var a = async (): Promise&lt;number&gt; =&gt; 1 + await p; // suspends execution.
var a = async () =&gt; 1 + await p; // suspends execution. return type is inferred as "Promise&lt;number&gt;" when compiling with --target ES6
var fe = async function(): Promise&lt;number&gt; {
  var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
  return 1 + i;
}

class C {
  async m(): Promise&lt;number&gt; {
    var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    return 1 + i;
  }

  async get p(): Promise&lt;number&gt; {
    var i = await p; // suspend execution until 'p' is settled. 'i' has type "number"
    return 1 + i;
  }
}
</code></pre>
    
      <h2 id="nightly-builds">
        
        
          Nightly builds <a aria-label="Link to the header: Nightly builds" title="Link to the header: Nightly builds" href="#nightly-builds" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>While not strictly a language change, nightly builds are now available by installing with the following command:</p>

<pre><code class="language-Shell">npm install -g typescript@next
</code></pre>
    
      <h2 id="adjustments-in-module-resolution-logic">
        
        
          Adjustments in module resolution logic <a aria-label="Link to the header: Adjustments in module resolution logic" title="Link to the header: Adjustments in module resolution logic" href="#adjustments-in-module-resolution-logic" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting ‘commonjs’. These <a href="https://github.com/Microsoft/TypeScript/issues/2338">rules</a> attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using <code>--moduleResolution</code> command line option. Possible values are:</p>
<ul>
  <li>‘classic’ - module resolution rules used by pre 1.6 TypeScript compiler</li>
  <li>‘node’ - node-like module resolution</li>
</ul>
    
      <h2 id="merging-ambient-class-and-interface-declaration">
        
        
          Merging ambient class and interface declaration <a aria-label="Link to the header: Merging ambient class and interface declaration" title="Link to the header: Merging ambient class and interface declaration" href="#merging-ambient-class-and-interface-declaration" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</p>

<pre><code class="language-ts">declare class Foo {
    public x : number;
}

interface Foo {
    y : string;
}

function bar(foo : Foo)  {
    foo.x = 1; // OK, declared in the class Foo
    foo.y = "1"; // OK, declared in the interface Foo
}
</code></pre>
    
      <h2 id="user-defined-type-guard-functions">
        
        
          User-defined type guard functions <a aria-label="Link to the header: User-defined type guard functions" title="Link to the header: User-defined type guard functions" href="#user-defined-type-guard-functions" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.6 adds a new way to narrow a variable type inside an <code>if</code> block, in addition to <code>typeof</code> and <code>instanceof</code>. A user-defined type guard functions is one with a return type annotation of the form <code>x is T</code>, where <code>x</code> is a declared parameter in the signature, and <code>T</code> is any type. When a user-defined type guard function is invoked on a variable in an <code>if</code> block, the type of the variable will be narrowed to <code>T</code>.</p>
    
      <h5 id="examples-2">
        
        
          Examples <a aria-label="Link to the header: Examples" title="Link to the header: Examples" href="#examples-2" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-ts">function isCat(a: any): a is Cat {
  return a.name === 'kitty';
}

var x: Cat | Dog;
if(isCat(x)) {
  x.meow(); // OK, x is Cat in this block
}
</code></pre>
    
      <h2 id="exclude-property-support-in-tsconfigjson">
        
        
          <code>exclude</code> property support in tsconfig.json <a aria-label="Link to the header: exclude property support in tsconfig.json" title="Link to the header: exclude property support in tsconfig.json" href="#exclude-property-support-in-tsconfigjson" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>A tsconfig.json file that doesn’t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</p>
<pre><code class="language-json">{
    "compilerOptions": {
        "out": "test.js"
    },
    "exclude": [
        "node_modules",
        "test.ts",
        "utils/t2.ts"
    ]
}
</code></pre>
<p>The <code>exclude</code> list does not support wilcards. It must simply be a list of files and/or directories.</p>
    
      <h2 id="--init-command-line-option">
        
        
          <code>--init</code> command line option <a aria-label="Link to the header: --init command line option" title="Link to the header: --init command line option" href="#--init-command-line-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Run <code>tsc --init</code> in a directory to create an initial <code>tsconfig.json</code> in this directory with preset defaults. Optionally pass command line arguments along with <code>--init</code> to be stored in your initial tsconfig.json on creation.</p>
    
      <h2 id="typescript-15">
        
        
          TypeScript 1.5 <a aria-label="Link to the header: TypeScript 1.5" title="Link to the header: TypeScript 1.5" href="#typescript-15" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="es6-modules">
        
        
          ES6 Modules <a aria-label="Link to the header: ES6 Modules" title="Link to the header: ES6 Modules" href="#es6-modules" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript’s original internal and external module constructs and the constructs can be mixed and matched at will.</p>
    
      <h4 id="export-declarations">
        
        
          Export Declarations <a aria-label="Link to the header: Export Declarations" title="Link to the header: Export Declarations" href="#export-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>In addition to the existing TypeScript support for decorating declarations with <code>export</code>, module members can also be exported using separate export declarations, optionally specifying different names for exports using <code>as</code> clauses.</p>

<pre><code class="language-ts">interface Stream { ... }
function writeToStream(stream: Stream, data: string) { ... }
export { Stream, writeToStream as write };  // writeToStream exported as write
</code></pre>

<p>Import declarations, as well, can optionally use <code>as</code> clauses to specify different local names for the imports. For example:</p>

<pre><code class="language-ts">import { read, write, standardOutput as stdout } from "./inout";
var s = read(stdout);
write(stdout, s);
</code></pre>

<p>As an alternative to individual imports, a namespace import can be used to import an entire module:</p>

<pre><code class="language-ts">import * as io from "./inout";
var s = io.read(io.standardOutput);
io.write(io.standardOutput, s);
</code></pre>
    
      <h4 id="re-exporting">
        
        
          Re-exporting <a aria-label="Link to the header: Re-exporting" title="Link to the header: Re-exporting" href="#re-exporting" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Using <code>from</code> clause a module can copy the exports of a given module to the current module without introducing local names.</p>

<pre><code class="language-ts">export { read, write, standardOutput as stdout } from "./inout";
</code></pre>

<p><code>export *</code> can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</p>

<pre><code class="language-ts">export function transform(s: string): string { ... }
export * from "./mod1";
export * from "./mod2";
</code></pre>
    
      <h4 id="default-export">
        
        
          Default Export <a aria-label="Link to the header: Default Export" title="Link to the header: Default Export" href="#default-export" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>An export default declaration specifies an expression that becomes the default export of a module:</p>

<pre><code class="language-ts">export default class Greeter {
    sayHello() {
        console.log("Greetings!");
    }
}
</code></pre>

<p>Which in turn can be imported using default imports:</p>

<pre><code class="language-ts">import Greeter from "./greeter";
var g = new Greeter();
g.sayHello();
</code></pre>
    
      <h4 id="bare-import">
        
        
          Bare Import <a aria-label="Link to the header: Bare Import" title="Link to the header: Bare Import" href="#bare-import" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>A “bare import” can be used to import a module only for its side-effects.</p>

<pre><code class="language-ts">import "./polyfills";
</code></pre>

<p>For more information about module, please see the <a href="https://github.com/Microsoft/TypeScript/issues/2242">ES6 module support spec</a>.</p>
    
      <h2 id="destructuring-in-declarations-and-assignments">
        
        
          Destructuring in declarations and assignments <a aria-label="Link to the header: Destructuring in declarations and assignments" title="Link to the header: Destructuring in declarations and assignments" href="#destructuring-in-declarations-and-assignments" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</p>
    
      <h4 id="declarations">
        
        
          Declarations <a aria-label="Link to the header: Declarations" title="Link to the header: Declarations" href="#declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</p>

<p>For example, the following sample declares variables <code>x</code>, <code>y</code>, and <code>z</code>, and initializes them to <code>getSomeObject().x</code>, <code>getSomeObject().y</code> and <code>getSomeObject().z</code> respectively:</p>

<pre><code class="language-ts">var { x, y, z} = getSomeObject();
</code></pre>

<p>Destructuring declarations also works for extracting values from arrays:</p>

<pre><code class="language-ts">var [x, y, z = 10] = getSomeArray();
</code></pre>

<p>Similarly, destructuring  can be used in function parameter declarations:</p>

<pre><code class="language-ts">function drawText({ text = "", location: [x, y] = [0, 0], bold = false }) {
    // Draw text
}

// Call drawText with an object literal
var item = { text: "someText", location: [1,2,3], style: "italics" };
drawText(item);
</code></pre>
    
      <h4 id="assignments">
        
        
          Assignments <a aria-label="Link to the header: Assignments" title="Link to the header: Assignments" href="#assignments" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<p>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</p>

<pre><code class="language-ts">var x = 1;
var y = 2;
[x, y] = [y, x];
</code></pre>
    
      <h2 id="namespace-keyword">
        
        
          <code>namespace</code> keyword <a aria-label="Link to the header: namespace keyword" title="Link to the header: namespace keyword" href="#namespace-keyword" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript used the <code>module</code> keyword to define both “internal modules” and “external modules”; this has been a bit of confusion for developers new to TypeScript. “Internal modules” are closer to what most people would call a namespace; likewise, “external modules” in JS speak really just are modules now.</p>

<blockquote>
  <p>Note: Previous syntax defining internal modules are still supported.</p>
</blockquote>

<p><strong>Before</strong>:</p>
<pre><code class="language-ts">module Math {
    export function add(x, y) { ... }
}
</code></pre>

<p><strong>After</strong>:</p>
<pre><code class="language-ts">namespace Math {
    export function add(x, y) { ... }
}
</code></pre>
    
      <h2 id="let-and-const-support">
        
        
          <code>let</code> and <code>const</code> support <a aria-label="Link to the header: let and const support" title="Link to the header: let and const support" href="#let-and-const-support" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
<p>ES6 <code>let</code> and <code>const</code> declarations are now supported when targeting ES3 and ES5.</p>
    
      <h4 id="const">
        
        
          Const <a aria-label="Link to the header: Const" title="Link to the header: Const" href="#const" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">const MAX = 100;

++MAX; // Error: The operand of an increment or decrement
       //        operator cannot be a constant.
</code></pre>
    
      <h4 id="block-scoped">
        
        
          Block scoped <a aria-label="Link to the header: Block scoped" title="Link to the header: Block scoped" href="#block-scoped" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h4>

<pre><code class="language-ts">if (true) {
  let a = 4;
  // use a
}
else {
  let a = "string";
  // use a
}

alert(a); // Error: a is not defined in this scope
</code></pre>
    
      <h2 id="forof-support">
        
        
          for..of support <a aria-label="Link to the header: for..of support" title="Link to the header: for..of support" href="#forof-support" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targetting ES6.</p>
    
      <h5 id="example-90">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-90" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</p>

<pre><code class="language-ts">for (var v of expr) { }
</code></pre>

<p>will be emitted as:</p>

<pre><code class="language-js">for (var _i = 0, _a = expr; _i &lt; _a.length; _i++) {
    var v = _a[_i];
}
</code></pre>
    
      <h2 id="decorators">
        
        
          Decorators <a aria-label="Link to the header: Decorators" title="Link to the header: Decorators" href="#decorators" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
<blockquote>
  <p>TypeScript decorators are based on the <a href="https://github.com/wycats/javascript-decorators">ES7 decorator proposal</a>.</p>
</blockquote>

<p>A decorator is:</p>
<ul>
  <li>an expression</li>
  <li>that evaluates to a function</li>
  <li>that takes the target, name, and property descriptor as arguments</li>
  <li>and optionally returns a property descriptor to install on the target object</li>
</ul>

<blockquote>
  <p>For more information, please see the <a href="https://github.com/Microsoft/TypeScript/issues/2249">Decorators</a> proposal.</p>
</blockquote>
    
      <h5 id="example-91">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-91" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<p>Decorators <code>readonly</code> and <code>enumerable(false)</code> will be applied to the property <code>method</code> before it is installed on class <code>C</code>. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</p>

<pre><code class="language-ts">class C {
  @readonly
  @enumerable(false)
  method() { }
}

function readonly(target, key, descriptor) {
    descriptor.writable = false;
}

function enumerable(value) {
  return function (target, key, descriptor) {
     descriptor.enumerable = value;
  }
}
</code></pre>
    
      <h2 id="computed-properties">
        
        
          Computed properties <a aria-label="Link to the header: Computed properties" title="Link to the header: Computed properties" href="#computed-properties" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
<p>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</p>

<pre><code class="language-ts">type NeighborMap = { [name: string]: Node };
type Node = { name: string; neighbors: NeighborMap;}

function makeNode(name: string, initialNeighbor: Node): Node {
    var neighbors: NeighborMap = {};
    neighbors[initialNeighbor.name] = initialNeighbor;
    return { name: name, neighbors: neighbors };
}
</code></pre>

<p>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</p>

<pre><code class="language-ts">function makeNode(name: string, initialNeighbor: Node): Node {
    return {
        name: name,
        neighbors: {
            [initialNeighbor.name]: initialNeighbor
        }
    }
}
</code></pre>
    
      <h2 id="support-for-umd-and-system-module-output">
        
        
          Support for <code>UMD</code> and <code>System</code> module output <a aria-label="Link to the header: Support for UMD and System module output" title="Link to the header: Support for UMD and System module output" href="#support-for-umd-and-system-module-output" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In addition to <code>AMD</code> and <code>CommonJS</code> module loaders, TypeScript now supports emitting modules <code>UMD</code> (<a href="https://github.com/umdjs/umd">Universal Module Definition</a>) and <a href="https://github.com/systemjs/systemjs"><code>System</code></a> module formats.</p>

<p><strong>Usage</strong>:</p>
<blockquote>
  <p>tsc –module umd</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>tsc –module system</p>
</blockquote>
    
      <h2 id="unicode-codepoint-escapes-in-strings">
        
        
          Unicode codepoint escapes in strings <a aria-label="Link to the header: Unicode codepoint escapes in strings" title="Link to the header: Unicode codepoint escapes in strings" href="#unicode-codepoint-escapes-in-strings" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</p>

<p>As an example, consider the need to escape a string that contains the character ‘𠮷’.  In UTF-16/UCS2, ‘𠮷’ is represented as a surrogate pair, meaning that it’s encoded using a pair of 16-bit code units of values, specifically <code>0xD842</code> and <code>0xDFB7</code>. Previously this meant that you’d have to escape the codepoint as <code>"\uD842\uDFB7"</code>. This has the major downside that it’s difficult to discern two independent characters from a surrogate pair.</p>

<p>With ES6’s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: <code>"\u{20bb7}"</code>. TypeScript will emit the string in ES3/ES5 as <code>"\uD842\uDFB7"</code>.</p>
    
      <h2 id="tagged-template-strings-in-es3es5">
        
        
          Tagged template strings in ES3/ES5 <a aria-label="Link to the header: Tagged template strings in ES3/ES5" title="Link to the header: Tagged template strings in ES3/ES5" href="#tagged-template-strings-in-es3es5" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by <a href="https://github.com/ivogabe">@ivogabe</a>, we bridged the gap for for tagged templates in ES3 and ES5.</p>

<p>When targeting ES3/ES5, the following code</p>

<pre><code class="language-ts">function oddRawStrings(strs: TemplateStringsArray, n1, n2) {
    return strs.raw.filter((raw, index) =&gt; index % 2 === 1);
}

oddRawStrings `Hello \n${123} \t ${456}\n world`
</code></pre>

<p>will be emitted as</p>

<pre><code class="language-js">function oddRawStrings(strs, n1, n2) {
    return strs.raw.filter(function (raw, index) {
        return index % 2 === 1;
    });
}
(_a = ["Hello \n", " \t ", "\n world"], _a.raw = ["Hello \\n", " \\t ", "\\n world"], oddRawStrings(_a, 123, 456));
var _a;
</code></pre>
    
      <h2 id="amd-dependency-optional-names">
        
        
          AMD-dependency optional names <a aria-label="Link to the header: AMD-dependency optional names" title="Link to the header: AMD-dependency optional names" href="#amd-dependency-optional-names" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>/// &lt;amd-dependency path="x" /&gt;</code> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call; however, there was no way to consume this module in the TS code.</p>

<p>The new <code>amd-dependency name</code> property allows passing an optional name for an amd-dependency:</p>

<pre><code class="language-ts">/// &lt;amd-dependency path="legacy/moduleA" name="moduleA"/&gt;
declare var moduleA:MyType
moduleA.callStuff()
</code></pre>

<p>Generated JS code:</p>

<pre><code class="language-js">define(["require", "exports", "legacy/moduleA"], function (require, exports, moduleA) {
    moduleA.callStuff()
});
</code></pre>
    
      <h2 id="project-support-through-tsconfigjson">
        
        
          Project support through <code>tsconfig.json</code> <a aria-label="Link to the header: Project support through tsconfig.json" title="Link to the header: Project support through tsconfig.json" href="#project-support-through-tsconfigjson" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Adding a <code>tsconfig.json</code> file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</p>

<ul>
  <li>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</li>
  <li>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</li>
</ul>
    
      <h5 id="example-92">
        
        
          Example <a aria-label="Link to the header: Example" title="Link to the header: Example" href="#example-92" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h5>

<pre><code class="language-json">{
    "compilerOptions": {
        "module": "commonjs",
        "noImplicitAny": true,
        "sourceMap": true,
    }
}
</code></pre>

<p>See the <a href="https://github.com/Microsoft/TypeScript/wiki/tsconfig.json">tsconfig.json wiki page</a> for more details.</p>
    
      <h2 id="--rootdir-command-line-option">
        
        
          <code>--rootDir</code> command line option <a aria-label="Link to the header: --rootDir command line option" title="Link to the header: --rootDir command line option" href="#--rootdir-command-line-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Option <code>--outDir</code> duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</p>

<p>Sometimes this is not desirable, for instance inputs <code>FolderA/FolderB/1.ts</code> and <code>FolderA/FolderB/2.ts</code> would result in output structure mirroring <code>FolderA/FolderB/</code>. Now if a new file <code>FolderA/3.ts</code> is added to the input, the output structure will pop out to mirror <code>FolderA/</code>.</p>

<p><code>--rootDir</code> specifies the input directory to be mirrored in output instead of computing it.</p>
    
      <h2 id="--noemithelpers-command-line-option">
        
        
          <code>--noEmitHelpers</code> command line option <a aria-label="Link to the header: --noEmitHelpers command line option" title="Link to the header: --noEmitHelpers command line option" href="#--noemithelpers-command-line-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The TypeScript compiler emits a few helpers like <code>__extends</code> when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use <code>--noEmitHelpers</code> to instructs the compiler not to emit them.</p>
    
      <h2 id="--newline-command-line-option">
        
        
          <code>--newLine</code> command line option <a aria-label="Link to the header: --newLine command line option" title="Link to the header: --newLine command line option" href="#--newline-command-line-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>By default the output new line character is <code>\r\n</code> on Windows based systems and <code>\n</code> on *nix based systems. <code>--newLine</code> command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</p>
    
      <h2 id="--inlinesourcemap-and-inlinesources-command-line-options">
        
        
          <code>--inlineSourceMap</code> and <code>inlineSources</code> command line options <a aria-label="Link to the header: --inlineSourceMap and inlineSources command line options" title="Link to the header: --inlineSourceMap and inlineSources command line options" href="#--inlinesourcemap-and-inlinesources-command-line-options" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p><code>--inlineSourceMap</code> causes source map files to be written inline in the generated <code>.js</code> files instead of in a independent <code>.js.map</code> file.  <code>--inlineSources</code> allows for additionally inlining the source <code>.ts</code> file into the</p>
    
      <h2 id="typescript-14">
        
        
          TypeScript 1.4 <a aria-label="Link to the header: TypeScript 1.4" title="Link to the header: TypeScript 1.4" href="#typescript-14" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="union-types">
        
        
          Union types <a aria-label="Link to the header: Union types" title="Link to the header: Union types" href="#union-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h3 id="overview">
        
        
          Overview <a aria-label="Link to the header: Overview" title="Link to the header: Overview" href="#overview" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a <code>string</code>, a <code>string[]</code> or a function that returns a <code>string</code>. You can now write:</p>

<pre><code class="language-ts">interface RunOptions {
   program: string;
   commandline: string[]|string|(() =&gt; string);
}
</code></pre>

<p>Assignment to union types works very intuitively – anything you could assign to one of the union type’s members is assignable to the union:</p>

<pre><code class="language-ts">var opts: RunOptions = /* ... */;
opts.commandline = '-hello world'; // OK
opts.commandline = ['-hello', 'world']; // OK
opts.commandline = [42]; // Error, number is not string or string[]
</code></pre>

<p>When reading from a union type, you can see any properties that are shared by them:</p>

<pre><code class="language-ts">if (opts.length === 0) { // OK, string and string[] both have 'length' property
  console.log("it's empty");
}
</code></pre>

<p>Using Type Guards, you can easily work with a variable of a union type:</p>

<pre><code class="language-ts">function formatCommandline(c: string|string[]) {
    if (typeof c === 'string') {
        return c.trim();
    }
    else {
        return c.join(' ');
    }
}
</code></pre>
    
      <h3 id="stricter-generics">
        
        
          Stricter Generics <a aria-label="Link to the header: Stricter Generics" title="Link to the header: Stricter Generics" href="#stricter-generics" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>With union types able to represent a wide range of type scenarios, we’ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</p>

<pre><code class="language-ts">function equal&lt;T&gt;(lhs: T, rhs: T): boolean {
  return lhs === rhs;
}

// Previously: No error
// New behavior: Error, no best common type between 'string' and 'number'
var e = equal(42, 'hello');
</code></pre>
<p>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</p>

<pre><code class="language-ts">// 'choose' function where types must match
function choose1&lt;T&gt;(a: T, b: T): T { return Math.random() &gt; 0.5 ? a : b }
var a = choose1('hello', 42); // Error
var b = choose1&lt;string|number&gt;('hello', 42); // OK

// 'choose' function where types need not match
function choose2&lt;T, U&gt;(a: T, b: U): T|U { return Math.random() &gt; 0.5 ? a : b }
var c = choose2('bar', 'foo'); // OK, c: string
var d = choose2('hello', 42); // OK, d: string|number
</code></pre>
    
      <h3 id="better-type-inference">
        
        
          Better Type Inference <a aria-label="Link to the header: Better Type Inference" title="Link to the header: Better Type Inference" href="#better-type-inference" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h3>

<p>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</p>

<pre><code class="language-ts">var x = [1, 'hello']; // x: Array&lt;string|number&gt;
x[0] = 'world'; // OK
x[0] = false; // Error, boolean is not string or number
</code></pre>
    
      <h2 id="let-declarations">
        
        
          <code>let</code> declarations <a aria-label="Link to the header: let declarations" title="Link to the header: let declarations" href="#let-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>In JavaScript, <code>var</code> declarations are “hoisted” to the top of their enclosing scope. This can result in confusing bugs:</p>

<pre><code class="language-ts">console.log(x); // meant to write 'y' here
/* later in the same block */
var x = 'hello';
</code></pre>

<p>The new ES6 keyword <code>let</code>, now supported in TypeScript, declares a variable with more intuitive “block” semantics. A <code>let</code> variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</p>

<pre><code class="language-ts">if (foo) {
    console.log(x); // Error, cannot refer to x before its declaration
    let x = 'hello';
}
else {
    console.log(x); // Error, x is not declared in this block
}
</code></pre>

<p><code>let</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>
    
      <h2 id="const-declarations">
        
        
          <code>const</code> declarations <a aria-label="Link to the header: const declarations" title="Link to the header: const declarations" href="#const-declarations" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
<p>The other new ES6 declaration type supported in TypeScript is <code>const</code>. A <code>const</code> variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don’t want to change the value after its initialization:</p>

<pre><code class="language-ts">const halfPi = Math.PI / 2;
halfPi = 2; // Error, can't assign to a `const`
</code></pre>

<p><code>const</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>
    
      <h2 id="template-strings">
        
        
          Template strings <a aria-label="Link to the header: Template strings" title="Link to the header: Template strings" href="#template-strings" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</p>

<pre><code class="language-ts">var name = "TypeScript";
var greeting  = `Hello, ${name}! Your name has ${name.length} characters`;
</code></pre>

<p>When compiling to pre-ES6 targets, the string is decomposed:</p>

<pre><code class="language-js">var name = "TypeScript!";
var greeting = "Hello, " + name + "! Your name has " + name.length + " characters";
</code></pre>
    
      <h2 id="type-guards">
        
        
          Type Guards <a aria-label="Link to the header: Type Guards" title="Link to the header: Type Guards" href="#type-guards" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>A common pattern in JavaScript is to use <code>typeof</code> or <code>instanceof</code> to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an <code>if</code> block.</p>

<p>Using <code>typeof</code> to test a variable:</p>

<pre><code class="language-ts">var x: any = /* ... */;
if(typeof x === 'string') {
    console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'
}
// x is still any here
x.unknown(); // OK
</code></pre>

<p>Using <code>typeof</code> with union types and <code>else</code>:</p>

<pre><code class="language-ts">var x: string | HTMLElement = /* ... */;
if(typeof x === 'string') {
    // x is string here, as shown above
}
else {
    // x is HTMLElement here
    console.log(x.innerHTML);
}
</code></pre>

<p>Using <code>instanceof</code> with classes and union types:</p>

<pre><code class="language-ts">class Dog { woof() { } }
class Cat { meow() { } }
var pet: Dog|Cat = /* ... */;
if (pet instanceof Dog) {
    pet.woof(); // OK
}
else {
    pet.woof(); // Error
}
</code></pre>
    
      <h2 id="type-aliases">
        
        
          Type Aliases <a aria-label="Link to the header: Type Aliases" title="Link to the header: Type Aliases" href="#type-aliases" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>You can now define an <em>alias</em> for a type using the <code>type</code> keyword:</p>

<pre><code class="language-ts">type PrimitiveArray = Array&lt;string|number|boolean&gt;;
type MyNumber = number;
type NgScope = ng.IScope;
type Callback = () =&gt; void;
</code></pre>

<p>Type aliases are exactly the same as their original types; they are simply alternative names.</p>
    
      <h2 id="const-enum-completely-inlined-enums">
        
        
          <code>const enum</code> (completely inlined enums) <a aria-label="Link to the header: const enum (completely inlined enums)" title="Link to the header: const enum (completely inlined enums)" href="#const-enum-completely-inlined-enums" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
<p>Enums are very useful, but some programs don’t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new <code>const enum</code> declaration works just like a regular <code>enum</code> for type safety, but erases completely at compile time.</p>

<pre><code class="language-ts">const enum Suit { Clubs, Diamonds, Hearts, Spades }
var d = Suit.Diamonds;
</code></pre>

<p>Compiles to exactly:</p>

<pre><code class="language-js">var d = 1;
</code></pre>

<p>TypeScript will also now compute enum values when possible:</p>

<pre><code class="language-ts">enum MyFlags {
  None = 0,
  Neat = 1,
  Cool = 2,
  Awesome = 4,
  Best = Neat | Cool | Awesome
}
var b = MyFlags.Best; // emits var b = 7;
</code></pre>
    
      <h2 id="-noemitonerror-commandline-option">
        
        
          <code>-noEmitOnError</code> commandline option <a aria-label="Link to the header: -noEmitOnError commandline option" title="Link to the header: -noEmitOnError commandline option" href="#-noemitonerror-commandline-option" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a <code>string</code> to a <code>number</code>). This can be undesirable on build servers or other scenarios where only output from a “clean” build is desired. The new flag <code>noEmitOnError</code> prevents the compiler from emitting .js code if there were any errors.</p>

<p>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</p>
    
      <h2 id="amd-module-names">
        
        
          AMD Module names <a aria-label="Link to the header: AMD Module names" title="Link to the header: AMD Module names" href="#amd-module-names" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundler (e.g. <code>r.js</code>).</p>

<p>The new <code>amd-module name</code> tag allows passing an optional module name to the compiler:</p>

<pre><code class="language-ts">//// [amdModule.ts]
///&lt;amd-module name='NamedModule'/&gt;
export class C {
}
</code></pre>
<p>Will result in assigning the name <code>NamedModule</code> to the module as part of calling the AMD <code>define</code>:</p>

<pre><code class="language-js">//// [amdModule.js]
define("NamedModule", ["require", "exports"], function (require, exports) {
    var C = (function () {
        function C() {
        }
        return C;
    })();
    exports.C = C;
});
</code></pre>
    
      <h2 id="typescript-13">
        
        
          TypeScript 1.3 <a aria-label="Link to the header: TypeScript 1.3" title="Link to the header: TypeScript 1.3" href="#typescript-13" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="protected">
        
        
          Protected <a aria-label="Link to the header: Protected" title="Link to the header: Protected" href="#protected" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The new <code>protected</code> modifier in classes works like it does in familiar languages like C++, C#, and Java. A <code>protected</code> member of a class is visible only inside subclasses of the class in which it is declared:</p>

<pre><code class="language-ts">class Thing {
  protected doSomething() { /* ... */ }
}

class MyThing extends Thing {
  public myMethod() {
    // OK, can access protected member from subclass
    this.doSomething();
  }
}
var t = new MyThing();
t.doSomething(); // Error, cannot call protected member from outside class
</code></pre>
    
      <h2 id="tuple-types">
        
        
          Tuple types <a aria-label="Link to the header: Tuple types" title="Link to the header: Tuple types" href="#tuple-types" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a <code>string</code> at position 0 and a <code>number</code> at position 1:</p>

<pre><code class="language-ts">// Declare a tuple type
var x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
// Initialize it incorrectly
x = [10, 'hello']; // Error
</code></pre>

<p>When accessing an element with a known index, the correct type is retrieved:</p>

<pre><code class="language-ts">console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'
</code></pre>

<p>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</p>

<pre><code class="language-ts">x[3] = 'world'; // OK
console.log(x[5].toString()); // OK, 'string' and 'number' both have toString
x[6] = true; // Error, boolean isn't number or string
</code></pre>
    
      <h2 id="typescript-11">
        
        
          TypeScript 1.1 <a aria-label="Link to the header: TypeScript 1.1" title="Link to the header: TypeScript 1.1" href="#typescript-11" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>
    
      <h2 id="performance-improvements">
        
        
          Performance Improvements <a aria-label="Link to the header: Performance Improvements" title="Link to the header: Performance Improvements" href="#performance-improvements" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>The 1.1 compiler is typically around 4x faster than any previous release. See <a href="http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx">this blog post for some impressive charts.</a></p>
    
      <h2 id="better-module-visibility-rules">
        
        
          Better Module Visibility Rules <a aria-label="Link to the header: Better Module Visibility Rules" title="Link to the header: Better Module Visibility Rules" href="#better-module-visibility-rules" class="anchor-hash" title="Link to this header">#</a>
        
        
      </h2>

<p>TypeScript now only strictly enforces the visibility of types in modules if the <code>--declaration</code> flag is provided. This is very useful for Angular scenarios, for example:</p>

<pre><code class="language-ts">module MyControllers {
  interface ZooScope extends ng.IScope {
    animals: Animal[];
  }
  export class ZooController {
    // Used to be an error (cannot expose ZooScope), but now is only
    // an error when trying to generate .d.ts files
    constructor(public $scope: ZooScope) { }
    /* more code */
  }
}
</code></pre>


          </article>
        </div>
        </div>
    </a>

<script type="text/javascript">

      $(function() {
        //$(".tocAccordion").accordion();
        setDocTOC();
        hljs.initHighlightingOnLoad();
      });

</script>

	</main>
	<footer role="contentinfo">
    <div class="container-fluid signature-container">
        <div class="container">
            <div class="row signature">
                <div class="col-sm-7 col-xs-12">
                    <p class="pull-left">Made with <span class="glyphicon glyphicon-heart"></span> in Redmond</p>
                    <div class="twitter-buttons pull-left">
                        <a class="twitter-follow-button" href="https://twitter.com/typescript/">Follow @typescript</a>
                    </div>
                </div>
                <div class="col-sm-5 col-xs-12">
                    <img class="ms-logo-footer pull-right" src="/assets/images/Microsoft-logo_rgb_c-gray.svg" alt="Microsoft logo"/>
                    <p class="copyright pull-right">&copy;2012-2020 Microsoft</p>
                    <p class="privacy pull-right"><a href="https://go.microsoft.com/fwlink/?LinkId=521839" data-mscc-ic="false">Privacy</a></p>
                </div>
            </div>
        </div>
    </div>
</footer>

</body>
<!-- JS -->
<script src="/assets/js/libraries.5f479ded.js"></script>
<!-- at the end of the BODY -->

<script type="text/javascript">
docsearch({
  apiKey: '3c2db2aef0c7ff26e8911267474a9b2c',
  indexName: 'typescriptlang',
  inputSelector: '.site-search',
  debug: true // Set debug to true if you want to inspect the dropdown
});
</script>

</html>
